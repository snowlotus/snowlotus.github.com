{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/img/vue-components-bus-01.png","path":"img/vue-components-bus-01.png","modified":0,"renderable":0},{"_id":"source/img/css-interview/boxmodel.png","path":"img/css-interview/boxmodel.png","modified":0,"renderable":0},{"_id":"source/img/js-black-tech/1.jpg","path":"img/js-black-tech/1.jpg","modified":0,"renderable":0},{"_id":"source/img/js-black-tech/12.jpg","path":"img/js-black-tech/12.jpg","modified":0,"renderable":0},{"_id":"source/img/js-black-tech/10.jpg","path":"img/js-black-tech/10.jpg","modified":0,"renderable":0},{"_id":"source/img/js-black-tech/11.jpg","path":"img/js-black-tech/11.jpg","modified":0,"renderable":0},{"_id":"source/img/js-black-tech/13.jpg","path":"img/js-black-tech/13.jpg","modified":0,"renderable":0},{"_id":"source/img/js-black-tech/15.jpg","path":"img/js-black-tech/15.jpg","modified":0,"renderable":0},{"_id":"source/img/js-black-tech/16.jpg","path":"img/js-black-tech/16.jpg","modified":0,"renderable":0},{"_id":"source/img/js-black-tech/14.jpg","path":"img/js-black-tech/14.jpg","modified":0,"renderable":0},{"_id":"source/img/js-black-tech/17.jpg","path":"img/js-black-tech/17.jpg","modified":0,"renderable":0},{"_id":"source/img/js-black-tech/18.jpg","path":"img/js-black-tech/18.jpg","modified":0,"renderable":0},{"_id":"source/img/js-black-tech/19.jpg","path":"img/js-black-tech/19.jpg","modified":0,"renderable":0},{"_id":"source/img/js-black-tech/2.jpg","path":"img/js-black-tech/2.jpg","modified":0,"renderable":0},{"_id":"source/img/js-black-tech/21.jpg","path":"img/js-black-tech/21.jpg","modified":0,"renderable":0},{"_id":"source/img/js-black-tech/20.jpg","path":"img/js-black-tech/20.jpg","modified":0,"renderable":0},{"_id":"source/img/js-black-tech/22.jpg","path":"img/js-black-tech/22.jpg","modified":0,"renderable":0},{"_id":"source/img/js-black-tech/26.jpg","path":"img/js-black-tech/26.jpg","modified":0,"renderable":0},{"_id":"source/img/js-black-tech/23.jpg","path":"img/js-black-tech/23.jpg","modified":0,"renderable":0},{"_id":"source/img/js-black-tech/24.jpg","path":"img/js-black-tech/24.jpg","modified":0,"renderable":0},{"_id":"source/img/js-black-tech/25.jpg","path":"img/js-black-tech/25.jpg","modified":0,"renderable":0},{"_id":"source/img/js-black-tech/27.jpg","path":"img/js-black-tech/27.jpg","modified":0,"renderable":0},{"_id":"source/img/js-black-tech/28.jpg","path":"img/js-black-tech/28.jpg","modified":0,"renderable":0},{"_id":"source/img/js-black-tech/3.jpg","path":"img/js-black-tech/3.jpg","modified":0,"renderable":0},{"_id":"source/img/js-black-tech/29.jpg","path":"img/js-black-tech/29.jpg","modified":0,"renderable":0},{"_id":"source/img/js-black-tech/30.jpg","path":"img/js-black-tech/30.jpg","modified":0,"renderable":0},{"_id":"source/img/js-black-tech/31.jpg","path":"img/js-black-tech/31.jpg","modified":0,"renderable":0},{"_id":"source/img/js-black-tech/32.jpg","path":"img/js-black-tech/32.jpg","modified":0,"renderable":0},{"_id":"source/img/js-black-tech/33.gif","path":"img/js-black-tech/33.gif","modified":0,"renderable":0},{"_id":"source/img/js-black-tech/34.jpg","path":"img/js-black-tech/34.jpg","modified":0,"renderable":0},{"_id":"source/img/js-black-tech/35.jpg","path":"img/js-black-tech/35.jpg","modified":0,"renderable":0},{"_id":"source/img/js-black-tech/4.jpg","path":"img/js-black-tech/4.jpg","modified":0,"renderable":0},{"_id":"source/img/js-black-tech/5.jpg","path":"img/js-black-tech/5.jpg","modified":0,"renderable":0},{"_id":"source/img/js-black-tech/8.jpg","path":"img/js-black-tech/8.jpg","modified":0,"renderable":0},{"_id":"source/img/js-black-tech/6.jpg","path":"img/js-black-tech/6.jpg","modified":0,"renderable":0},{"_id":"source/img/js-black-tech/7.jpg","path":"img/js-black-tech/7.jpg","modified":0,"renderable":0},{"_id":"source/img/readme-img/readme3.png","path":"img/readme-img/readme3.png","modified":0,"renderable":0},{"_id":"source/img/readme-img/readme2.png","path":"img/readme-img/readme2.png","modified":0,"renderable":0},{"_id":"source/img/readme-img/readme1.png","path":"img/readme-img/readme1.png","modified":0,"renderable":0},{"_id":"themes/vexo/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/vexo/source/js/qrious.js","path":"js/qrious.js","modified":0,"renderable":1},{"_id":"themes/vexo/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"source/img/js-black-tech/9.jpg","path":"img/js-black-tech/9.jpg","modified":0,"renderable":0},{"_id":"themes/vexo/source/css/images/catalog.png","path":"css/images/catalog.png","modified":0,"renderable":1},{"_id":"themes/vexo/source/css/images/escheres.png","path":"css/images/escheres.png","modified":0,"renderable":1},{"_id":"themes/vexo/source/css/images/menu.png","path":"css/images/menu.png","modified":0,"renderable":1},{"_id":"themes/vexo/source/css/images/top.png","path":"css/images/top.png","modified":0,"renderable":1},{"_id":"themes/vexo/source/css/images/logo.png","path":"css/images/logo.png","modified":0,"renderable":1},{"_id":"themes/vexo/source/css/images/vue_pro.jpg","path":"css/images/vue_pro.jpg","modified":0,"renderable":1},{"_id":"themes/vexo/source/css/plugins/gitment.css","path":"css/plugins/gitment.css","modified":0,"renderable":1},{"_id":"themes/vexo/source/css/images/wechat.jpg","path":"css/images/wechat.jpg","modified":0,"renderable":1},{"_id":"themes/vexo/source/fonts/SourceSansPro.ttf","path":"fonts/SourceSansPro.ttf","modified":0,"renderable":1},{"_id":"themes/vexo/source/js/gitment.js","path":"js/gitment.js","modified":0,"renderable":1},{"_id":"themes/vexo/source/css/images/alipay.jpg","path":"css/images/alipay.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"46497473c82c145a22e67dc987c4ca74fabb58b3","modified":1560396318509},{"_id":"themes/vexo/_config.yml","hash":"973e573a03213133eed395dc0082e7720698c5b9","modified":1560392781600},{"_id":"themes/vexo/lint.sh","hash":"f580302e4aa9ccfb95a253851da6501d145613fe","modified":1554884101374},{"_id":"themes/vexo/package.json","hash":"8852c5a394ac59d219e5bbbcee10d573d33e1fc6","modified":1554884101374},{"_id":"source/_posts/fe-performance.md","hash":"26932a3fd52658fe39f9538153df968434801a8e","modified":1561713465568},{"_id":"source/_posts/javascript-function.md","hash":"b3c1a02d3f0c5bdfbb2b28c9660df2d1cfdc2cce","modified":1554884101345},{"_id":"source/_posts/css-interview.md","hash":"8d2b492c057eff52cbdb49a1f0b1d103639f0067","modified":1554947947157},{"_id":"source/_posts/2018-read-book.md","hash":"cd546833529d33808edcde333bfefebbb9a6f708","modified":1554948084473},{"_id":"source/_posts/mpvue-weui.md","hash":"f53b726eb717cba4a3b474c8ada588f195c12513","modified":1554884101346},{"_id":"source/_posts/javascript-traverse.md","hash":"128d7792f52f53c12476bd1aefabbbd3864a57e3","modified":1554884101346},{"_id":"source/_posts/A-step-by-step-guide-to-single-spa.md","hash":"dfb949c4f5ce297ea1862086718deb8022a04ce0","modified":1573007753330},{"_id":"source/_posts/pay-yourself-first.md","hash":"5bfae99984c130a33206249b19a11532c4df34e2","modified":1554947179607},{"_id":"source/_posts/the-best-front-end-hacking-cheatsheets.md","hash":"e68723d699d1ad73ea371dbcd20732cdb14e8522","modified":1560237810605},{"_id":"source/_posts/note-of-the-difficulty-in-javascript.md","hash":"f3e8068bd595207a164bad25975e4aef5e0e5967","modified":1561360844122},{"_id":"source/_posts/the-difference-between-git-merge-and-git-rebase.md","hash":"95fc40495eba192edc17303f8a7d89f881e8e96a","modified":1560421623305},{"_id":"source/_posts/vue-component-communication.md","hash":"1dfeaa8cb30177f368397093b9589559ca6f98c6","modified":1554884101347},{"_id":"source/_posts/vue-router.md","hash":"54352e4ce7f5eb612958ceca940a6167dc0fdf69","modified":1554884101347},{"_id":"source/about/index.md","hash":"68c8af0453deca5f6b03eb18ee6f89fb0c1f1f75","modified":1554884101347},{"_id":"source/_posts/the-way-to-reading.md","hash":"8e0e25b0a7557471fba4aa5beb37d92429c7ec5b","modified":1554947414079},{"_id":"source/img/vue-components-bus-01.png","hash":"43eb2f5af409d03d39bc40726c0f07f6575dd0d4","modified":1554884101361},{"_id":"source/project/index.md","hash":"b8f5482c157514bd2df4ce8a4e4d01a957497924","modified":1554884101361},{"_id":"source/tags/index.md","hash":"80a15f1b5daff22b04849109e976bc91a410b83e","modified":1554884101361},{"_id":"themes/vexo/layout/about.ejs","hash":"8b1b8f38c9d54c818232aa5812ed935661ee6c53","modified":1554884101373},{"_id":"themes/vexo/layout/archive.ejs","hash":"af1b76141fe72a6a4e0280ed765e11966051045b","modified":1554884101373},{"_id":"themes/vexo/layout/index.ejs","hash":"5039a8285f040f3fb780c930e12e6d1ae5ce1305","modified":1554884101373},{"_id":"themes/vexo/layout/project.ejs","hash":"662e1b37d5f192d4d94ff335b17fd2be605e94e4","modified":1554884101374},{"_id":"themes/vexo/layout/layout.ejs","hash":"812c4390ba28e569420018fa562965135fdc1121","modified":1560396050095},{"_id":"themes/vexo/layout/page.ejs","hash":"cb9c216f9a33620c9cba0a303e8a910161b1eca9","modified":1560239129289},{"_id":"themes/vexo/layout/tags.ejs","hash":"acd4bec10562e6aab98b2347a44f3687e8f5e485","modified":1554884101374},{"_id":"themes/vexo/static/gitment.css","hash":"c245680e6900ca43514d2023bf1f0e1b539992dc","modified":1554884101387},{"_id":"source/img/css-interview/boxmodel.png","hash":"d489b0495c9cde1d7c692bebd227c31c9032739c","modified":1554884101348},{"_id":"source/img/js-black-tech/1.jpg","hash":"91668617234050baf4f3e7a6d1844f2d5e880f84","modified":1554884101348},{"_id":"source/img/js-black-tech/12.jpg","hash":"4be37ac08a0fe9e38e5cc48656270d74910966a6","modified":1554884101349},{"_id":"source/img/js-black-tech/10.jpg","hash":"c759aebf42ea7140d5086ebb676ce81dd39e493f","modified":1554884101349},{"_id":"source/img/js-black-tech/11.jpg","hash":"014983b3e8b7f5a5548b74a3362d629d0bfe519f","modified":1554884101349},{"_id":"source/img/js-black-tech/13.jpg","hash":"dc3e41a3b7e82e06011665467e6daf45ef5134f1","modified":1554884101350},{"_id":"source/img/js-black-tech/15.jpg","hash":"afdc8a79511de918ef022342f58388e625012690","modified":1554884101351},{"_id":"source/img/js-black-tech/16.jpg","hash":"4a47bfc4ab6055e794b0fd2aba9d7eb53ec055d1","modified":1554884101351},{"_id":"source/img/js-black-tech/14.jpg","hash":"e97358edd86cdf1b0c3f29368c41971ae36862e8","modified":1554884101350},{"_id":"source/img/js-black-tech/17.jpg","hash":"47dedb77e6370a61523d50d0f290511bd1281433","modified":1554884101351},{"_id":"source/img/js-black-tech/18.jpg","hash":"b37cd5ff118886bed5ad27816bfbc3833f944157","modified":1554884101351},{"_id":"source/img/js-black-tech/19.jpg","hash":"6ceb9685718da86bdb1035535285336109bb183c","modified":1554884101352},{"_id":"source/img/js-black-tech/2.jpg","hash":"41c88e12c1a888bedbdcf6bc328bb098d6948739","modified":1554884101352},{"_id":"source/img/js-black-tech/21.jpg","hash":"ea9392cd163f365c2f7569117e2365c97ec5bc06","modified":1554884101352},{"_id":"source/img/js-black-tech/20.jpg","hash":"828b64484eb25270363285992d1e1619b9820662","modified":1554884101352},{"_id":"source/img/js-black-tech/22.jpg","hash":"78d1ba6483f979ef8a0f24b90d47f3fb95870060","modified":1554884101353},{"_id":"source/img/js-black-tech/26.jpg","hash":"bbf2f91ea617c25ebfeb11d9f3aa56485fc351bb","modified":1554884101354},{"_id":"source/img/js-black-tech/23.jpg","hash":"b3ef99c290484802793b34e20e2b6f7fb232d54b","modified":1554884101353},{"_id":"source/img/js-black-tech/24.jpg","hash":"ffd6292ac755c5c4518ac568684121e6ae2e1a2d","modified":1554884101354},{"_id":"source/img/js-black-tech/25.jpg","hash":"7c656d744af341179d8ed9577c580258b018ede8","modified":1554884101354},{"_id":"source/img/js-black-tech/27.jpg","hash":"9662e55b263db80ec46541cbf7a433b9ba64b56d","modified":1554884101355},{"_id":"source/img/js-black-tech/28.jpg","hash":"2863428057966675e96e6f7113133be18e8aa4aa","modified":1554884101355},{"_id":"source/img/js-black-tech/3.jpg","hash":"71ca4963e98916f9f75178301020d94525bbafbe","modified":1554884101355},{"_id":"source/img/js-black-tech/29.jpg","hash":"1e33bed26fc51171fd210c7a1bf5a93744777332","modified":1554884101355},{"_id":"source/img/js-black-tech/30.jpg","hash":"fac81e3f3f97081512624a3fb5c5a53064533ba0","modified":1554884101355},{"_id":"source/img/js-black-tech/31.jpg","hash":"7578b39786038621ad8fe4a0ad214966ae10eb72","modified":1554884101356},{"_id":"source/img/js-black-tech/32.jpg","hash":"f0d75cff4778005c41ca956c760d14d84bb38ae5","modified":1554884101356},{"_id":"source/img/js-black-tech/33.gif","hash":"502aa094697821dc6c2ef8a33506f520ab7bf86f","modified":1554884101356},{"_id":"source/img/js-black-tech/34.jpg","hash":"cd94ad41297200a5bbde868b85a658b7411cb8e1","modified":1554884101357},{"_id":"source/img/js-black-tech/35.jpg","hash":"cd2d3e236a648af18e7afe38c6193732e8fcf024","modified":1554884101357},{"_id":"source/img/js-black-tech/4.jpg","hash":"816034556691307481956093a254d3a0d243e7e5","modified":1554884101357},{"_id":"source/img/js-black-tech/5.jpg","hash":"056830caef51b4a3a88da7120591ea7b308fc158","modified":1554884101358},{"_id":"source/img/js-black-tech/8.jpg","hash":"26365c6972c83d8068bf213ca3ce55f2fe7ebc03","modified":1554884101358},{"_id":"source/img/js-black-tech/6.jpg","hash":"488cf906927d4e297a9d184d1814bf029d5ca8fb","modified":1554884101358},{"_id":"source/img/js-black-tech/7.jpg","hash":"ffceee0f930afa1360408b01b11c5f53f1bcf347","modified":1554884101358},{"_id":"source/img/readme-img/readme3.png","hash":"9da143276cf0c7cb8dfa6407ebfa75fbcf730d89","modified":1554884101360},{"_id":"source/img/readme-img/readme2.png","hash":"3b198c29e8dbd62b1d3f06c4c83c4521c9afd083","modified":1554884101360},{"_id":"source/img/readme-img/readme1.png","hash":"a6e77f1dd3454083ea5136765af05e4d9894deb7","modified":1554884101360},{"_id":"themes/vexo/_source/project/index.md","hash":"b8f5482c157514bd2df4ce8a4e4d01a957497924","modified":1554884101370},{"_id":"themes/vexo/_source/about/index.md","hash":"68c8af0453deca5f6b03eb18ee6f89fb0c1f1f75","modified":1554884101370},{"_id":"themes/vexo/_source/tags/index.md","hash":"80a15f1b5daff22b04849109e976bc91a410b83e","modified":1554884101370},{"_id":"themes/vexo/layout/_partial/catalog.ejs","hash":"0352ce39c28074dcfc3bd6416680195eeb384fd1","modified":1554884101371},{"_id":"themes/vexo/layout/_partial/archive.ejs","hash":"9abbf14034d581569c0b6c992fe22035cb5306b3","modified":1554884101371},{"_id":"themes/vexo/layout/_partial/footer.ejs","hash":"71970630102ce6eb788689ebed388cceb6467dd0","modified":1560393708873},{"_id":"themes/vexo/layout/_partial/head.ejs","hash":"e8b1b4336a2a2921046271742e4018026b27672a","modified":1554884101372},{"_id":"themes/vexo/layout/_partial/header.ejs","hash":"bd53219f52f119fe29183674c789e46da6cd5843","modified":1554884101372},{"_id":"themes/vexo/layout/_partial/tag.ejs","hash":"afdfbe882e4179323dd185e66a7eeaa22342f5bf","modified":1554884101372},{"_id":"themes/vexo/layout/_partial/pager.ejs","hash":"3a1b9680fbfa3baa76933c7c17216996381ad241","modified":1554884101372},{"_id":"themes/vexo/layout/_partial/top.ejs","hash":"f09dea486246a580213005b21d4b38810dd16fb3","modified":1554884101373},{"_id":"themes/vexo/source/css/_config.styl","hash":"ded322f32ddb31ca9973d58d129be09d8994f74b","modified":1554884101375},{"_id":"themes/vexo/source/css/style.styl","hash":"10619b7dd0912709c0ccf74f439208bcef468ee2","modified":1554884101382},{"_id":"themes/vexo/source/js/qrious.js","hash":"a9271e81e2ac6a692b1c133811afa33f0f3d7dc5","modified":1554884101386},{"_id":"themes/vexo/source/js/script.js","hash":"79e35bcea678a0d057ef05a51ad9d2f816f9389a","modified":1554884101387},{"_id":"themes/vexo/static/gitment.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1554884101388},{"_id":"source/img/js-black-tech/9.jpg","hash":"40cd8f575902be648d037582af3427e909b0dab6","modified":1554884101359},{"_id":"themes/vexo/source/css/_partial/footer.styl","hash":"3a8762c7a3d33dfd820095735a19778259c6e7c9","modified":1554884101376},{"_id":"themes/vexo/source/css/_partial/about.styl","hash":"8fe2282486fbb59838cbea2202c6df8c471e0149","modified":1554884101375},{"_id":"themes/vexo/source/css/_partial/catalog.styl","hash":"37175d72f44bc0e354554c1dff67f7010169fb1b","modified":1554884101376},{"_id":"themes/vexo/source/css/_partial/header.styl","hash":"8fe5f3165628af0ce59a7e0fabbaab8f47f5bb52","modified":1554884101376},{"_id":"themes/vexo/source/css/_partial/archive.styl","hash":"d433506f00d0d84b7476ba9588e23ac0f9473c8a","modified":1554884101375},{"_id":"themes/vexo/source/css/_partial/project.styl","hash":"78bf52ed8a8e2a8ac0d7075e0afaaa42027c353d","modified":1554884101377},{"_id":"themes/vexo/source/css/_partial/markdown.styl","hash":"1ba71943cc3f4d734b1a0f7af93b7e4b41c9874f","modified":1554884101377},{"_id":"themes/vexo/source/css/_partial/tags.styl","hash":"5198a7f7c221341138ae5c65185e86b6e13e8e26","modified":1554884101377},{"_id":"themes/vexo/source/css/_partial/pager.styl","hash":"888384c67429c7568aa38b5ebe5acae3cc4de367","modified":1554884101377},{"_id":"themes/vexo/source/css/images/catalog.png","hash":"541d20dd600fc2c9230329ceb6885d86e6c151dd","modified":1554884101380},{"_id":"themes/vexo/source/css/images/escheres.png","hash":"55deece3236dcc2fb44c28dec3e8bacbb7b46542","modified":1554884101380},{"_id":"themes/vexo/source/css/images/menu.png","hash":"bdaa35eb1ed119caeb934e15a05b9f4a5396d957","modified":1554884101381},{"_id":"themes/vexo/source/css/images/top.png","hash":"611a257907474ca02828319f81b006c1d818bb84","modified":1554884101381},{"_id":"themes/vexo/source/css/images/logo.png","hash":"718c6e48956249121cf3cca1a22a99f8372a3f0d","modified":1554884101380},{"_id":"themes/vexo/source/css/images/vue_pro.jpg","hash":"ad09ea8a127671dba647a78724230be4af5b57df","modified":1554884101381},{"_id":"themes/vexo/source/css/plugins/gitment.css","hash":"541ff18d7f3542b5663dc6aad06d43e135332b71","modified":1554884101382},{"_id":"themes/vexo/source/css/images/wechat.jpg","hash":"89a1453354119058dba888a6d877f74948646f2e","modified":1554884101381},{"_id":"themes/vexo/source/fonts/SourceSansPro.ttf","hash":"1e9f0372c269da205fdbac8cf27cb9cf59f6ad45","modified":1554884101384},{"_id":"themes/vexo/source/js/gitment.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1554884101386},{"_id":"themes/vexo/source/css/images/alipay.jpg","hash":"1b38f67192cc4bf6b2ea7f31aab9451f4d3fbb18","modified":1554884101379},{"_id":"source/_posts/intro-of-react-native.md","hash":"5b7e0bfc74bc42c7ecbe1d341c5acdb0a8d10221","modified":1573008293422},{"_id":"public/about/index.html","hash":"e2a0441c71f34e4bb1a4fcc9649c7d0a6ab7a22a","modified":1573008330645},{"_id":"public/project/index.html","hash":"21e8b3ac77d241a2dd64ea0af18c51dc284ec19c","modified":1573008330645},{"_id":"public/2019/04/11/the-best-front-end-hacking-cheatsheets/index.html","hash":"1b56c71c5d0baade2d5a4cf3a38f601272438888","modified":1573008330666},{"_id":"public/2019/03/08/the-way-to-reading/index.html","hash":"a74517d9fd90c955cc6e95bf69bec04670ad42f4","modified":1573008330666},{"_id":"public/2018/03/20/pay-yourself-first/index.html","hash":"e7e1fe8ba44c982a76911a739e819f4f8905a367","modified":1573008330666},{"_id":"public/archives/index.html","hash":"4ad27874e066ac84d1402ce1cc71427c8b8d5d0d","modified":1573008330666},{"_id":"public/archives/page/2/index.html","hash":"12c12f6163b788702f90ec59ab14c0411233a151","modified":1573008330667},{"_id":"public/archives/2018/index.html","hash":"cfb72e1eb5d3c473be2f1547095b6e823092f60e","modified":1573008330667},{"_id":"public/archives/2018/02/index.html","hash":"7cfec9315bf37595a28633642840bb69bf3488b3","modified":1573008330667},{"_id":"public/archives/2018/03/index.html","hash":"8ca4f60e95888b450c7e429bb0f6d0b1d43f44c5","modified":1573008330667},{"_id":"public/archives/2019/index.html","hash":"5fb52516153e00fdb5df18fee7b568a888c20920","modified":1573008330667},{"_id":"public/archives/2019/01/index.html","hash":"d680a8041e830f31be3bacee4d7e49f2c5395075","modified":1573008330667},{"_id":"public/archives/2019/03/index.html","hash":"4b7b9e8a7095d29729e08c8cae4e53b27a2d387c","modified":1573008330668},{"_id":"public/archives/2019/04/index.html","hash":"b123ef1c53637381a9242af4cdad346c362dff5d","modified":1573008330668},{"_id":"public/archives/2019/06/index.html","hash":"dec91278f117be3766df98854e1d281f6450a8de","modified":1573008330668},{"_id":"public/index.html","hash":"15ffbd30f98ffa5e91338b31bcb32c23899ccbcd","modified":1573008330668},{"_id":"public/page/2/index.html","hash":"504d353c5f6589524c3e0c552dec5bfaa2bea8be","modified":1573008330668},{"_id":"public/tags/javascript/index.html","hash":"bb9e7bb745ad61928340f73b7c6afd7f522046ea","modified":1573008330668},{"_id":"public/tags/性能/index.html","hash":"febf47f9e4a51b122e3b5aa2641f2936ca796307","modified":1573008330668},{"_id":"public/tags/监控/index.html","hash":"0d66b383b0c25bb178908ccf0a30b51f88672592","modified":1573008330668},{"_id":"public/tags/CSS/index.html","hash":"afd3efc9d1595f12cae58fdc7e11cd92d48d2745","modified":1573008330668},{"_id":"public/tags/面试/index.html","hash":"e7bba811cd782b6cad4439ffe6c3dec632cdf58e","modified":1573008330668},{"_id":"public/tags/mpvue/index.html","hash":"52e8bd167c7a5ffa933b3b273d9128b294f781f2","modified":1573008330668},{"_id":"public/tags/vue/index.html","hash":"9b8b7072672ad4dce23fab34e43d51cc8d144565","modified":1573008330668},{"_id":"public/tags/小程序/index.html","hash":"d3554e408a17a7267571aaf3ea5830cc00e3336e","modified":1573008330668},{"_id":"public/tags/feelings/index.html","hash":"3ea8e6f5ba799140ea3920e3e832c9b04b8c857f","modified":1573008330668},{"_id":"public/tags/生活/index.html","hash":"07ca601d035295ba2e2fe3b96cbd601f02546f66","modified":1573008330668},{"_id":"public/tags/API/index.html","hash":"2961c0a1bcd76acd4002978a76c3000c6d7b1c3a","modified":1573008330668},{"_id":"public/tags/备忘单/index.html","hash":"d04e2bebcdd767089c6430d96911e260b5c8ed71","modified":1573008330668},{"_id":"public/tags/sheet/index.html","hash":"ad3ee2b67fe1a1d4e300ae84a99bdcf3cd3e0d30","modified":1573008330669},{"_id":"public/tags/读书/index.html","hash":"30fa6897b892f881326b6a7e1afdf6f7d7bf5c9e","modified":1573008330669},{"_id":"public/tags/git-merge-rebase/index.html","hash":"2c2bbe8d086ea106edea8e9ad39db775ad28850d","modified":1573008330669},{"_id":"public/tags/学习笔记/index.html","hash":"3675ee9f72af08e0a05f112bbee79864004de998","modified":1573008330669},{"_id":"public/tags/js/index.html","hash":"92a5b62831c4848dfafeedd05a9578d57f7546b5","modified":1573008330669},{"_id":"public/tags/知识梳理/index.html","hash":"4cdc4b1f146c9132544fc6348751a494f4083aca","modified":1573008330669},{"_id":"public/tags/index.html","hash":"ef1f40cf1cdb8519619a9eb38d3442c59a678541","modified":1573008330669},{"_id":"public/2019/06/28/fe-performance/index.html","hash":"5aad7f307f6e8383aaa5be91cd6c56ba9389bef6","modified":1573008330669},{"_id":"public/2019/06/18/note-of-the-difficulty-in-javascript/index.html","hash":"3e826154b6373504049a66085660173d7ea2e8a4","modified":1573008330669},{"_id":"public/2019/06/12/the-difference-between-git-merge-and-git-rebase/index.html","hash":"2c8d4fe84c55b05c6cf285ec93cf10ad2aca5915","modified":1573008330669},{"_id":"public/2019/01/01/2018-read-book/index.html","hash":"47b4dd6b6675f934bc96e27d3b040d69de27b888","modified":1573008330669},{"_id":"public/2018/03/20/mpvue-weui/index.html","hash":"ef7779539c6969bec9c5fd8fd979f404bf52fa0a","modified":1573008330669},{"_id":"public/2018/02/24/vue-router/index.html","hash":"3f03f1634e9be888c47a93bdeb7da2b93ff0a193","modified":1573008330669},{"_id":"public/2018/02/24/css-interview/index.html","hash":"24cae95049fdbacec5046097f15737a37e713d6a","modified":1573008330669},{"_id":"public/2018/02/11/javascript-traverse/index.html","hash":"975766ad6245e6692dbdd78b1f2dc4d6f36d89f0","modified":1573008330669},{"_id":"public/2018/02/08/javascript-function/index.html","hash":"601abf49f19613f142ad1bdf61e38972b7433519","modified":1573008330669},{"_id":"public/2018/02/08/vue-component-communication/index.html","hash":"fc6c2c132871225acf0b4735349878aae515ba5a","modified":1573008330670},{"_id":"public/2019/11/06/intro-of-react-native/index.html","hash":"1fa5529c836ccffb64def134c18dafea89b4feb1","modified":1573008330672},{"_id":"public/archives/2019/11/index.html","hash":"e03e22c06afd8cf489ca02f75a63c006e21a8439","modified":1573008330672},{"_id":"public/tags/react-native/index.html","hash":"7ff58361094d0de70d9751b625efced1191bfcc2","modified":1573008330672},{"_id":"public/tags/react/index.html","hash":"ed3d2c89f9745deb7bb78f124ceff4173f737cde","modified":1573008330672},{"_id":"public/tags/jsx/index.html","hash":"a3965ca77111832f92343f82a84b0cf8a8ebf40e","modified":1573008330672},{"_id":"public/tags/es6/index.html","hash":"dc90d7e17ef57775e4b9f71f07dea2e23eb854ad","modified":1573008330672}],"Category":[],"Data":[],"Page":[{"title":"About","layout":"about","_content":"","source":"about/index.md","raw":"---\ntitle: About\nlayout: about\n---","date":"2019-04-10T08:15:01.347Z","updated":"2019-04-10T08:15:01.347Z","path":"about/index.html","comments":1,"_id":"ck2mo4mx70001dt47nsid1fbh","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: Tags\nlayout: tags\n---\n","date":"2019-04-10T08:15:01.361Z","updated":"2019-04-10T08:15:01.361Z","path":"tags/index.html","comments":1,"_id":"ck2mo4myb0018dt4740l410o0","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Project","layout":"project","_content":"","source":"project/index.md","raw":"---\ntitle: Project\nlayout: project\n---\n","date":"2019-04-10T08:15:01.361Z","updated":"2019-04-10T08:15:01.361Z","path":"project/index.html","comments":1,"_id":"ck2mo4myd001adt4747yw3v6r","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"前端页面性能监控小结","date":"2019-06-28T06:59:36.000Z","summary":"性能监测是前端页面性能的重要一环，通过监测可以确定页面性能瓶颈，从而有针对性的展开具体的优化工作","_content":"\n性能监测是前端页面性能的重要一环，通过监测可以确定页面性能瓶颈，从而有针对性的展开具体的优化工作。\n在近期调研好伙伴性能优化的过程中，调研了下业界较推崇的两种方式，**可编程方案、可视化方案**。其中可视化方案又有两款比较好用的工具Performance和LightHouse，一起看看如何使用吧。\n\n### 可编程方案-W3C 性能 API\nwindow.Performance是W3C性能小组引入的API，通过相关属性我们可以获取到用户访问页面的每个阶段的精确时间，从而对性能进行分析。\n*目前好伙伴项目所接入的听云browser版，本质上也是基于这些api，将各项数据采集上报到听云服务器，并转化成可视化的页面展示方式用于分析页面各项指标*\n\n以下是performance对象的完整结构\n![performance](https://upload-images.jianshu.io/upload_images/8878545-e57eba8a5567836c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n其中timing下的时间戳和页面加载时间有一个对应关系，如下图所示\n![timing](https://upload-images.jianshu.io/upload_images/8878545-c1395036da4fbc0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n通过求两个时间点之间的差值，可以得出页面各个过程所花费的时间\n```javascript\nconst timing = window.performance.timing\n\n//DNS查询耗时\nconst domainTime = timing.domainLookupEnd - timing.domainLookupStart\n\n//TCP连接耗时\nconst tcpTime = timing.connectEnd - timing.connectStart\n\n//内容加载耗时(注意是否存在cache)\nconst loadTime = timing.responseEnd - timing.responseStart\n\n//白屏时间\nconst firstPaintTime = timing.domLoading - timing.fetchStart\n\n//可交互时间\nconst ttiTime = timing.domInteractive - timing.fetchStart\n\n// html加载完成时间;此时可以操作dom\nconst domReadyTime = timing.domContentLoadedEventEnd - timing.fetchStart\n\n// 页面完全加载完成时间\nconst loadCompleteTime = timing.loadEventStart - timing.fetchStart\n```\n\n### 可视化工具1——Performance\nPerformance是chrome浏览器开发者工具的一个面板，用于实时的记录和分析页面在运行时的各项指标。\n\n###### 使用方式\nF12打开开发者工具，选中 Performance 面板：\n![image.png](https://upload-images.jianshu.io/upload_images/8878545-f9c996290c521a50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/720)\n*选中实心圆按钮，Performance 会开始帮我们记录我们后续的交互操作；\n选中刷新箭头按钮，Performance 会将页面重新加载，计算加载过程中的性能表现。*\n\n![无痕模式](https://upload-images.jianshu.io/upload_images/8878545-e33b750c66028f83.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/720)\n\n*为了避免其它 Chrome 插件对页面的性能影响，建议最好在无痕模式下打开页面*\n\n###### 功能介绍及分析\n以下是好伙伴页面加载过程中的表现，红框部分依次为概述面板、详情面板及绿框的FPS、CPU和NET\n![好伙伴performance](https://upload-images.jianshu.io/upload_images/8878545-3c6a984e7cffd6cb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080)\n\n**概述面板：**页面性能的汇总\n\n**FPS：** 和动画性能密切相关的指标，表示每一秒的帧数。绿色柱状越高表示帧率越高，体验就越流畅。若出现红色块，则代表长时间帧，很可能会出现卡顿。（图中以绿色为主，说明动画性能并不糟糕。）\n\n**CPU：** 表示CPU的忙闲情况。（一般结合Summary 饼图一起看）\n\n**NET：** 展示各请求的耗时与前后顺序。\n\n**详情面板-Main：** 又称火焰图。在图中我们可以看到3条垂直的线，蓝线代表 DOMContentLoaded 时间， 绿线代表首次绘制（及白屏）的时间，红线代表 load 时间。\n**详情面板-Summary：** 结合CPU可得出，scripting过程最耗时（即脚本执行）\n\n### 可视化工具2——LightHouse\nLighthouse 是一个开源的自动化工具，和Performance不同的是，它可以直接生成一个报告，报告中会对各项指标和优化建议做一个具体的呈现。\n\n**具体操作：**\n方式1：在 Chrome 应用商店下载一个 LightHouse插件，打开要测试的那个页面，点击icon和“Generate report”按钮，即可生成性能报告了。\n方式2：chrome开发者工具下的audits面板可直接run audits （需要浏览器的版本大于60）\n下图是生成的报告，同样以好伙伴首页为例\n![LightHouse](https://upload-images.jianshu.io/upload_images/8878545-94c0585f7002b614.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n*上图从上到下依次为：*\n1.当前访问地址、访问时间、模拟设备、网络情况\n2.页面性能、PWA（渐进式 Web 应用）、可访问性、最佳实践、SEO 五项指标的评分情况\n3.每一项指标的细化评估\n4.改进建议以及预计的节省时间（**此项可作为重点依据进行优化** ）\n\n### 推荐阅读\n[使用 Lighthouse 审查网络应用](https://developers.google.com/web/tools/lighthouse/?hl=zh-cn)\n[Performance工具](https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference)\n[Performance API](https://developer.mozilla.org/en-US/docs/Web/API/Window/performance)\n\n\n\n\n","source":"_posts/fe-performance.md","raw":"---\ntitle: 前端页面性能监控小结\ndate: 2019-06-28 14:59:36\ntags: [javascript,性能,监控]\nsummary: 性能监测是前端页面性能的重要一环，通过监测可以确定页面性能瓶颈，从而有针对性的展开具体的优化工作\n\n---\n\n性能监测是前端页面性能的重要一环，通过监测可以确定页面性能瓶颈，从而有针对性的展开具体的优化工作。\n在近期调研好伙伴性能优化的过程中，调研了下业界较推崇的两种方式，**可编程方案、可视化方案**。其中可视化方案又有两款比较好用的工具Performance和LightHouse，一起看看如何使用吧。\n\n### 可编程方案-W3C 性能 API\nwindow.Performance是W3C性能小组引入的API，通过相关属性我们可以获取到用户访问页面的每个阶段的精确时间，从而对性能进行分析。\n*目前好伙伴项目所接入的听云browser版，本质上也是基于这些api，将各项数据采集上报到听云服务器，并转化成可视化的页面展示方式用于分析页面各项指标*\n\n以下是performance对象的完整结构\n![performance](https://upload-images.jianshu.io/upload_images/8878545-e57eba8a5567836c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n其中timing下的时间戳和页面加载时间有一个对应关系，如下图所示\n![timing](https://upload-images.jianshu.io/upload_images/8878545-c1395036da4fbc0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n通过求两个时间点之间的差值，可以得出页面各个过程所花费的时间\n```javascript\nconst timing = window.performance.timing\n\n//DNS查询耗时\nconst domainTime = timing.domainLookupEnd - timing.domainLookupStart\n\n//TCP连接耗时\nconst tcpTime = timing.connectEnd - timing.connectStart\n\n//内容加载耗时(注意是否存在cache)\nconst loadTime = timing.responseEnd - timing.responseStart\n\n//白屏时间\nconst firstPaintTime = timing.domLoading - timing.fetchStart\n\n//可交互时间\nconst ttiTime = timing.domInteractive - timing.fetchStart\n\n// html加载完成时间;此时可以操作dom\nconst domReadyTime = timing.domContentLoadedEventEnd - timing.fetchStart\n\n// 页面完全加载完成时间\nconst loadCompleteTime = timing.loadEventStart - timing.fetchStart\n```\n\n### 可视化工具1——Performance\nPerformance是chrome浏览器开发者工具的一个面板，用于实时的记录和分析页面在运行时的各项指标。\n\n###### 使用方式\nF12打开开发者工具，选中 Performance 面板：\n![image.png](https://upload-images.jianshu.io/upload_images/8878545-f9c996290c521a50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/720)\n*选中实心圆按钮，Performance 会开始帮我们记录我们后续的交互操作；\n选中刷新箭头按钮，Performance 会将页面重新加载，计算加载过程中的性能表现。*\n\n![无痕模式](https://upload-images.jianshu.io/upload_images/8878545-e33b750c66028f83.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/720)\n\n*为了避免其它 Chrome 插件对页面的性能影响，建议最好在无痕模式下打开页面*\n\n###### 功能介绍及分析\n以下是好伙伴页面加载过程中的表现，红框部分依次为概述面板、详情面板及绿框的FPS、CPU和NET\n![好伙伴performance](https://upload-images.jianshu.io/upload_images/8878545-3c6a984e7cffd6cb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080)\n\n**概述面板：**页面性能的汇总\n\n**FPS：** 和动画性能密切相关的指标，表示每一秒的帧数。绿色柱状越高表示帧率越高，体验就越流畅。若出现红色块，则代表长时间帧，很可能会出现卡顿。（图中以绿色为主，说明动画性能并不糟糕。）\n\n**CPU：** 表示CPU的忙闲情况。（一般结合Summary 饼图一起看）\n\n**NET：** 展示各请求的耗时与前后顺序。\n\n**详情面板-Main：** 又称火焰图。在图中我们可以看到3条垂直的线，蓝线代表 DOMContentLoaded 时间， 绿线代表首次绘制（及白屏）的时间，红线代表 load 时间。\n**详情面板-Summary：** 结合CPU可得出，scripting过程最耗时（即脚本执行）\n\n### 可视化工具2——LightHouse\nLighthouse 是一个开源的自动化工具，和Performance不同的是，它可以直接生成一个报告，报告中会对各项指标和优化建议做一个具体的呈现。\n\n**具体操作：**\n方式1：在 Chrome 应用商店下载一个 LightHouse插件，打开要测试的那个页面，点击icon和“Generate report”按钮，即可生成性能报告了。\n方式2：chrome开发者工具下的audits面板可直接run audits （需要浏览器的版本大于60）\n下图是生成的报告，同样以好伙伴首页为例\n![LightHouse](https://upload-images.jianshu.io/upload_images/8878545-94c0585f7002b614.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n*上图从上到下依次为：*\n1.当前访问地址、访问时间、模拟设备、网络情况\n2.页面性能、PWA（渐进式 Web 应用）、可访问性、最佳实践、SEO 五项指标的评分情况\n3.每一项指标的细化评估\n4.改进建议以及预计的节省时间（**此项可作为重点依据进行优化** ）\n\n### 推荐阅读\n[使用 Lighthouse 审查网络应用](https://developers.google.com/web/tools/lighthouse/?hl=zh-cn)\n[Performance工具](https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference)\n[Performance API](https://developer.mozilla.org/en-US/docs/Web/API/Window/performance)\n\n\n\n\n","slug":"fe-performance","published":1,"updated":"2019-06-28T09:17:45.568Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2mo4mx00000dt47cd1hqdcx","content":"<p>性能监测是前端页面性能的重要一环，通过监测可以确定页面性能瓶颈，从而有针对性的展开具体的优化工作。<br>在近期调研好伙伴性能优化的过程中，调研了下业界较推崇的两种方式，<strong>可编程方案、可视化方案</strong>。其中可视化方案又有两款比较好用的工具Performance和LightHouse，一起看看如何使用吧。</p>\n<h3 id=\"可编程方案-W3C-性能-API\"><a href=\"#可编程方案-W3C-性能-API\" class=\"headerlink\" title=\"可编程方案-W3C 性能 API\"></a>可编程方案-W3C 性能 API</h3><p>window.Performance是W3C性能小组引入的API，通过相关属性我们可以获取到用户访问页面的每个阶段的精确时间，从而对性能进行分析。<br><em>目前好伙伴项目所接入的听云browser版，本质上也是基于这些api，将各项数据采集上报到听云服务器，并转化成可视化的页面展示方式用于分析页面各项指标</em></p>\n<p>以下是performance对象的完整结构<br><img src=\"https://upload-images.jianshu.io/upload_images/8878545-e57eba8a5567836c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"performance\"></p>\n<p>其中timing下的时间戳和页面加载时间有一个对应关系，如下图所示<br><img src=\"https://upload-images.jianshu.io/upload_images/8878545-c1395036da4fbc0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"timing\"><br>通过求两个时间点之间的差值，可以得出页面各个过程所花费的时间<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> timing = <span class=\"built_in\">window</span>.performance.timing</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//DNS查询耗时</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> domainTime = timing.domainLookupEnd - timing.domainLookupStart</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//TCP连接耗时</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> tcpTime = timing.connectEnd - timing.connectStart</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//内容加载耗时(注意是否存在cache)</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> loadTime = timing.responseEnd - timing.responseStart</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//白屏时间</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> firstPaintTime = timing.domLoading - timing.fetchStart</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//可交互时间</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> ttiTime = timing.domInteractive - timing.fetchStart</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// html加载完成时间;此时可以操作dom</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> domReadyTime = timing.domContentLoadedEventEnd - timing.fetchStart</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 页面完全加载完成时间</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> loadCompleteTime = timing.loadEventStart - timing.fetchStart</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"可视化工具1——Performance\"><a href=\"#可视化工具1——Performance\" class=\"headerlink\" title=\"可视化工具1——Performance\"></a>可视化工具1——Performance</h3><p>Performance是chrome浏览器开发者工具的一个面板，用于实时的记录和分析页面在运行时的各项指标。</p>\n<h6 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h6><p>F12打开开发者工具，选中 Performance 面板：<br><img src=\"https://upload-images.jianshu.io/upload_images/8878545-f9c996290c521a50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/720\" alt=\"image.png\"><br><em>选中实心圆按钮，Performance 会开始帮我们记录我们后续的交互操作；<br>选中刷新箭头按钮，Performance 会将页面重新加载，计算加载过程中的性能表现。</em></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8878545-e33b750c66028f83.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/720\" alt=\"无痕模式\"></p>\n<p><em>为了避免其它 Chrome 插件对页面的性能影响，建议最好在无痕模式下打开页面</em></p>\n<h6 id=\"功能介绍及分析\"><a href=\"#功能介绍及分析\" class=\"headerlink\" title=\"功能介绍及分析\"></a>功能介绍及分析</h6><p>以下是好伙伴页面加载过程中的表现，红框部分依次为概述面板、详情面板及绿框的FPS、CPU和NET<br><img src=\"https://upload-images.jianshu.io/upload_images/8878545-3c6a984e7cffd6cb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080\" alt=\"好伙伴performance\"></p>\n<p><strong>概述面板：</strong>页面性能的汇总</p>\n<p><strong>FPS：</strong> 和动画性能密切相关的指标，表示每一秒的帧数。绿色柱状越高表示帧率越高，体验就越流畅。若出现红色块，则代表长时间帧，很可能会出现卡顿。（图中以绿色为主，说明动画性能并不糟糕。）</p>\n<p><strong>CPU：</strong> 表示CPU的忙闲情况。（一般结合Summary 饼图一起看）</p>\n<p><strong>NET：</strong> 展示各请求的耗时与前后顺序。</p>\n<p><strong>详情面板-Main：</strong> 又称火焰图。在图中我们可以看到3条垂直的线，蓝线代表 DOMContentLoaded 时间， 绿线代表首次绘制（及白屏）的时间，红线代表 load 时间。<br><strong>详情面板-Summary：</strong> 结合CPU可得出，scripting过程最耗时（即脚本执行）</p>\n<h3 id=\"可视化工具2——LightHouse\"><a href=\"#可视化工具2——LightHouse\" class=\"headerlink\" title=\"可视化工具2——LightHouse\"></a>可视化工具2——LightHouse</h3><p>Lighthouse 是一个开源的自动化工具，和Performance不同的是，它可以直接生成一个报告，报告中会对各项指标和优化建议做一个具体的呈现。</p>\n<p><strong>具体操作：</strong><br>方式1：在 Chrome 应用商店下载一个 LightHouse插件，打开要测试的那个页面，点击icon和“Generate report”按钮，即可生成性能报告了。<br>方式2：chrome开发者工具下的audits面板可直接run audits （需要浏览器的版本大于60）<br>下图是生成的报告，同样以好伙伴首页为例<br><img src=\"https://upload-images.jianshu.io/upload_images/8878545-94c0585f7002b614.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"LightHouse\"><br><em>上图从上到下依次为：</em><br>1.当前访问地址、访问时间、模拟设备、网络情况<br>2.页面性能、PWA（渐进式 Web 应用）、可访问性、最佳实践、SEO 五项指标的评分情况<br>3.每一项指标的细化评估<br>4.改进建议以及预计的节省时间（<strong>此项可作为重点依据进行优化</strong> ）</p>\n<h3 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h3><p><a href=\"https://developers.google.com/web/tools/lighthouse/?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">使用 Lighthouse 审查网络应用</a><br><a href=\"https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference\" target=\"_blank\" rel=\"noopener\">Performance工具</a><br><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/performance\" target=\"_blank\" rel=\"noopener\">Performance API</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>性能监测是前端页面性能的重要一环，通过监测可以确定页面性能瓶颈，从而有针对性的展开具体的优化工作。<br>在近期调研好伙伴性能优化的过程中，调研了下业界较推崇的两种方式，<strong>可编程方案、可视化方案</strong>。其中可视化方案又有两款比较好用的工具Performance和LightHouse，一起看看如何使用吧。</p>\n<h3 id=\"可编程方案-W3C-性能-API\"><a href=\"#可编程方案-W3C-性能-API\" class=\"headerlink\" title=\"可编程方案-W3C 性能 API\"></a>可编程方案-W3C 性能 API</h3><p>window.Performance是W3C性能小组引入的API，通过相关属性我们可以获取到用户访问页面的每个阶段的精确时间，从而对性能进行分析。<br><em>目前好伙伴项目所接入的听云browser版，本质上也是基于这些api，将各项数据采集上报到听云服务器，并转化成可视化的页面展示方式用于分析页面各项指标</em></p>\n<p>以下是performance对象的完整结构<br><img src=\"https://upload-images.jianshu.io/upload_images/8878545-e57eba8a5567836c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"performance\"></p>\n<p>其中timing下的时间戳和页面加载时间有一个对应关系，如下图所示<br><img src=\"https://upload-images.jianshu.io/upload_images/8878545-c1395036da4fbc0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"timing\"><br>通过求两个时间点之间的差值，可以得出页面各个过程所花费的时间<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> timing = <span class=\"built_in\">window</span>.performance.timing</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//DNS查询耗时</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> domainTime = timing.domainLookupEnd - timing.domainLookupStart</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//TCP连接耗时</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> tcpTime = timing.connectEnd - timing.connectStart</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//内容加载耗时(注意是否存在cache)</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> loadTime = timing.responseEnd - timing.responseStart</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//白屏时间</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> firstPaintTime = timing.domLoading - timing.fetchStart</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//可交互时间</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> ttiTime = timing.domInteractive - timing.fetchStart</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// html加载完成时间;此时可以操作dom</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> domReadyTime = timing.domContentLoadedEventEnd - timing.fetchStart</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 页面完全加载完成时间</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> loadCompleteTime = timing.loadEventStart - timing.fetchStart</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"可视化工具1——Performance\"><a href=\"#可视化工具1——Performance\" class=\"headerlink\" title=\"可视化工具1——Performance\"></a>可视化工具1——Performance</h3><p>Performance是chrome浏览器开发者工具的一个面板，用于实时的记录和分析页面在运行时的各项指标。</p>\n<h6 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h6><p>F12打开开发者工具，选中 Performance 面板：<br><img src=\"https://upload-images.jianshu.io/upload_images/8878545-f9c996290c521a50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/720\" alt=\"image.png\"><br><em>选中实心圆按钮，Performance 会开始帮我们记录我们后续的交互操作；<br>选中刷新箭头按钮，Performance 会将页面重新加载，计算加载过程中的性能表现。</em></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8878545-e33b750c66028f83.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/720\" alt=\"无痕模式\"></p>\n<p><em>为了避免其它 Chrome 插件对页面的性能影响，建议最好在无痕模式下打开页面</em></p>\n<h6 id=\"功能介绍及分析\"><a href=\"#功能介绍及分析\" class=\"headerlink\" title=\"功能介绍及分析\"></a>功能介绍及分析</h6><p>以下是好伙伴页面加载过程中的表现，红框部分依次为概述面板、详情面板及绿框的FPS、CPU和NET<br><img src=\"https://upload-images.jianshu.io/upload_images/8878545-3c6a984e7cffd6cb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080\" alt=\"好伙伴performance\"></p>\n<p><strong>概述面板：</strong>页面性能的汇总</p>\n<p><strong>FPS：</strong> 和动画性能密切相关的指标，表示每一秒的帧数。绿色柱状越高表示帧率越高，体验就越流畅。若出现红色块，则代表长时间帧，很可能会出现卡顿。（图中以绿色为主，说明动画性能并不糟糕。）</p>\n<p><strong>CPU：</strong> 表示CPU的忙闲情况。（一般结合Summary 饼图一起看）</p>\n<p><strong>NET：</strong> 展示各请求的耗时与前后顺序。</p>\n<p><strong>详情面板-Main：</strong> 又称火焰图。在图中我们可以看到3条垂直的线，蓝线代表 DOMContentLoaded 时间， 绿线代表首次绘制（及白屏）的时间，红线代表 load 时间。<br><strong>详情面板-Summary：</strong> 结合CPU可得出，scripting过程最耗时（即脚本执行）</p>\n<h3 id=\"可视化工具2——LightHouse\"><a href=\"#可视化工具2——LightHouse\" class=\"headerlink\" title=\"可视化工具2——LightHouse\"></a>可视化工具2——LightHouse</h3><p>Lighthouse 是一个开源的自动化工具，和Performance不同的是，它可以直接生成一个报告，报告中会对各项指标和优化建议做一个具体的呈现。</p>\n<p><strong>具体操作：</strong><br>方式1：在 Chrome 应用商店下载一个 LightHouse插件，打开要测试的那个页面，点击icon和“Generate report”按钮，即可生成性能报告了。<br>方式2：chrome开发者工具下的audits面板可直接run audits （需要浏览器的版本大于60）<br>下图是生成的报告，同样以好伙伴首页为例<br><img src=\"https://upload-images.jianshu.io/upload_images/8878545-94c0585f7002b614.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"LightHouse\"><br><em>上图从上到下依次为：</em><br>1.当前访问地址、访问时间、模拟设备、网络情况<br>2.页面性能、PWA（渐进式 Web 应用）、可访问性、最佳实践、SEO 五项指标的评分情况<br>3.每一项指标的细化评估<br>4.改进建议以及预计的节省时间（<strong>此项可作为重点依据进行优化</strong> ）</p>\n<h3 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h3><p><a href=\"https://developers.google.com/web/tools/lighthouse/?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">使用 Lighthouse 审查网络应用</a><br><a href=\"https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference\" target=\"_blank\" rel=\"noopener\">Performance工具</a><br><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/performance\" target=\"_blank\" rel=\"noopener\">Performance API</a></p>\n"},{"title":"小巧却实用的 javascript 方法","date":"2018-02-08T06:59:36.000Z","summary":"在开发中会遇到一些简单实用的方法，比如移动端设备判断，获取url参数或者去掉字符串中的空格等等，这篇博客目的就在于记录下这些方法，持续更新。","_content":"在开发中会遇到一些简单实用的方法，比如移动端设备判断，获取url参数或者去掉字符串中的空格等等，这篇博客目的就在于记录下这些方法，持续更新。\n## 去掉字符串中的空格\n``` javascript\n/**\n *去掉所有空格\n * @param {any} str\n * @param {any} isGlobal\n * @returns\n*/\nlet _trim = (str, isGlobal) => {\n    let result;\n    result = str.replace(/(^\\s+)|(\\s+$)/g, '');\n    if (isGlobal.toLowerCase() === 'g') {\n\tresult = result.replace(/\\s/g, '');\n    }\n    return result;\n};\n```\n<p class='tip'>默认替换字符串首位空格，如果第二个参数为`g`，则替换字符串中所有的空格。</p>\n\n## 获取 url 中参数\n``` javascript\n/**\n * 获取 url 中的参数\n * @param {any} name\n * @returns\n */\nlet _getQueryString = (name) => {\n    let reg = new RegExp('(^|&?)' + name + '=([^&]*)(&|$)', 'i');\n    let r = window.location.search.substr(1).match(reg) || window.location.hash.substr(1).match(reg);\n    if (r != null) {\n        return decodeURIComponent(r[2]);\n    }\n    return null;\n};\n```\n\n## 判断设备\n``` javascript\nlet ua = window.navigator.userAgent;\nlet browser = {\n    isAndroid: () => {\n\treturn ua.match(/Android/i) ? true : false;\n    },\n    isIOS: () => {\n\treturn ua.match(/iPhone|iPad|iPod/i) ? true : false;\n    },\n    isWx: () => {\n\treturn ua.match(/micromessenger/i) ? true : false;\n    },\n    isWp: () => {\n\treturn ua.toLowerCase().indexOf('windows phone') > -1;\n    },\n    isMobile: () => {\n\treturn ua.match(/(iPhone|iPod|Android|ios)/i) ? true : false;\n    },\n    isPC: () => {\n\treturn ua.match(/(iPhone|iPod|Android|ios)/i) ? false : true;\n    }\n};\n\n/* android */\nif (browser.isAndroid()) {\n  console.log('android');\n}\n/* ios */\nif (browser.isIOS()) {\n  console.log('ios');\n}\n/* windows phone */\nif (browser.isWp()) {\n  console.log('windows phone');\n}\n/* weixin */\nif (browser.isWx()) {\n  console.log('weixin');\n}\n/* mobile */\nif (browser.isMobile()) {\n  console.log('Mobile');\n}\n/* pc */\nif (browser.isPC()) {\n  console.log('PC')\n}\n```\n\n## type类型判断\n``` javascript\nisString (o) { //是否字符串\n    return Object.prototype.toString.call(o).slice(8, -1) === 'String'\n}\n\nisNumber (o) { //是否数字\n    return Object.prototype.toString.call(o).slice(8, -1) === 'Number'\n}\n\nisBoolean (o) { //是否boolean\n    return Object.prototype.toString.call(o).slice(8, -1) === 'Boolean'\n}\n\nisFunction (o) { //是否函数\n    return Object.prototype.toString.call(o).slice(8, -1) === 'Function'\n}\n\nisNull (o) { //是否为null\n    return Object.prototype.toString.call(o).slice(8, -1) === 'Null'\n}\n\nisUndefined (o) { //是否undefined\n    return Object.prototype.toString.call(o).slice(8, -1) === 'Undefined'\n}\n\nisObj (o) { //是否对象\n    return Object.prototype.toString.call(o).slice(8, -1) === 'Object'\n}\n\nisArray (o) { //是否数组\n    return Object.prototype.toString.call(o).slice(8, -1) === 'Array'\n}\n\nisDate (o) { //是否时间\n    return Object.prototype.toString.call(o).slice(8, -1) === 'Date'\n}\n\nisRegExp (o) { //是否正则\n    return Object.prototype.toString.call(o).slice(8, -1) === 'RegExp'\n}\n\nisError (o) { //是否错误对象\n    return Object.prototype.toString.call(o).slice(8, -1) === 'Error'\n}\n\nisSymbol (o) { //是否Symbol函数\n    return Object.prototype.toString.call(o).slice(8, -1) === 'Symbol'\n}\n\nisPromise (o) { //是否Promise对象\n    return Object.prototype.toString.call(o).slice(8, -1) === 'Promise'\n}\n\nisSet (o) { //是否Set对象\n    return Object.prototype.toString.call(o).slice(8, -1) === 'Set'\n}\n\n```\n\n## 交换两个变量的值\n利用 ES6 的解构实现，写法简单，语义非常清晰。\n``` javascript\nlet x = 1;\nlet y = 2;\n[x, y] = [y, x];\nconsole.log(x,y); // 2 1\n```\n\n## 数组去重\n利用ES6 的 Set 数据解构实现\n``` javascript\nfunction dedupe(array) {\n  return Array.from(new Set(array));\n}\n\ndedupe([1, 1, 2, 3]) // [1, 2, 3]","source":"_posts/javascript-function.md","raw":"---\ntitle: 小巧却实用的 javascript 方法\ndate: 2018-02-08 14:59:36\ntags: javascript\nsummary: 在开发中会遇到一些简单实用的方法，比如移动端设备判断，获取url参数或者去掉字符串中的空格等等，这篇博客目的就在于记录下这些方法，持续更新。\n\n---\n在开发中会遇到一些简单实用的方法，比如移动端设备判断，获取url参数或者去掉字符串中的空格等等，这篇博客目的就在于记录下这些方法，持续更新。\n## 去掉字符串中的空格\n``` javascript\n/**\n *去掉所有空格\n * @param {any} str\n * @param {any} isGlobal\n * @returns\n*/\nlet _trim = (str, isGlobal) => {\n    let result;\n    result = str.replace(/(^\\s+)|(\\s+$)/g, '');\n    if (isGlobal.toLowerCase() === 'g') {\n\tresult = result.replace(/\\s/g, '');\n    }\n    return result;\n};\n```\n<p class='tip'>默认替换字符串首位空格，如果第二个参数为`g`，则替换字符串中所有的空格。</p>\n\n## 获取 url 中参数\n``` javascript\n/**\n * 获取 url 中的参数\n * @param {any} name\n * @returns\n */\nlet _getQueryString = (name) => {\n    let reg = new RegExp('(^|&?)' + name + '=([^&]*)(&|$)', 'i');\n    let r = window.location.search.substr(1).match(reg) || window.location.hash.substr(1).match(reg);\n    if (r != null) {\n        return decodeURIComponent(r[2]);\n    }\n    return null;\n};\n```\n\n## 判断设备\n``` javascript\nlet ua = window.navigator.userAgent;\nlet browser = {\n    isAndroid: () => {\n\treturn ua.match(/Android/i) ? true : false;\n    },\n    isIOS: () => {\n\treturn ua.match(/iPhone|iPad|iPod/i) ? true : false;\n    },\n    isWx: () => {\n\treturn ua.match(/micromessenger/i) ? true : false;\n    },\n    isWp: () => {\n\treturn ua.toLowerCase().indexOf('windows phone') > -1;\n    },\n    isMobile: () => {\n\treturn ua.match(/(iPhone|iPod|Android|ios)/i) ? true : false;\n    },\n    isPC: () => {\n\treturn ua.match(/(iPhone|iPod|Android|ios)/i) ? false : true;\n    }\n};\n\n/* android */\nif (browser.isAndroid()) {\n  console.log('android');\n}\n/* ios */\nif (browser.isIOS()) {\n  console.log('ios');\n}\n/* windows phone */\nif (browser.isWp()) {\n  console.log('windows phone');\n}\n/* weixin */\nif (browser.isWx()) {\n  console.log('weixin');\n}\n/* mobile */\nif (browser.isMobile()) {\n  console.log('Mobile');\n}\n/* pc */\nif (browser.isPC()) {\n  console.log('PC')\n}\n```\n\n## type类型判断\n``` javascript\nisString (o) { //是否字符串\n    return Object.prototype.toString.call(o).slice(8, -1) === 'String'\n}\n\nisNumber (o) { //是否数字\n    return Object.prototype.toString.call(o).slice(8, -1) === 'Number'\n}\n\nisBoolean (o) { //是否boolean\n    return Object.prototype.toString.call(o).slice(8, -1) === 'Boolean'\n}\n\nisFunction (o) { //是否函数\n    return Object.prototype.toString.call(o).slice(8, -1) === 'Function'\n}\n\nisNull (o) { //是否为null\n    return Object.prototype.toString.call(o).slice(8, -1) === 'Null'\n}\n\nisUndefined (o) { //是否undefined\n    return Object.prototype.toString.call(o).slice(8, -1) === 'Undefined'\n}\n\nisObj (o) { //是否对象\n    return Object.prototype.toString.call(o).slice(8, -1) === 'Object'\n}\n\nisArray (o) { //是否数组\n    return Object.prototype.toString.call(o).slice(8, -1) === 'Array'\n}\n\nisDate (o) { //是否时间\n    return Object.prototype.toString.call(o).slice(8, -1) === 'Date'\n}\n\nisRegExp (o) { //是否正则\n    return Object.prototype.toString.call(o).slice(8, -1) === 'RegExp'\n}\n\nisError (o) { //是否错误对象\n    return Object.prototype.toString.call(o).slice(8, -1) === 'Error'\n}\n\nisSymbol (o) { //是否Symbol函数\n    return Object.prototype.toString.call(o).slice(8, -1) === 'Symbol'\n}\n\nisPromise (o) { //是否Promise对象\n    return Object.prototype.toString.call(o).slice(8, -1) === 'Promise'\n}\n\nisSet (o) { //是否Set对象\n    return Object.prototype.toString.call(o).slice(8, -1) === 'Set'\n}\n\n```\n\n## 交换两个变量的值\n利用 ES6 的解构实现，写法简单，语义非常清晰。\n``` javascript\nlet x = 1;\nlet y = 2;\n[x, y] = [y, x];\nconsole.log(x,y); // 2 1\n```\n\n## 数组去重\n利用ES6 的 Set 数据解构实现\n``` javascript\nfunction dedupe(array) {\n  return Array.from(new Set(array));\n}\n\ndedupe([1, 1, 2, 3]) // [1, 2, 3]","slug":"javascript-function","published":1,"updated":"2019-04-10T08:15:01.345Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2mo4mx90002dt47zf6mduef","content":"<p>在开发中会遇到一些简单实用的方法，比如移动端设备判断，获取url参数或者去掉字符串中的空格等等，这篇博客目的就在于记录下这些方法，持续更新。</p>\n<h2 id=\"去掉字符串中的空格\"><a href=\"#去掉字符串中的空格\" class=\"headerlink\" title=\"去掉字符串中的空格\"></a>去掉字符串中的空格</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *去掉所有空格</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;any&#125; str</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;any&#125; isGlobal</span></span><br><span class=\"line\"><span class=\"comment\"> * @returns</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> _trim = <span class=\"function\">(<span class=\"params\">str, isGlobal</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> result;</span><br><span class=\"line\">    result = str.replace(<span class=\"regexp\">/(^\\s+)|(\\s+$)/g</span>, <span class=\"string\">''</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isGlobal.toLowerCase() === <span class=\"string\">'g'</span>) &#123;</span><br><span class=\"line\">\tresult = result.replace(<span class=\"regexp\">/\\s/g</span>, <span class=\"string\">''</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p class=\"tip\">默认替换字符串首位空格，如果第二个参数为<code>g</code>，则替换字符串中所有的空格。</p>\n\n<h2 id=\"获取-url-中参数\"><a href=\"#获取-url-中参数\" class=\"headerlink\" title=\"获取 url 中参数\"></a>获取 url 中参数</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 获取 url 中的参数</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;any&#125; name</span></span><br><span class=\"line\"><span class=\"comment\"> * @returns</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> _getQueryString = <span class=\"function\">(<span class=\"params\">name</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> reg = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">'(^|&amp;?)'</span> + name + <span class=\"string\">'=([^&amp;]*)(&amp;|$)'</span>, <span class=\"string\">'i'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> r = <span class=\"built_in\">window</span>.location.search.substr(<span class=\"number\">1</span>).match(reg) || <span class=\"built_in\">window</span>.location.hash.substr(<span class=\"number\">1</span>).match(reg);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">decodeURIComponent</span>(r[<span class=\"number\">2</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"判断设备\"><a href=\"#判断设备\" class=\"headerlink\" title=\"判断设备\"></a>判断设备</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> ua = <span class=\"built_in\">window</span>.navigator.userAgent;</span><br><span class=\"line\"><span class=\"keyword\">let</span> browser = &#123;</span><br><span class=\"line\">    isAndroid: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ua.match(<span class=\"regexp\">/Android/i</span>) ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    isIOS: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ua.match(<span class=\"regexp\">/iPhone|iPad|iPod/i</span>) ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    isWx: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ua.match(<span class=\"regexp\">/micromessenger/i</span>) ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    isWp: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ua.toLowerCase().indexOf(<span class=\"string\">'windows phone'</span>) &gt; <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    isMobile: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ua.match(<span class=\"regexp\">/(iPhone|iPod|Android|ios)/i</span>) ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    isPC: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ua.match(<span class=\"regexp\">/(iPhone|iPod|Android|ios)/i</span>) ? <span class=\"literal\">false</span> : <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* android */</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (browser.isAndroid()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'android'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* ios */</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (browser.isIOS()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'ios'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* windows phone */</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (browser.isWp()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'windows phone'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* weixin */</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (browser.isWx()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'weixin'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* mobile */</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (browser.isMobile()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Mobile'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* pc */</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (browser.isPC()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'PC'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"type类型判断\"><a href=\"#type类型判断\" class=\"headerlink\" title=\"type类型判断\"></a>type类型判断</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">isString (o) &#123; <span class=\"comment\">//是否字符串</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(o).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'String'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">isNumber (o) &#123; <span class=\"comment\">//是否数字</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(o).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Number'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">isBoolean (o) &#123; <span class=\"comment\">//是否boolean</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(o).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Boolean'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">isFunction (o) &#123; <span class=\"comment\">//是否函数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(o).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Function'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">isNull (o) &#123; <span class=\"comment\">//是否为null</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(o).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Null'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">isUndefined (o) &#123; <span class=\"comment\">//是否undefined</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(o).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Undefined'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">isObj (o) &#123; <span class=\"comment\">//是否对象</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(o).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Object'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">isArray (o) &#123; <span class=\"comment\">//是否数组</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(o).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Array'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">isDate (o) &#123; <span class=\"comment\">//是否时间</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(o).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Date'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">isRegExp (o) &#123; <span class=\"comment\">//是否正则</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(o).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'RegExp'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">isError (o) &#123; <span class=\"comment\">//是否错误对象</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(o).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Error'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">isSymbol (o) &#123; <span class=\"comment\">//是否Symbol函数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(o).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Symbol'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">isPromise (o) &#123; <span class=\"comment\">//是否Promise对象</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(o).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Promise'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">isSet (o) &#123; <span class=\"comment\">//是否Set对象</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(o).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Set'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"交换两个变量的值\"><a href=\"#交换两个变量的值\" class=\"headerlink\" title=\"交换两个变量的值\"></a>交换两个变量的值</h2><p>利用 ES6 的解构实现，写法简单，语义非常清晰。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> y = <span class=\"number\">2</span>;</span><br><span class=\"line\">[x, y] = [y, x];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x,y); <span class=\"comment\">// 2 1</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"数组去重\"><a href=\"#数组去重\" class=\"headerlink\" title=\"数组去重\"></a>数组去重</h2><p>利用ES6 的 Set 数据解构实现<br>``` javascript<br>function dedupe(array) {<br>  return Array.from(new Set(array));<br>}</p>\n<p>dedupe([1, 1, 2, 3]) // [1, 2, 3]</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在开发中会遇到一些简单实用的方法，比如移动端设备判断，获取url参数或者去掉字符串中的空格等等，这篇博客目的就在于记录下这些方法，持续更新。</p>\n<h2 id=\"去掉字符串中的空格\"><a href=\"#去掉字符串中的空格\" class=\"headerlink\" title=\"去掉字符串中的空格\"></a>去掉字符串中的空格</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *去掉所有空格</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;any&#125; str</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;any&#125; isGlobal</span></span><br><span class=\"line\"><span class=\"comment\"> * @returns</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> _trim = <span class=\"function\">(<span class=\"params\">str, isGlobal</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> result;</span><br><span class=\"line\">    result = str.replace(<span class=\"regexp\">/(^\\s+)|(\\s+$)/g</span>, <span class=\"string\">''</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isGlobal.toLowerCase() === <span class=\"string\">'g'</span>) &#123;</span><br><span class=\"line\">\tresult = result.replace(<span class=\"regexp\">/\\s/g</span>, <span class=\"string\">''</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p class=\"tip\">默认替换字符串首位空格，如果第二个参数为<code>g</code>，则替换字符串中所有的空格。</p>\n\n<h2 id=\"获取-url-中参数\"><a href=\"#获取-url-中参数\" class=\"headerlink\" title=\"获取 url 中参数\"></a>获取 url 中参数</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 获取 url 中的参数</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;any&#125; name</span></span><br><span class=\"line\"><span class=\"comment\"> * @returns</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> _getQueryString = <span class=\"function\">(<span class=\"params\">name</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> reg = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">'(^|&amp;?)'</span> + name + <span class=\"string\">'=([^&amp;]*)(&amp;|$)'</span>, <span class=\"string\">'i'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> r = <span class=\"built_in\">window</span>.location.search.substr(<span class=\"number\">1</span>).match(reg) || <span class=\"built_in\">window</span>.location.hash.substr(<span class=\"number\">1</span>).match(reg);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">decodeURIComponent</span>(r[<span class=\"number\">2</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"判断设备\"><a href=\"#判断设备\" class=\"headerlink\" title=\"判断设备\"></a>判断设备</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> ua = <span class=\"built_in\">window</span>.navigator.userAgent;</span><br><span class=\"line\"><span class=\"keyword\">let</span> browser = &#123;</span><br><span class=\"line\">    isAndroid: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ua.match(<span class=\"regexp\">/Android/i</span>) ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    isIOS: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ua.match(<span class=\"regexp\">/iPhone|iPad|iPod/i</span>) ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    isWx: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ua.match(<span class=\"regexp\">/micromessenger/i</span>) ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    isWp: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ua.toLowerCase().indexOf(<span class=\"string\">'windows phone'</span>) &gt; <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    isMobile: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ua.match(<span class=\"regexp\">/(iPhone|iPod|Android|ios)/i</span>) ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    isPC: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ua.match(<span class=\"regexp\">/(iPhone|iPod|Android|ios)/i</span>) ? <span class=\"literal\">false</span> : <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* android */</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (browser.isAndroid()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'android'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* ios */</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (browser.isIOS()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'ios'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* windows phone */</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (browser.isWp()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'windows phone'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* weixin */</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (browser.isWx()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'weixin'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* mobile */</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (browser.isMobile()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Mobile'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* pc */</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (browser.isPC()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'PC'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"type类型判断\"><a href=\"#type类型判断\" class=\"headerlink\" title=\"type类型判断\"></a>type类型判断</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">isString (o) &#123; <span class=\"comment\">//是否字符串</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(o).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'String'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">isNumber (o) &#123; <span class=\"comment\">//是否数字</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(o).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Number'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">isBoolean (o) &#123; <span class=\"comment\">//是否boolean</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(o).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Boolean'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">isFunction (o) &#123; <span class=\"comment\">//是否函数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(o).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Function'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">isNull (o) &#123; <span class=\"comment\">//是否为null</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(o).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Null'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">isUndefined (o) &#123; <span class=\"comment\">//是否undefined</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(o).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Undefined'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">isObj (o) &#123; <span class=\"comment\">//是否对象</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(o).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Object'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">isArray (o) &#123; <span class=\"comment\">//是否数组</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(o).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Array'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">isDate (o) &#123; <span class=\"comment\">//是否时间</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(o).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Date'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">isRegExp (o) &#123; <span class=\"comment\">//是否正则</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(o).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'RegExp'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">isError (o) &#123; <span class=\"comment\">//是否错误对象</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(o).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Error'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">isSymbol (o) &#123; <span class=\"comment\">//是否Symbol函数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(o).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Symbol'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">isPromise (o) &#123; <span class=\"comment\">//是否Promise对象</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(o).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Promise'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">isSet (o) &#123; <span class=\"comment\">//是否Set对象</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(o).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">'Set'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"交换两个变量的值\"><a href=\"#交换两个变量的值\" class=\"headerlink\" title=\"交换两个变量的值\"></a>交换两个变量的值</h2><p>利用 ES6 的解构实现，写法简单，语义非常清晰。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> y = <span class=\"number\">2</span>;</span><br><span class=\"line\">[x, y] = [y, x];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x,y); <span class=\"comment\">// 2 1</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"数组去重\"><a href=\"#数组去重\" class=\"headerlink\" title=\"数组去重\"></a>数组去重</h2><p>利用ES6 的 Set 数据解构实现<br>``` javascript<br>function dedupe(array) {<br>  return Array.from(new Set(array));<br>}</p>\n<p>dedupe([1, 1, 2, 3]) // [1, 2, 3]</p>\n"},{"title":"总会收集一些有用的 CSS","date":"2018-02-24T01:50:03.000Z","summary":"不知道写什么概括语，就这样写吧：目前收集了盒子模型、box-sizing 属性、CSS 选择器、CSS 继承属性、CSS3新特性等等。","_content":"\n#### 1. CSS 盒子模型\n在一个文档中，每个**元素**都被表示为一个**矩形**的盒子。确定这些盒子的尺寸, 属性 --- 像它的颜色，背景，边框方面 --- 和位置是渲染引擎的标。\n在 CSS 中使用标准的**盒模型**来描述这些矩形盒子中的每一个，这个模型描述了元素所占空间的内容。每个盒子有四个边：**外边距边**, **边框边**, **内填充边** 与 **内容边**。分别对应CSS中的 **margin** **border** **padding** **content**。\n<img src=\"/blog/img/css-interview/boxmodel.png\">\n或者可以这样描述: 宽度(width)=内容的宽度(content) + padding + border + margin\n<p class=\"tip\">上面描述的是标准的盒子模型，当然还有低版本IE盒子模型，它可以进行这样描述:宽度(width)=内容的宽度(content+ padding + border) + margin，两者的区别可以很明显的看出。</p>\n\n#### 2. box-sizing 属性\n**box-sizing**在开发中很常见，它是盒子模型的解析模式,她有两个值：content-box和border-box,默认为content-box\n* **content-box**: 标准的W3C盒子模型，设置元素的height/width属性指的是conent部分的height/width\n* **border-box**: IE传统盒子模型，设置元素的height/width属性指的是border+padding+content部分的height/width\n\n> 这个属性很实用，比如你想将一个div的宽度设置为100%，然后又想加一个padding，如果不将box-sizing设置为border-box，那么这个div就会溢出，反之就是你想要的效果。\n\n#### 3. CSS 选择器\n在 CSS 中，选择器是一种模式，用于选择需要添加样式的元素。\n\n|选择器|例子|例子描述|CSS\n|---|---\n|.class|.info|选择 class=\"info\" 的所有元素。|1\n|#id|#idName|选择 id=\"idName\" 的所有元素。|1\n|*|*|选择所有元素。|2\n|element|\tp|选择 所有`<p>`元素。|1\n|element,element|div,p|选择所有`<div>`元素和所有 `<p>` 元素。|1\n|element element|div p|选择 `<div>` 元素内部的所有 `<p>` 元素。|1\n|element>element|\tdiv>p|选择所有父元素为`div`的`p`元素|2\n|element+element|div+p|选择紧接着`div`元素之后的所有`p`元素|2\n|[attribute]|[target]|选择带有 target 属性所有元素。|\t2\n|[attribute=value]|[target=_blank]|选择 target=\"_blank\" 的所有元素。|2\n|:link|a:link|选择所有未被访问的链接。|1\n|:first-letter|p:first-letter|选择每个 `<p>` 元素的首字母。。|1\n|:before|\tp:before|在每个 `<p>` 元素的内容之前插入内容。|2\n|:first-of-type|\tp:first-of-type|选择属于其父元素的首个 `<p>` 元素。|3\n|:not(selector)|:not(p)|选择非 `<p>` 元素的每个元素。|3\n\n<p class=\"tip\">上面这些选择器是一些比较常见的选择器，其中也包含了一些CSS3中的新的选择器。[更多选择器](http://www.w3school.com.cn/cssref/css_selectors.ASP)</p>\n\n#### 4. CSS 哪些属性可以继承\nCSS 可继承的属性有: \n``` css\n* font-size \n* font-family \n* color\n```\n\n#### 5. CSS3新增伪类有那些\n* p:first-of-type 选择其父元素的首个`<p>`元素\n* p:first-of-type 选择其父元素的最后一个`<p>`元素\n* p:only-of-type 选择属于其父元素唯一的元素\n* p:only-child 选择属于其父元素的唯一子元素\n* p:nth-child(2) 选择属于其父元素的第二个子元素\n* :enabled :disabled 表单控件的禁用状态。\n* :checked 单选框或复选框被选中。\n\n#### 6. CSS3有哪些新特性？\n* RGBA和透明度\n* background-image background-origin(content-box/padding-box/border-box) background-size background-repeat\n* word-wrap（对长的不可分割单词换行）word-wrap：break-word\n* 文字阴影：text-shadow： 5px 5px 5px #FF0000;（水平阴影，垂直阴影，模糊距离，阴影颜色）\n* font-face属性：定义自己的字体\n* 圆角（边框半径）：border-radius 属性用于创建圆角\n* 边框图片：border-image: url(border.png) 30 30 round\n* 盒阴影：box-shadow: 10px 10px 5px #888888\n* 媒体查询：定义两套css，当浏览器的尺寸变化时会采用不同的属性\n\n#### 7. 用纯CSS创建一个三角形的原理\n首先将其宽度和高度设置为0，然后再设置其边框的样式。\n``` css\nwidth: 0;\nheight: 0;\nborder-top: 50px solid transparent;\nborder-left: 50px solid transparent;\nborder-right: 50px solid transparent;\nborder-bottom: 50px solid #00ff00\n```\n\n#### 8. 清除浮动\n``` css\n.clearfix {\n  zoom:1\n  &::after {\n    content: '';\n    display: block;\n    height: 0;\n    visibility: hidden;\n    clear: both;\n  }\n}\n```\n\n#### 9. 移动端布局的媒体查询\n通过媒体查询可以为不同大小和尺寸的媒体定义不同的css，适应相应的设备的显示。\n* <head></head>里面\n``` html\n<link rel=\"stylesheet\" type=\"text/css\" href=\"xxx.css\" media=\"only screen and (max-device-width:480px)\">\n```\n* CSS\n``` css\n: @media only screen and (max-device-width:480px) {/css样式/}\n```\n\n#### 10.  ::before 和 :after中双冒号和单冒号的区别\n1.单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素\n2.::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。\n:before 和 :after 这两个伪元素，是在CSS2.1里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着Web的进化，在CSS3的规范里，伪元素的语法被修改成使用双冒号，成为::before ::after\n\n#### 11. png、jpg、gif、webp图片格式\n* png是便携式网络图片（Portable Network Graphics）是一种无损数据压缩位图文件格式.优点是：压缩比高，色彩好。 大多数地方都可以用。\n* jpg是一种针对相片使用的一种失真压缩方法，是一种破坏性的压缩，在色调及颜色平滑变化做的不错。在www上，被用来储存和传输照片的格式。\n* gif是一种位图文件格式，以8位色重现真色彩的图像。可以实现动画效果.\n* webp格式是谷歌在2010年推出的图片格式，压缩率只有jpg的2/3，大小比png小了45%。缺点是压缩的时间更久了，兼容性不好，目前谷歌和opera支持。\n\n##### 持续更新中....\n","source":"_posts/css-interview.md","raw":"---\ntitle: 总会收集一些有用的 CSS\ndate: 2018-02-24 09:50:03\ntags: [CSS,面试]\nsummary: 不知道写什么概括语，就这样写吧：目前收集了盒子模型、box-sizing 属性、CSS 选择器、CSS 继承属性、CSS3新特性等等。\n\n---\n\n#### 1. CSS 盒子模型\n在一个文档中，每个**元素**都被表示为一个**矩形**的盒子。确定这些盒子的尺寸, 属性 --- 像它的颜色，背景，边框方面 --- 和位置是渲染引擎的标。\n在 CSS 中使用标准的**盒模型**来描述这些矩形盒子中的每一个，这个模型描述了元素所占空间的内容。每个盒子有四个边：**外边距边**, **边框边**, **内填充边** 与 **内容边**。分别对应CSS中的 **margin** **border** **padding** **content**。\n<img src=\"/blog/img/css-interview/boxmodel.png\">\n或者可以这样描述: 宽度(width)=内容的宽度(content) + padding + border + margin\n<p class=\"tip\">上面描述的是标准的盒子模型，当然还有低版本IE盒子模型，它可以进行这样描述:宽度(width)=内容的宽度(content+ padding + border) + margin，两者的区别可以很明显的看出。</p>\n\n#### 2. box-sizing 属性\n**box-sizing**在开发中很常见，它是盒子模型的解析模式,她有两个值：content-box和border-box,默认为content-box\n* **content-box**: 标准的W3C盒子模型，设置元素的height/width属性指的是conent部分的height/width\n* **border-box**: IE传统盒子模型，设置元素的height/width属性指的是border+padding+content部分的height/width\n\n> 这个属性很实用，比如你想将一个div的宽度设置为100%，然后又想加一个padding，如果不将box-sizing设置为border-box，那么这个div就会溢出，反之就是你想要的效果。\n\n#### 3. CSS 选择器\n在 CSS 中，选择器是一种模式，用于选择需要添加样式的元素。\n\n|选择器|例子|例子描述|CSS\n|---|---\n|.class|.info|选择 class=\"info\" 的所有元素。|1\n|#id|#idName|选择 id=\"idName\" 的所有元素。|1\n|*|*|选择所有元素。|2\n|element|\tp|选择 所有`<p>`元素。|1\n|element,element|div,p|选择所有`<div>`元素和所有 `<p>` 元素。|1\n|element element|div p|选择 `<div>` 元素内部的所有 `<p>` 元素。|1\n|element>element|\tdiv>p|选择所有父元素为`div`的`p`元素|2\n|element+element|div+p|选择紧接着`div`元素之后的所有`p`元素|2\n|[attribute]|[target]|选择带有 target 属性所有元素。|\t2\n|[attribute=value]|[target=_blank]|选择 target=\"_blank\" 的所有元素。|2\n|:link|a:link|选择所有未被访问的链接。|1\n|:first-letter|p:first-letter|选择每个 `<p>` 元素的首字母。。|1\n|:before|\tp:before|在每个 `<p>` 元素的内容之前插入内容。|2\n|:first-of-type|\tp:first-of-type|选择属于其父元素的首个 `<p>` 元素。|3\n|:not(selector)|:not(p)|选择非 `<p>` 元素的每个元素。|3\n\n<p class=\"tip\">上面这些选择器是一些比较常见的选择器，其中也包含了一些CSS3中的新的选择器。[更多选择器](http://www.w3school.com.cn/cssref/css_selectors.ASP)</p>\n\n#### 4. CSS 哪些属性可以继承\nCSS 可继承的属性有: \n``` css\n* font-size \n* font-family \n* color\n```\n\n#### 5. CSS3新增伪类有那些\n* p:first-of-type 选择其父元素的首个`<p>`元素\n* p:first-of-type 选择其父元素的最后一个`<p>`元素\n* p:only-of-type 选择属于其父元素唯一的元素\n* p:only-child 选择属于其父元素的唯一子元素\n* p:nth-child(2) 选择属于其父元素的第二个子元素\n* :enabled :disabled 表单控件的禁用状态。\n* :checked 单选框或复选框被选中。\n\n#### 6. CSS3有哪些新特性？\n* RGBA和透明度\n* background-image background-origin(content-box/padding-box/border-box) background-size background-repeat\n* word-wrap（对长的不可分割单词换行）word-wrap：break-word\n* 文字阴影：text-shadow： 5px 5px 5px #FF0000;（水平阴影，垂直阴影，模糊距离，阴影颜色）\n* font-face属性：定义自己的字体\n* 圆角（边框半径）：border-radius 属性用于创建圆角\n* 边框图片：border-image: url(border.png) 30 30 round\n* 盒阴影：box-shadow: 10px 10px 5px #888888\n* 媒体查询：定义两套css，当浏览器的尺寸变化时会采用不同的属性\n\n#### 7. 用纯CSS创建一个三角形的原理\n首先将其宽度和高度设置为0，然后再设置其边框的样式。\n``` css\nwidth: 0;\nheight: 0;\nborder-top: 50px solid transparent;\nborder-left: 50px solid transparent;\nborder-right: 50px solid transparent;\nborder-bottom: 50px solid #00ff00\n```\n\n#### 8. 清除浮动\n``` css\n.clearfix {\n  zoom:1\n  &::after {\n    content: '';\n    display: block;\n    height: 0;\n    visibility: hidden;\n    clear: both;\n  }\n}\n```\n\n#### 9. 移动端布局的媒体查询\n通过媒体查询可以为不同大小和尺寸的媒体定义不同的css，适应相应的设备的显示。\n* <head></head>里面\n``` html\n<link rel=\"stylesheet\" type=\"text/css\" href=\"xxx.css\" media=\"only screen and (max-device-width:480px)\">\n```\n* CSS\n``` css\n: @media only screen and (max-device-width:480px) {/css样式/}\n```\n\n#### 10.  ::before 和 :after中双冒号和单冒号的区别\n1.单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素\n2.::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。\n:before 和 :after 这两个伪元素，是在CSS2.1里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着Web的进化，在CSS3的规范里，伪元素的语法被修改成使用双冒号，成为::before ::after\n\n#### 11. png、jpg、gif、webp图片格式\n* png是便携式网络图片（Portable Network Graphics）是一种无损数据压缩位图文件格式.优点是：压缩比高，色彩好。 大多数地方都可以用。\n* jpg是一种针对相片使用的一种失真压缩方法，是一种破坏性的压缩，在色调及颜色平滑变化做的不错。在www上，被用来储存和传输照片的格式。\n* gif是一种位图文件格式，以8位色重现真色彩的图像。可以实现动画效果.\n* webp格式是谷歌在2010年推出的图片格式，压缩率只有jpg的2/3，大小比png小了45%。缺点是压缩的时间更久了，兼容性不好，目前谷歌和opera支持。\n\n##### 持续更新中....\n","slug":"css-interview","published":1,"updated":"2019-04-11T01:59:07.157Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2mo4mxd0004dt47g4sjjzn1","content":"<h4 id=\"1-CSS-盒子模型\"><a href=\"#1-CSS-盒子模型\" class=\"headerlink\" title=\"1. CSS 盒子模型\"></a>1. CSS 盒子模型</h4><p>在一个文档中，每个<strong>元素</strong>都被表示为一个<strong>矩形</strong>的盒子。确定这些盒子的尺寸, 属性 — 像它的颜色，背景，边框方面 — 和位置是渲染引擎的标。<br>在 CSS 中使用标准的<strong>盒模型</strong>来描述这些矩形盒子中的每一个，这个模型描述了元素所占空间的内容。每个盒子有四个边：<strong>外边距边</strong>, <strong>边框边</strong>, <strong>内填充边</strong> 与 <strong>内容边</strong>。分别对应CSS中的 <strong>margin</strong> <strong>border</strong> <strong>padding</strong> <strong>content</strong>。<br><img src=\"/blog/img/css-interview/boxmodel.png\"><br>或者可以这样描述: 宽度(width)=内容的宽度(content) + padding + border + margin</p>\n<p class=\"tip\">上面描述的是标准的盒子模型，当然还有低版本IE盒子模型，它可以进行这样描述:宽度(width)=内容的宽度(content+ padding + border) + margin，两者的区别可以很明显的看出。</p>\n\n<h4 id=\"2-box-sizing-属性\"><a href=\"#2-box-sizing-属性\" class=\"headerlink\" title=\"2. box-sizing 属性\"></a>2. box-sizing 属性</h4><p><strong>box-sizing</strong>在开发中很常见，它是盒子模型的解析模式,她有两个值：content-box和border-box,默认为content-box</p>\n<ul>\n<li><strong>content-box</strong>: 标准的W3C盒子模型，设置元素的height/width属性指的是conent部分的height/width</li>\n<li><strong>border-box</strong>: IE传统盒子模型，设置元素的height/width属性指的是border+padding+content部分的height/width</li>\n</ul>\n<blockquote>\n<p>这个属性很实用，比如你想将一个div的宽度设置为100%，然后又想加一个padding，如果不将box-sizing设置为border-box，那么这个div就会溢出，反之就是你想要的效果。</p>\n</blockquote>\n<h4 id=\"3-CSS-选择器\"><a href=\"#3-CSS-选择器\" class=\"headerlink\" title=\"3. CSS 选择器\"></a>3. CSS 选择器</h4><p>在 CSS 中，选择器是一种模式，用于选择需要添加样式的元素。</p>\n<table>\n<thead>\n<tr>\n<th>选择器</th>\n<th>例子</th>\n<th>例子描述</th>\n<th>CSS</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>.class</td>\n<td>.info</td>\n<td>选择 class=”info” 的所有元素。</td>\n<td>1</td>\n</tr>\n<tr>\n<td>#id</td>\n<td>#idName</td>\n<td>选择 id=”idName” 的所有元素。</td>\n<td>1</td>\n</tr>\n<tr>\n<td>*</td>\n<td>*</td>\n<td>选择所有元素。</td>\n<td>2</td>\n</tr>\n<tr>\n<td>element</td>\n<td>p</td>\n<td>选择 所有<code>&lt;p&gt;</code>元素。</td>\n<td>1</td>\n</tr>\n<tr>\n<td>element,element</td>\n<td>div,p</td>\n<td>选择所有<code>&lt;div&gt;</code>元素和所有 <code>&lt;p&gt;</code> 元素。</td>\n<td>1</td>\n</tr>\n<tr>\n<td>element element</td>\n<td>div p</td>\n<td>选择 <code>&lt;div&gt;</code> 元素内部的所有 <code>&lt;p&gt;</code> 元素。</td>\n<td>1</td>\n</tr>\n<tr>\n<td>element&gt;element</td>\n<td>div&gt;p</td>\n<td>选择所有父元素为<code>div</code>的<code>p</code>元素</td>\n<td>2</td>\n</tr>\n<tr>\n<td>element+element</td>\n<td>div+p</td>\n<td>选择紧接着<code>div</code>元素之后的所有<code>p</code>元素</td>\n<td>2</td>\n</tr>\n<tr>\n<td>[attribute]</td>\n<td>[target]</td>\n<td>选择带有 target 属性所有元素。</td>\n<td>2</td>\n</tr>\n<tr>\n<td>[attribute=value]</td>\n<td>[target=_blank]</td>\n<td>选择 target=”_blank” 的所有元素。</td>\n<td>2</td>\n</tr>\n<tr>\n<td>:link</td>\n<td>a:link</td>\n<td>选择所有未被访问的链接。</td>\n<td>1</td>\n</tr>\n<tr>\n<td>:first-letter</td>\n<td>p:first-letter</td>\n<td>选择每个 <code>&lt;p&gt;</code> 元素的首字母。。</td>\n<td>1</td>\n</tr>\n<tr>\n<td>:before</td>\n<td>p:before</td>\n<td>在每个 <code>&lt;p&gt;</code> 元素的内容之前插入内容。</td>\n<td>2</td>\n</tr>\n<tr>\n<td>:first-of-type</td>\n<td>p:first-of-type</td>\n<td>选择属于其父元素的首个 <code>&lt;p&gt;</code> 元素。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>:not(selector)</td>\n<td>:not(p)</td>\n<td>选择非 <code>&lt;p&gt;</code> 元素的每个元素。</td>\n<td>3</td>\n</tr>\n</tbody>\n</table>\n<p class=\"tip\">上面这些选择器是一些比较常见的选择器，其中也包含了一些CSS3中的新的选择器。<a href=\"http://www.w3school.com.cn/cssref/css_selectors.ASP\" target=\"_blank\" rel=\"noopener\">更多选择器</a></p>\n\n<h4 id=\"4-CSS-哪些属性可以继承\"><a href=\"#4-CSS-哪些属性可以继承\" class=\"headerlink\" title=\"4. CSS 哪些属性可以继承\"></a>4. CSS 哪些属性可以继承</h4><p>CSS 可继承的属性有:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* <span class=\"selector-tag\">font-size</span> </span><br><span class=\"line\">* <span class=\"selector-tag\">font-family</span> </span><br><span class=\"line\">* <span class=\"selector-tag\">color</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-CSS3新增伪类有那些\"><a href=\"#5-CSS3新增伪类有那些\" class=\"headerlink\" title=\"5. CSS3新增伪类有那些\"></a>5. CSS3新增伪类有那些</h4><ul>\n<li>p:first-of-type 选择其父元素的首个<code>&lt;p&gt;</code>元素</li>\n<li>p:first-of-type 选择其父元素的最后一个<code>&lt;p&gt;</code>元素</li>\n<li>p:only-of-type 选择属于其父元素唯一的元素</li>\n<li>p:only-child 选择属于其父元素的唯一子元素</li>\n<li>p:nth-child(2) 选择属于其父元素的第二个子元素</li>\n<li>:enabled :disabled 表单控件的禁用状态。</li>\n<li>:checked 单选框或复选框被选中。</li>\n</ul>\n<h4 id=\"6-CSS3有哪些新特性？\"><a href=\"#6-CSS3有哪些新特性？\" class=\"headerlink\" title=\"6. CSS3有哪些新特性？\"></a>6. CSS3有哪些新特性？</h4><ul>\n<li>RGBA和透明度</li>\n<li>background-image background-origin(content-box/padding-box/border-box) background-size background-repeat</li>\n<li>word-wrap（对长的不可分割单词换行）word-wrap：break-word</li>\n<li>文字阴影：text-shadow： 5px 5px 5px #FF0000;（水平阴影，垂直阴影，模糊距离，阴影颜色）</li>\n<li>font-face属性：定义自己的字体</li>\n<li>圆角（边框半径）：border-radius 属性用于创建圆角</li>\n<li>边框图片：border-image: url(border.png) 30 30 round</li>\n<li>盒阴影：box-shadow: 10px 10px 5px #888888</li>\n<li>媒体查询：定义两套css，当浏览器的尺寸变化时会采用不同的属性</li>\n</ul>\n<h4 id=\"7-用纯CSS创建一个三角形的原理\"><a href=\"#7-用纯CSS创建一个三角形的原理\" class=\"headerlink\" title=\"7. 用纯CSS创建一个三角形的原理\"></a>7. 用纯CSS创建一个三角形的原理</h4><p>首先将其宽度和高度设置为0，然后再设置其边框的样式。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">width</span>: 0;</span><br><span class=\"line\"><span class=\"selector-tag\">height</span>: 0;</span><br><span class=\"line\"><span class=\"selector-tag\">border-top</span>: 50<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">solid</span> <span class=\"selector-tag\">transparent</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">border-left</span>: 50<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">solid</span> <span class=\"selector-tag\">transparent</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">border-right</span>: 50<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">solid</span> <span class=\"selector-tag\">transparent</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">border-bottom</span>: 50<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">solid</span> <span class=\"selector-id\">#00ff00</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"8-清除浮动\"><a href=\"#8-清除浮动\" class=\"headerlink\" title=\"8. 清除浮动\"></a>8. 清除浮动</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.clearfix</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">zoom</span>:<span class=\"number\">1</span></span><br><span class=\"line\">  &amp;::after &#123;</span><br><span class=\"line\">    content: <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">visibility</span>: hidden;</span><br><span class=\"line\">    <span class=\"attribute\">clear</span>: both;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"9-移动端布局的媒体查询\"><a href=\"#9-移动端布局的媒体查询\" class=\"headerlink\" title=\"9. 移动端布局的媒体查询\"></a>9. 移动端布局的媒体查询</h4><p>通过媒体查询可以为不同大小和尺寸的媒体定义不同的css，适应相应的设备的显示。</p>\n<ul>\n<li><p><head><meta name=\"generator\" content=\"Hexo 3.8.0\"></head>里面</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"xxx.css\"</span> <span class=\"attr\">media</span>=<span class=\"string\">\"only screen and (max-device-width:480px)\"</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>CSS</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">: @media only screen and (max-device-width:480px) &#123;/css样式/&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"10-before-和-after中双冒号和单冒号的区别\"><a href=\"#10-before-和-after中双冒号和单冒号的区别\" class=\"headerlink\" title=\"10.  ::before 和 :after中双冒号和单冒号的区别\"></a>10.  ::before 和 :after中双冒号和单冒号的区别</h4><p>1.单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素<br>2.::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。<br>:before 和 :after 这两个伪元素，是在CSS2.1里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着Web的进化，在CSS3的规范里，伪元素的语法被修改成使用双冒号，成为::before ::after</p>\n<h4 id=\"11-png、jpg、gif、webp图片格式\"><a href=\"#11-png、jpg、gif、webp图片格式\" class=\"headerlink\" title=\"11. png、jpg、gif、webp图片格式\"></a>11. png、jpg、gif、webp图片格式</h4><ul>\n<li>png是便携式网络图片（Portable Network Graphics）是一种无损数据压缩位图文件格式.优点是：压缩比高，色彩好。 大多数地方都可以用。</li>\n<li>jpg是一种针对相片使用的一种失真压缩方法，是一种破坏性的压缩，在色调及颜色平滑变化做的不错。在www上，被用来储存和传输照片的格式。</li>\n<li>gif是一种位图文件格式，以8位色重现真色彩的图像。可以实现动画效果.</li>\n<li>webp格式是谷歌在2010年推出的图片格式，压缩率只有jpg的2/3，大小比png小了45%。缺点是压缩的时间更久了，兼容性不好，目前谷歌和opera支持。</li>\n</ul>\n<h5 id=\"持续更新中…\"><a href=\"#持续更新中…\" class=\"headerlink\" title=\"持续更新中….\"></a>持续更新中….</h5>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"1-CSS-盒子模型\"><a href=\"#1-CSS-盒子模型\" class=\"headerlink\" title=\"1. CSS 盒子模型\"></a>1. CSS 盒子模型</h4><p>在一个文档中，每个<strong>元素</strong>都被表示为一个<strong>矩形</strong>的盒子。确定这些盒子的尺寸, 属性 — 像它的颜色，背景，边框方面 — 和位置是渲染引擎的标。<br>在 CSS 中使用标准的<strong>盒模型</strong>来描述这些矩形盒子中的每一个，这个模型描述了元素所占空间的内容。每个盒子有四个边：<strong>外边距边</strong>, <strong>边框边</strong>, <strong>内填充边</strong> 与 <strong>内容边</strong>。分别对应CSS中的 <strong>margin</strong> <strong>border</strong> <strong>padding</strong> <strong>content</strong>。<br><img src=\"/blog/img/css-interview/boxmodel.png\"><br>或者可以这样描述: 宽度(width)=内容的宽度(content) + padding + border + margin</p>\n<p class=\"tip\">上面描述的是标准的盒子模型，当然还有低版本IE盒子模型，它可以进行这样描述:宽度(width)=内容的宽度(content+ padding + border) + margin，两者的区别可以很明显的看出。</p>\n\n<h4 id=\"2-box-sizing-属性\"><a href=\"#2-box-sizing-属性\" class=\"headerlink\" title=\"2. box-sizing 属性\"></a>2. box-sizing 属性</h4><p><strong>box-sizing</strong>在开发中很常见，它是盒子模型的解析模式,她有两个值：content-box和border-box,默认为content-box</p>\n<ul>\n<li><strong>content-box</strong>: 标准的W3C盒子模型，设置元素的height/width属性指的是conent部分的height/width</li>\n<li><strong>border-box</strong>: IE传统盒子模型，设置元素的height/width属性指的是border+padding+content部分的height/width</li>\n</ul>\n<blockquote>\n<p>这个属性很实用，比如你想将一个div的宽度设置为100%，然后又想加一个padding，如果不将box-sizing设置为border-box，那么这个div就会溢出，反之就是你想要的效果。</p>\n</blockquote>\n<h4 id=\"3-CSS-选择器\"><a href=\"#3-CSS-选择器\" class=\"headerlink\" title=\"3. CSS 选择器\"></a>3. CSS 选择器</h4><p>在 CSS 中，选择器是一种模式，用于选择需要添加样式的元素。</p>\n<table>\n<thead>\n<tr>\n<th>选择器</th>\n<th>例子</th>\n<th>例子描述</th>\n<th>CSS</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>.class</td>\n<td>.info</td>\n<td>选择 class=”info” 的所有元素。</td>\n<td>1</td>\n</tr>\n<tr>\n<td>#id</td>\n<td>#idName</td>\n<td>选择 id=”idName” 的所有元素。</td>\n<td>1</td>\n</tr>\n<tr>\n<td>*</td>\n<td>*</td>\n<td>选择所有元素。</td>\n<td>2</td>\n</tr>\n<tr>\n<td>element</td>\n<td>p</td>\n<td>选择 所有<code>&lt;p&gt;</code>元素。</td>\n<td>1</td>\n</tr>\n<tr>\n<td>element,element</td>\n<td>div,p</td>\n<td>选择所有<code>&lt;div&gt;</code>元素和所有 <code>&lt;p&gt;</code> 元素。</td>\n<td>1</td>\n</tr>\n<tr>\n<td>element element</td>\n<td>div p</td>\n<td>选择 <code>&lt;div&gt;</code> 元素内部的所有 <code>&lt;p&gt;</code> 元素。</td>\n<td>1</td>\n</tr>\n<tr>\n<td>element&gt;element</td>\n<td>div&gt;p</td>\n<td>选择所有父元素为<code>div</code>的<code>p</code>元素</td>\n<td>2</td>\n</tr>\n<tr>\n<td>element+element</td>\n<td>div+p</td>\n<td>选择紧接着<code>div</code>元素之后的所有<code>p</code>元素</td>\n<td>2</td>\n</tr>\n<tr>\n<td>[attribute]</td>\n<td>[target]</td>\n<td>选择带有 target 属性所有元素。</td>\n<td>2</td>\n</tr>\n<tr>\n<td>[attribute=value]</td>\n<td>[target=_blank]</td>\n<td>选择 target=”_blank” 的所有元素。</td>\n<td>2</td>\n</tr>\n<tr>\n<td>:link</td>\n<td>a:link</td>\n<td>选择所有未被访问的链接。</td>\n<td>1</td>\n</tr>\n<tr>\n<td>:first-letter</td>\n<td>p:first-letter</td>\n<td>选择每个 <code>&lt;p&gt;</code> 元素的首字母。。</td>\n<td>1</td>\n</tr>\n<tr>\n<td>:before</td>\n<td>p:before</td>\n<td>在每个 <code>&lt;p&gt;</code> 元素的内容之前插入内容。</td>\n<td>2</td>\n</tr>\n<tr>\n<td>:first-of-type</td>\n<td>p:first-of-type</td>\n<td>选择属于其父元素的首个 <code>&lt;p&gt;</code> 元素。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>:not(selector)</td>\n<td>:not(p)</td>\n<td>选择非 <code>&lt;p&gt;</code> 元素的每个元素。</td>\n<td>3</td>\n</tr>\n</tbody>\n</table>\n<p class=\"tip\">上面这些选择器是一些比较常见的选择器，其中也包含了一些CSS3中的新的选择器。<a href=\"http://www.w3school.com.cn/cssref/css_selectors.ASP\" target=\"_blank\" rel=\"noopener\">更多选择器</a></p>\n\n<h4 id=\"4-CSS-哪些属性可以继承\"><a href=\"#4-CSS-哪些属性可以继承\" class=\"headerlink\" title=\"4. CSS 哪些属性可以继承\"></a>4. CSS 哪些属性可以继承</h4><p>CSS 可继承的属性有:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* <span class=\"selector-tag\">font-size</span> </span><br><span class=\"line\">* <span class=\"selector-tag\">font-family</span> </span><br><span class=\"line\">* <span class=\"selector-tag\">color</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-CSS3新增伪类有那些\"><a href=\"#5-CSS3新增伪类有那些\" class=\"headerlink\" title=\"5. CSS3新增伪类有那些\"></a>5. CSS3新增伪类有那些</h4><ul>\n<li>p:first-of-type 选择其父元素的首个<code>&lt;p&gt;</code>元素</li>\n<li>p:first-of-type 选择其父元素的最后一个<code>&lt;p&gt;</code>元素</li>\n<li>p:only-of-type 选择属于其父元素唯一的元素</li>\n<li>p:only-child 选择属于其父元素的唯一子元素</li>\n<li>p:nth-child(2) 选择属于其父元素的第二个子元素</li>\n<li>:enabled :disabled 表单控件的禁用状态。</li>\n<li>:checked 单选框或复选框被选中。</li>\n</ul>\n<h4 id=\"6-CSS3有哪些新特性？\"><a href=\"#6-CSS3有哪些新特性？\" class=\"headerlink\" title=\"6. CSS3有哪些新特性？\"></a>6. CSS3有哪些新特性？</h4><ul>\n<li>RGBA和透明度</li>\n<li>background-image background-origin(content-box/padding-box/border-box) background-size background-repeat</li>\n<li>word-wrap（对长的不可分割单词换行）word-wrap：break-word</li>\n<li>文字阴影：text-shadow： 5px 5px 5px #FF0000;（水平阴影，垂直阴影，模糊距离，阴影颜色）</li>\n<li>font-face属性：定义自己的字体</li>\n<li>圆角（边框半径）：border-radius 属性用于创建圆角</li>\n<li>边框图片：border-image: url(border.png) 30 30 round</li>\n<li>盒阴影：box-shadow: 10px 10px 5px #888888</li>\n<li>媒体查询：定义两套css，当浏览器的尺寸变化时会采用不同的属性</li>\n</ul>\n<h4 id=\"7-用纯CSS创建一个三角形的原理\"><a href=\"#7-用纯CSS创建一个三角形的原理\" class=\"headerlink\" title=\"7. 用纯CSS创建一个三角形的原理\"></a>7. 用纯CSS创建一个三角形的原理</h4><p>首先将其宽度和高度设置为0，然后再设置其边框的样式。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">width</span>: 0;</span><br><span class=\"line\"><span class=\"selector-tag\">height</span>: 0;</span><br><span class=\"line\"><span class=\"selector-tag\">border-top</span>: 50<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">solid</span> <span class=\"selector-tag\">transparent</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">border-left</span>: 50<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">solid</span> <span class=\"selector-tag\">transparent</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">border-right</span>: 50<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">solid</span> <span class=\"selector-tag\">transparent</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">border-bottom</span>: 50<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">solid</span> <span class=\"selector-id\">#00ff00</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"8-清除浮动\"><a href=\"#8-清除浮动\" class=\"headerlink\" title=\"8. 清除浮动\"></a>8. 清除浮动</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.clearfix</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">zoom</span>:<span class=\"number\">1</span></span><br><span class=\"line\">  &amp;::after &#123;</span><br><span class=\"line\">    content: <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">visibility</span>: hidden;</span><br><span class=\"line\">    <span class=\"attribute\">clear</span>: both;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"9-移动端布局的媒体查询\"><a href=\"#9-移动端布局的媒体查询\" class=\"headerlink\" title=\"9. 移动端布局的媒体查询\"></a>9. 移动端布局的媒体查询</h4><p>通过媒体查询可以为不同大小和尺寸的媒体定义不同的css，适应相应的设备的显示。</p>\n<ul>\n<li><p><head><meta name=\"generator\" content=\"Hexo 3.8.0\"></head>里面</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"xxx.css\"</span> <span class=\"attr\">media</span>=<span class=\"string\">\"only screen and (max-device-width:480px)\"</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>CSS</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">: @media only screen and (max-device-width:480px) &#123;/css样式/&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"10-before-和-after中双冒号和单冒号的区别\"><a href=\"#10-before-和-after中双冒号和单冒号的区别\" class=\"headerlink\" title=\"10.  ::before 和 :after中双冒号和单冒号的区别\"></a>10.  ::before 和 :after中双冒号和单冒号的区别</h4><p>1.单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素<br>2.::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。<br>:before 和 :after 这两个伪元素，是在CSS2.1里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着Web的进化，在CSS3的规范里，伪元素的语法被修改成使用双冒号，成为::before ::after</p>\n<h4 id=\"11-png、jpg、gif、webp图片格式\"><a href=\"#11-png、jpg、gif、webp图片格式\" class=\"headerlink\" title=\"11. png、jpg、gif、webp图片格式\"></a>11. png、jpg、gif、webp图片格式</h4><ul>\n<li>png是便携式网络图片（Portable Network Graphics）是一种无损数据压缩位图文件格式.优点是：压缩比高，色彩好。 大多数地方都可以用。</li>\n<li>jpg是一种针对相片使用的一种失真压缩方法，是一种破坏性的压缩，在色调及颜色平滑变化做的不错。在www上，被用来储存和传输照片的格式。</li>\n<li>gif是一种位图文件格式，以8位色重现真色彩的图像。可以实现动画效果.</li>\n<li>webp格式是谷歌在2010年推出的图片格式，压缩率只有jpg的2/3，大小比png小了45%。缺点是压缩的时间更久了，兼容性不好，目前谷歌和opera支持。</li>\n</ul>\n<h5 id=\"持续更新中…\"><a href=\"#持续更新中…\" class=\"headerlink\" title=\"持续更新中….\"></a>持续更新中….</h5>"},{"title":"用 vue 写小程序，基于 mpvue 框架重写 weui","date":"2018-03-19T16:01:30.000Z","summary":"上周美团开源了 mpvue 框架，他基于 Vue.js 的小程序开发框架，从底层支持 Vue.js 语法和构建工具体系。what，小程序可以用 vue 写了？简直有点不太敢确定，看了一下简介，没错，真的可以用 vue 开发小程序。真的是**限制了我的想象力，明白又该学写了，于是就开始准备利用这个框架写一点项目，感受一下他的魅力(其实是踩坑)。","_content":"# [mpvue-weui](https://github.com/KuangPF/mpvue-weui)\n\n## 前言\n上周美团开源了 [mpvue](https://github.com/Meituan-Dianping/mpvue) 框架，他基于` Vue.js` 的小程序开发框架，从底层支持 `Vue.js` 语法和构建工具体系。what，小程序可以用`vue`写了？简直有点不太敢确定，花了[5分钟](http://mpvue.com/mpvue/quickstart/)看了一下简介，没错，真的可以用`vue`开发小程序。真的是**限制了我的想象力，明白又该学写了，于是就开始准备利用这个框架写一点项目，感受一下他的魅力(其实是踩坑)。\n\n## 重写 `WeUI`\n俗话说，**第一个吃螃蟹的人，总要踩一些坑**（俗话有这么说过？）。[WeUI](https://weui.io/)是微信的官方 UI 库，在小程序中或者移动端使用的非常多，那么就有了一些想法:用 `mpvue` 重写 `WeUI`。\n\n##  `mpvue-weui`是什么\n也许 `mpvue-weui` 的内容不像它的名字那么高大上，它不是一个UI库（原谅我霸占了这么好的名字），其实它就是一个 `WeUI`的 demo 库，就像 [WeUI](https://weui.io/)一样，只不过是基于 `mpvue` 框架重写了一下。\n\n## 重写目的\n其实重写的目的就是看看`mpvue`好不好用，里面有哪些坑，然后将它写成[文档](https://kuangpf.github.io/mpvue-weui/#/)的形式，从而避免基于`mpvue`框架开发的人再次踩坑。\n\n## 重写感受\n当重写完了以后，发现最大的感受就是：\n\n* 开发体验很棒，VSCode(IDE 自选)写代码，小程序开发工具开效果；\n* 对小程序官方组件和 API 支持的非常完美；\n* 快捷的 webpack 构建机制，开发过程中热更新.\n* ...\n\n这次主要是重写 `Weui`，可能在自定义组件交互方面还没涉及，比如可以使用`vuex`进行状态管理，或者将来要支持`vue-router`。总之很好用，为美团点赞。\n\n## 重写效果\n\n![](https://user-gold-cdn.xitu.io/2018/3/14/16224e73e631622d?w=381&h=670&f=png&s=12631)\n![](https://user-gold-cdn.xitu.io/2018/3/14/16224e7707ec3aac?w=378&h=670&f=png&s=14440)\n![](https://user-gold-cdn.xitu.io/2018/3/14/16224e7fae68699b?w=376&h=669&f=png&s=6951)\n![](https://user-gold-cdn.xitu.io/2018/3/14/16224e81004b17b2?w=377&h=670&f=png&s=8907)\n\n## 踩坑文档\n[mpvue-weui 踩坑文档](https://kuangpf.github.io/mpvue-weui/#/)\n\ntip: 文档会随着`mpvue`新语法或者新特性的更新而继续完善。\n\n## 相关申明\n\n1. 本项目[mpvue-weui](https://github.com/KuangPF/mpvue-weui)主要使用了 [weui-wxss](https://github.com/Tencent/weui-wxss) 中的相关文件，主要目的在于交流学习，如果冒犯了相关的开源协议，实属抱歉。\n2. 这篇文档是自己在重写了 `WeUI` 以后记录的，如果有说的不对的地方还希望各位大佬指出，一起学习。\n\n\n\n","source":"_posts/mpvue-weui.md","raw":"---\ntitle: 用 vue 写小程序，基于 mpvue 框架重写 weui\ndate: 2018-03-20 00:01:30\ntags: [mpvue,vue,小程序]\nsummary: 上周美团开源了 mpvue 框架，他基于 Vue.js 的小程序开发框架，从底层支持 Vue.js 语法和构建工具体系。what，小程序可以用 vue 写了？简直有点不太敢确定，看了一下简介，没错，真的可以用 vue 开发小程序。真的是**限制了我的想象力，明白又该学写了，于是就开始准备利用这个框架写一点项目，感受一下他的魅力(其实是踩坑)。\n---\n# [mpvue-weui](https://github.com/KuangPF/mpvue-weui)\n\n## 前言\n上周美团开源了 [mpvue](https://github.com/Meituan-Dianping/mpvue) 框架，他基于` Vue.js` 的小程序开发框架，从底层支持 `Vue.js` 语法和构建工具体系。what，小程序可以用`vue`写了？简直有点不太敢确定，花了[5分钟](http://mpvue.com/mpvue/quickstart/)看了一下简介，没错，真的可以用`vue`开发小程序。真的是**限制了我的想象力，明白又该学写了，于是就开始准备利用这个框架写一点项目，感受一下他的魅力(其实是踩坑)。\n\n## 重写 `WeUI`\n俗话说，**第一个吃螃蟹的人，总要踩一些坑**（俗话有这么说过？）。[WeUI](https://weui.io/)是微信的官方 UI 库，在小程序中或者移动端使用的非常多，那么就有了一些想法:用 `mpvue` 重写 `WeUI`。\n\n##  `mpvue-weui`是什么\n也许 `mpvue-weui` 的内容不像它的名字那么高大上，它不是一个UI库（原谅我霸占了这么好的名字），其实它就是一个 `WeUI`的 demo 库，就像 [WeUI](https://weui.io/)一样，只不过是基于 `mpvue` 框架重写了一下。\n\n## 重写目的\n其实重写的目的就是看看`mpvue`好不好用，里面有哪些坑，然后将它写成[文档](https://kuangpf.github.io/mpvue-weui/#/)的形式，从而避免基于`mpvue`框架开发的人再次踩坑。\n\n## 重写感受\n当重写完了以后，发现最大的感受就是：\n\n* 开发体验很棒，VSCode(IDE 自选)写代码，小程序开发工具开效果；\n* 对小程序官方组件和 API 支持的非常完美；\n* 快捷的 webpack 构建机制，开发过程中热更新.\n* ...\n\n这次主要是重写 `Weui`，可能在自定义组件交互方面还没涉及，比如可以使用`vuex`进行状态管理，或者将来要支持`vue-router`。总之很好用，为美团点赞。\n\n## 重写效果\n\n![](https://user-gold-cdn.xitu.io/2018/3/14/16224e73e631622d?w=381&h=670&f=png&s=12631)\n![](https://user-gold-cdn.xitu.io/2018/3/14/16224e7707ec3aac?w=378&h=670&f=png&s=14440)\n![](https://user-gold-cdn.xitu.io/2018/3/14/16224e7fae68699b?w=376&h=669&f=png&s=6951)\n![](https://user-gold-cdn.xitu.io/2018/3/14/16224e81004b17b2?w=377&h=670&f=png&s=8907)\n\n## 踩坑文档\n[mpvue-weui 踩坑文档](https://kuangpf.github.io/mpvue-weui/#/)\n\ntip: 文档会随着`mpvue`新语法或者新特性的更新而继续完善。\n\n## 相关申明\n\n1. 本项目[mpvue-weui](https://github.com/KuangPF/mpvue-weui)主要使用了 [weui-wxss](https://github.com/Tencent/weui-wxss) 中的相关文件，主要目的在于交流学习，如果冒犯了相关的开源协议，实属抱歉。\n2. 这篇文档是自己在重写了 `WeUI` 以后记录的，如果有说的不对的地方还希望各位大佬指出，一起学习。\n\n\n\n","slug":"mpvue-weui","published":1,"updated":"2019-04-10T08:15:01.346Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2mo4mxe0005dt47jqler9ti","content":"<h1 id=\"mpvue-weui\"><a href=\"#mpvue-weui\" class=\"headerlink\" title=\"mpvue-weui\"></a><a href=\"https://github.com/KuangPF/mpvue-weui\" target=\"_blank\" rel=\"noopener\">mpvue-weui</a></h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>上周美团开源了 <a href=\"https://github.com/Meituan-Dianping/mpvue\" target=\"_blank\" rel=\"noopener\">mpvue</a> 框架，他基于<code>Vue.js</code> 的小程序开发框架，从底层支持 <code>Vue.js</code> 语法和构建工具体系。what，小程序可以用<code>vue</code>写了？简直有点不太敢确定，花了<a href=\"http://mpvue.com/mpvue/quickstart/\" target=\"_blank\" rel=\"noopener\">5分钟</a>看了一下简介，没错，真的可以用<code>vue</code>开发小程序。真的是**限制了我的想象力，明白又该学写了，于是就开始准备利用这个框架写一点项目，感受一下他的魅力(其实是踩坑)。</p>\n<h2 id=\"重写-WeUI\"><a href=\"#重写-WeUI\" class=\"headerlink\" title=\"重写 WeUI\"></a>重写 <code>WeUI</code></h2><p>俗话说，<strong>第一个吃螃蟹的人，总要踩一些坑</strong>（俗话有这么说过？）。<a href=\"https://weui.io/\" target=\"_blank\" rel=\"noopener\">WeUI</a>是微信的官方 UI 库，在小程序中或者移动端使用的非常多，那么就有了一些想法:用 <code>mpvue</code> 重写 <code>WeUI</code>。</p>\n<h2 id=\"mpvue-weui是什么\"><a href=\"#mpvue-weui是什么\" class=\"headerlink\" title=\"mpvue-weui是什么\"></a><code>mpvue-weui</code>是什么</h2><p>也许 <code>mpvue-weui</code> 的内容不像它的名字那么高大上，它不是一个UI库（原谅我霸占了这么好的名字），其实它就是一个 <code>WeUI</code>的 demo 库，就像 <a href=\"https://weui.io/\" target=\"_blank\" rel=\"noopener\">WeUI</a>一样，只不过是基于 <code>mpvue</code> 框架重写了一下。</p>\n<h2 id=\"重写目的\"><a href=\"#重写目的\" class=\"headerlink\" title=\"重写目的\"></a>重写目的</h2><p>其实重写的目的就是看看<code>mpvue</code>好不好用，里面有哪些坑，然后将它写成<a href=\"https://kuangpf.github.io/mpvue-weui/#/\" target=\"_blank\" rel=\"noopener\">文档</a>的形式，从而避免基于<code>mpvue</code>框架开发的人再次踩坑。</p>\n<h2 id=\"重写感受\"><a href=\"#重写感受\" class=\"headerlink\" title=\"重写感受\"></a>重写感受</h2><p>当重写完了以后，发现最大的感受就是：</p>\n<ul>\n<li>开发体验很棒，VSCode(IDE 自选)写代码，小程序开发工具开效果；</li>\n<li>对小程序官方组件和 API 支持的非常完美；</li>\n<li>快捷的 webpack 构建机制，开发过程中热更新.</li>\n<li>…</li>\n</ul>\n<p>这次主要是重写 <code>Weui</code>，可能在自定义组件交互方面还没涉及，比如可以使用<code>vuex</code>进行状态管理，或者将来要支持<code>vue-router</code>。总之很好用，为美团点赞。</p>\n<h2 id=\"重写效果\"><a href=\"#重写效果\" class=\"headerlink\" title=\"重写效果\"></a>重写效果</h2><p><img src=\"https://user-gold-cdn.xitu.io/2018/3/14/16224e73e631622d?w=381&amp;h=670&amp;f=png&amp;s=12631\" alt><br><img src=\"https://user-gold-cdn.xitu.io/2018/3/14/16224e7707ec3aac?w=378&amp;h=670&amp;f=png&amp;s=14440\" alt><br><img src=\"https://user-gold-cdn.xitu.io/2018/3/14/16224e7fae68699b?w=376&amp;h=669&amp;f=png&amp;s=6951\" alt><br><img src=\"https://user-gold-cdn.xitu.io/2018/3/14/16224e81004b17b2?w=377&amp;h=670&amp;f=png&amp;s=8907\" alt></p>\n<h2 id=\"踩坑文档\"><a href=\"#踩坑文档\" class=\"headerlink\" title=\"踩坑文档\"></a>踩坑文档</h2><p><a href=\"https://kuangpf.github.io/mpvue-weui/#/\" target=\"_blank\" rel=\"noopener\">mpvue-weui 踩坑文档</a></p>\n<p>tip: 文档会随着<code>mpvue</code>新语法或者新特性的更新而继续完善。</p>\n<h2 id=\"相关申明\"><a href=\"#相关申明\" class=\"headerlink\" title=\"相关申明\"></a>相关申明</h2><ol>\n<li>本项目<a href=\"https://github.com/KuangPF/mpvue-weui\" target=\"_blank\" rel=\"noopener\">mpvue-weui</a>主要使用了 <a href=\"https://github.com/Tencent/weui-wxss\" target=\"_blank\" rel=\"noopener\">weui-wxss</a> 中的相关文件，主要目的在于交流学习，如果冒犯了相关的开源协议，实属抱歉。</li>\n<li>这篇文档是自己在重写了 <code>WeUI</code> 以后记录的，如果有说的不对的地方还希望各位大佬指出，一起学习。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"mpvue-weui\"><a href=\"#mpvue-weui\" class=\"headerlink\" title=\"mpvue-weui\"></a><a href=\"https://github.com/KuangPF/mpvue-weui\" target=\"_blank\" rel=\"noopener\">mpvue-weui</a></h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>上周美团开源了 <a href=\"https://github.com/Meituan-Dianping/mpvue\" target=\"_blank\" rel=\"noopener\">mpvue</a> 框架，他基于<code>Vue.js</code> 的小程序开发框架，从底层支持 <code>Vue.js</code> 语法和构建工具体系。what，小程序可以用<code>vue</code>写了？简直有点不太敢确定，花了<a href=\"http://mpvue.com/mpvue/quickstart/\" target=\"_blank\" rel=\"noopener\">5分钟</a>看了一下简介，没错，真的可以用<code>vue</code>开发小程序。真的是**限制了我的想象力，明白又该学写了，于是就开始准备利用这个框架写一点项目，感受一下他的魅力(其实是踩坑)。</p>\n<h2 id=\"重写-WeUI\"><a href=\"#重写-WeUI\" class=\"headerlink\" title=\"重写 WeUI\"></a>重写 <code>WeUI</code></h2><p>俗话说，<strong>第一个吃螃蟹的人，总要踩一些坑</strong>（俗话有这么说过？）。<a href=\"https://weui.io/\" target=\"_blank\" rel=\"noopener\">WeUI</a>是微信的官方 UI 库，在小程序中或者移动端使用的非常多，那么就有了一些想法:用 <code>mpvue</code> 重写 <code>WeUI</code>。</p>\n<h2 id=\"mpvue-weui是什么\"><a href=\"#mpvue-weui是什么\" class=\"headerlink\" title=\"mpvue-weui是什么\"></a><code>mpvue-weui</code>是什么</h2><p>也许 <code>mpvue-weui</code> 的内容不像它的名字那么高大上，它不是一个UI库（原谅我霸占了这么好的名字），其实它就是一个 <code>WeUI</code>的 demo 库，就像 <a href=\"https://weui.io/\" target=\"_blank\" rel=\"noopener\">WeUI</a>一样，只不过是基于 <code>mpvue</code> 框架重写了一下。</p>\n<h2 id=\"重写目的\"><a href=\"#重写目的\" class=\"headerlink\" title=\"重写目的\"></a>重写目的</h2><p>其实重写的目的就是看看<code>mpvue</code>好不好用，里面有哪些坑，然后将它写成<a href=\"https://kuangpf.github.io/mpvue-weui/#/\" target=\"_blank\" rel=\"noopener\">文档</a>的形式，从而避免基于<code>mpvue</code>框架开发的人再次踩坑。</p>\n<h2 id=\"重写感受\"><a href=\"#重写感受\" class=\"headerlink\" title=\"重写感受\"></a>重写感受</h2><p>当重写完了以后，发现最大的感受就是：</p>\n<ul>\n<li>开发体验很棒，VSCode(IDE 自选)写代码，小程序开发工具开效果；</li>\n<li>对小程序官方组件和 API 支持的非常完美；</li>\n<li>快捷的 webpack 构建机制，开发过程中热更新.</li>\n<li>…</li>\n</ul>\n<p>这次主要是重写 <code>Weui</code>，可能在自定义组件交互方面还没涉及，比如可以使用<code>vuex</code>进行状态管理，或者将来要支持<code>vue-router</code>。总之很好用，为美团点赞。</p>\n<h2 id=\"重写效果\"><a href=\"#重写效果\" class=\"headerlink\" title=\"重写效果\"></a>重写效果</h2><p><img src=\"https://user-gold-cdn.xitu.io/2018/3/14/16224e73e631622d?w=381&amp;h=670&amp;f=png&amp;s=12631\" alt><br><img src=\"https://user-gold-cdn.xitu.io/2018/3/14/16224e7707ec3aac?w=378&amp;h=670&amp;f=png&amp;s=14440\" alt><br><img src=\"https://user-gold-cdn.xitu.io/2018/3/14/16224e7fae68699b?w=376&amp;h=669&amp;f=png&amp;s=6951\" alt><br><img src=\"https://user-gold-cdn.xitu.io/2018/3/14/16224e81004b17b2?w=377&amp;h=670&amp;f=png&amp;s=8907\" alt></p>\n<h2 id=\"踩坑文档\"><a href=\"#踩坑文档\" class=\"headerlink\" title=\"踩坑文档\"></a>踩坑文档</h2><p><a href=\"https://kuangpf.github.io/mpvue-weui/#/\" target=\"_blank\" rel=\"noopener\">mpvue-weui 踩坑文档</a></p>\n<p>tip: 文档会随着<code>mpvue</code>新语法或者新特性的更新而继续完善。</p>\n<h2 id=\"相关申明\"><a href=\"#相关申明\" class=\"headerlink\" title=\"相关申明\"></a>相关申明</h2><ol>\n<li>本项目<a href=\"https://github.com/KuangPF/mpvue-weui\" target=\"_blank\" rel=\"noopener\">mpvue-weui</a>主要使用了 <a href=\"https://github.com/Tencent/weui-wxss\" target=\"_blank\" rel=\"noopener\">weui-wxss</a> 中的相关文件，主要目的在于交流学习，如果冒犯了相关的开源协议，实属抱歉。</li>\n<li>这篇文档是自己在重写了 <code>WeUI</code> 以后记录的，如果有说的不对的地方还希望各位大佬指出，一起学习。</li>\n</ol>\n"},{"title":"javascript 遍历方法汇总","date":"2018-02-11T08:02:54.000Z","summary":"对于数组中的遍历也许再熟悉不过，感觉从最开始接触C语言的时候就遇到了遍历...下面就一起来说说`javascript`中的遍历方法，以及他们之间的性能比较。","_content":"对于数组中的遍历也许再熟悉不过，感觉从最开始接触`C`语言的时候就遇到了遍历...下面就一起来说说`javascript`中的遍历方法，以及他们之间的性能比较。\n## for 循环语句\n``` javascript\nlet tempArry = [1, 2, 3, 4, 5];\n\n// for 循环语句\nfor (let i = 0; i < tempArry.length; i++) {\n  console.log(tempArry[i]);\n}\n```\n> 性能解读：这是我们最熟悉的一种遍历方式，也是最简单，使用频率最高的。他的性能虽然不弱，但是由于每次遍历都需要重新定义变量，因此还可以进行改进\n\n####  for 循环语句 改进\n``` javascript\nlet tempArry = [1, 2, 3, 4, 5];\nfor (let i = 0, len = tempArry.length; i < len; i++) {\n  console.log(tempArry[i]);\n}\n```\n> 减少了变量的定义，提高了遍历的性能，而且这种遍历方式性能最优。\n\n## forEach\n``` javascript\nlet tempArry = [1, 2, 3, 4, 5];\ntempArry.forEach((value, key, arry) => {\n  console.log(value); // 依次输出 1,2,3,4,5，\n  console.log(key); // 依次输出 0,1,2,3,4\n  console.log(arry); // 始终输出 [1,2,3,4,5]\n})\n```\n> `forEach`方法是数组内置方法，他的好处在于不用重新定义一系列变量，便于使用，但是从效率以及性能角度来说它是劣于原始for循环,而且`forEach`不支持`return`。\n\n## map\n``` javascript\nlet tempArry = [1, 2, 3, 4, 5];\nlet tempArryMap = tempArry.map((value, key, arry) => {\n  console.log(value);\n  console.log(key);\n  console.log(arry);\n  return value + 1;\n})\nconsole.log(tempArry); // 结果为 [1, 2, 3, 4, 5]\nconsole.log(tempArryMap); // 结果为 [2, 3, 4, 5, 6]\n```\n> `map`也是数组的内置方法，写法与`forEach`没有什么不一样的，不同点在于`map`可以改变当前循环的值，而`forEach`则不可以。因此`map`一般用来处理需要修改某一个数组的值，在效率以及性能上也不如原始的`for`循环。\n\n## filter\n``` javascript\nlet tempArry = [1, 2, 3, 4, 5];\nlet tempArryFilter = tempArry.filter((value, key, arry) => {\n  console.log(value);\n  console.log(key);\n  console.log(arry);\n  if (value === 5) {\n    return false;\n  }\n  return true;\n})\nconsole.log(tempArry); // 结果为 [1, 2, 3, 4, 5]\nconsole.log(tempArryFilter); // 结果为 [1, 2, 3, 4]\n```\n> `filter`也是数组内置的方法，`filter`和`map`不同，`map`目的是为了改变值，而`filter`目的是为了去掉不要的值，在循环的时候如果返回的是`false`那么就表示本次循环的不添加该值，返回`true`则相反是表示要添加到新建的数组中\n\n## reduce\n``` javascript\nlet tempArry = [1, 2, 3, 4, 5];\nlet tempArryReduce = tempArry.reduce((count, value,key,arry)=> {\n  console.log(count);  // 依次为  0,1,3,6,10\n  console.log(value);  // 依次为 1,2,3,4,5\n  console.log(key);  // 0,1,2,3,4\n  console.log(arry)  // 始终为 [1,2,3,4,5]\n  return count + value;\n},0);\nconsole.log(tempArry); // 结果为 [1, 2, 3, 4, 5]\nconsole.log(tempArryReduce)  // 结果为 16\n```\n> `reduce`的不同之处在于累加，和其他几个内置方法不同的地方，它的第二个参数不是`this`对象，而是初始累加值（如果不设置的话数组会乱掉），而且回调函数的的个数也不同，比其他的多了一个，而且还在在开始的多加了一个参数，第一个参数记录的是上一次循环的累加值\n\n## some\n``` javascript\nlet tempArry = [1, 2, 3, 4, 5];\nlet tempArrySome = tempArry.some((value,key,arry)=> {  \n  console.log(value);  // 依次为 1,2,3 \n  console.log(key);   // 0,1,2\n  console.log(arry) // 始终为[1, 2, 3, 4, 5]\n  return value === 3;\n});\nconsole.log(tempArry); // [1, 2, 3, 4, 5]\nconsole.log(tempArrySome)  // true\n```\n> `some`的不同之处在它返回的布尔值，它的作用有点像filter，不过它的目的不是为了筛选返回数组，而是为了筛选该数组是否有满足你要的值，而且找到符合条件的值返回了一次`true`之后就不会再继续执行了\n\n## every\n``` javascript\n// [...].every(ck)函数,某一个为false，则返回false,如果全部返回true，则返回true  \nlet tempArry = [1, 2, 3, 4, 5];\nlet tempArryEvery = tempArry.every((value,key,arry)=> {  \n  console.log(value);  // 1\n  console.log(key);   // 0\n  console.log(arry) // 始终为[1, 2, 3, 4, 5]\n  return value === 3;\n});\nconsole.log(tempArry); // [1, 2, 3, 4, 5]\nconsole.log(tempArryEvery)  // false\n```\n> 每个数组元素都执行一次`ck`函数，直到某个元素执行函数`ck`返回`false`,如果返回`false`则直接返回`false`,如果全部返回`true`，则返回`true`\n\n## indexOf\n``` javascript\nlet tempArry = [1, 2, 3, 4, 5];\nlet tempArryIndexOf = tempArry.indexOf(3);\nconsole.log(tempArry); // [1, 2, 3, 4, 5]\nconsole.log(tempArryIndexOf)  // 2\n```\n> 对于`indexOf`方法来说，在数组循环过程中会和传入的参数比对，如果是比对成功，那么终止循环，返回对比成功的下标。\n\n## lastIndexOf\n``` javascript\nlet tempArry = [1,2,3,4,5,4,3,4,5]\nlet tempArryLastIndexOf = tempArry.lastIndexOf(5);\nconsole.log(tempArry); // [1,2,3,4,5,4,3,4,5]\nconsole.log(tempArryLastIndexOf)  // 8\n```\n> lastIndexOf方法和indexOf作用一致，但查找方向不同，indexOf是正向查找，lastIndexOf是逆向查找，找到之后返回成功的下标\n\n<p class=\"tip\">小结：对于以上8个数组的内置方法，forEach方法仅仅只是为了循环，并不可以帮你做额外的事情；map方法相当于在循环的时候你告诉数组当前遍历的这个值需要改成什么样，那么它就会最后给什么样的数组；filter方法相当于在循环的时候数组遍历一个个对象，并问你这个是不是你要找的值，如果你说是，他就会给你返回一个到新的数组中，不是他就会剔除；reduce方法相当于循环遍历对象做统计（累加或者累减之类的）;some和every方法相当于在遍历的时候拿着一个个对象问你这个是不是你找的，只要你说了一遍是，那么他就会给你分别返回的是true和false；indexOf和lastIndexOf方法相当于你告诉它你要找什么值，找到之后立马返回给你它的门牌号。</p>\n\n## for...in\n``` javascript\nlet tempArry = [1, 2, 3, 4, 5];\nfor (let key in tempArry) {\n  console.log(key); // 依次输出 0,1,2,3,4\n}\n\nlet tempArryIn = {\n  '1': 'a',\n  '2': 'b',\n  '3': 'c'\n};\nfor (let key in tempArryIn) {\n console.log(key); // 依次输出 1,2,3\n```\n> 从结果得知,for...in遍历数组的时候是遍历数组的下标值，而在遍历对象的时候遍历的是key值\n\n<p class=\"tip\">在进行遍历的时候不推荐使用`for...in`</p>\n\n## for...of\n``` javascript\nlet tempArry = [1, 2, 3, 4, 5];\nfor(let value of tempArry) {\n  console.log(value); // 依次输入 1,2,3,4,5\n}\n```\n> `for...of`语句遍历的是值，而不是下标，但`for...of`不支持循环对象。\n\n<p class=\"tip\">总结：通过上面几种遍历方法可以看出，原始`for`的循环的效率和性能最高，尤其是在数据越多的时候它的优势体现的越明显，其他的方法可以根据需求灵活的选择。</p>","source":"_posts/javascript-traverse.md","raw":"---\ntitle: javascript 遍历方法汇总\ndate: 2018-02-11 16:02:54\ntags: javascript\nsummary: 对于数组中的遍历也许再熟悉不过，感觉从最开始接触C语言的时候就遇到了遍历...下面就一起来说说`javascript`中的遍历方法，以及他们之间的性能比较。\n---\n对于数组中的遍历也许再熟悉不过，感觉从最开始接触`C`语言的时候就遇到了遍历...下面就一起来说说`javascript`中的遍历方法，以及他们之间的性能比较。\n## for 循环语句\n``` javascript\nlet tempArry = [1, 2, 3, 4, 5];\n\n// for 循环语句\nfor (let i = 0; i < tempArry.length; i++) {\n  console.log(tempArry[i]);\n}\n```\n> 性能解读：这是我们最熟悉的一种遍历方式，也是最简单，使用频率最高的。他的性能虽然不弱，但是由于每次遍历都需要重新定义变量，因此还可以进行改进\n\n####  for 循环语句 改进\n``` javascript\nlet tempArry = [1, 2, 3, 4, 5];\nfor (let i = 0, len = tempArry.length; i < len; i++) {\n  console.log(tempArry[i]);\n}\n```\n> 减少了变量的定义，提高了遍历的性能，而且这种遍历方式性能最优。\n\n## forEach\n``` javascript\nlet tempArry = [1, 2, 3, 4, 5];\ntempArry.forEach((value, key, arry) => {\n  console.log(value); // 依次输出 1,2,3,4,5，\n  console.log(key); // 依次输出 0,1,2,3,4\n  console.log(arry); // 始终输出 [1,2,3,4,5]\n})\n```\n> `forEach`方法是数组内置方法，他的好处在于不用重新定义一系列变量，便于使用，但是从效率以及性能角度来说它是劣于原始for循环,而且`forEach`不支持`return`。\n\n## map\n``` javascript\nlet tempArry = [1, 2, 3, 4, 5];\nlet tempArryMap = tempArry.map((value, key, arry) => {\n  console.log(value);\n  console.log(key);\n  console.log(arry);\n  return value + 1;\n})\nconsole.log(tempArry); // 结果为 [1, 2, 3, 4, 5]\nconsole.log(tempArryMap); // 结果为 [2, 3, 4, 5, 6]\n```\n> `map`也是数组的内置方法，写法与`forEach`没有什么不一样的，不同点在于`map`可以改变当前循环的值，而`forEach`则不可以。因此`map`一般用来处理需要修改某一个数组的值，在效率以及性能上也不如原始的`for`循环。\n\n## filter\n``` javascript\nlet tempArry = [1, 2, 3, 4, 5];\nlet tempArryFilter = tempArry.filter((value, key, arry) => {\n  console.log(value);\n  console.log(key);\n  console.log(arry);\n  if (value === 5) {\n    return false;\n  }\n  return true;\n})\nconsole.log(tempArry); // 结果为 [1, 2, 3, 4, 5]\nconsole.log(tempArryFilter); // 结果为 [1, 2, 3, 4]\n```\n> `filter`也是数组内置的方法，`filter`和`map`不同，`map`目的是为了改变值，而`filter`目的是为了去掉不要的值，在循环的时候如果返回的是`false`那么就表示本次循环的不添加该值，返回`true`则相反是表示要添加到新建的数组中\n\n## reduce\n``` javascript\nlet tempArry = [1, 2, 3, 4, 5];\nlet tempArryReduce = tempArry.reduce((count, value,key,arry)=> {\n  console.log(count);  // 依次为  0,1,3,6,10\n  console.log(value);  // 依次为 1,2,3,4,5\n  console.log(key);  // 0,1,2,3,4\n  console.log(arry)  // 始终为 [1,2,3,4,5]\n  return count + value;\n},0);\nconsole.log(tempArry); // 结果为 [1, 2, 3, 4, 5]\nconsole.log(tempArryReduce)  // 结果为 16\n```\n> `reduce`的不同之处在于累加，和其他几个内置方法不同的地方，它的第二个参数不是`this`对象，而是初始累加值（如果不设置的话数组会乱掉），而且回调函数的的个数也不同，比其他的多了一个，而且还在在开始的多加了一个参数，第一个参数记录的是上一次循环的累加值\n\n## some\n``` javascript\nlet tempArry = [1, 2, 3, 4, 5];\nlet tempArrySome = tempArry.some((value,key,arry)=> {  \n  console.log(value);  // 依次为 1,2,3 \n  console.log(key);   // 0,1,2\n  console.log(arry) // 始终为[1, 2, 3, 4, 5]\n  return value === 3;\n});\nconsole.log(tempArry); // [1, 2, 3, 4, 5]\nconsole.log(tempArrySome)  // true\n```\n> `some`的不同之处在它返回的布尔值，它的作用有点像filter，不过它的目的不是为了筛选返回数组，而是为了筛选该数组是否有满足你要的值，而且找到符合条件的值返回了一次`true`之后就不会再继续执行了\n\n## every\n``` javascript\n// [...].every(ck)函数,某一个为false，则返回false,如果全部返回true，则返回true  \nlet tempArry = [1, 2, 3, 4, 5];\nlet tempArryEvery = tempArry.every((value,key,arry)=> {  \n  console.log(value);  // 1\n  console.log(key);   // 0\n  console.log(arry) // 始终为[1, 2, 3, 4, 5]\n  return value === 3;\n});\nconsole.log(tempArry); // [1, 2, 3, 4, 5]\nconsole.log(tempArryEvery)  // false\n```\n> 每个数组元素都执行一次`ck`函数，直到某个元素执行函数`ck`返回`false`,如果返回`false`则直接返回`false`,如果全部返回`true`，则返回`true`\n\n## indexOf\n``` javascript\nlet tempArry = [1, 2, 3, 4, 5];\nlet tempArryIndexOf = tempArry.indexOf(3);\nconsole.log(tempArry); // [1, 2, 3, 4, 5]\nconsole.log(tempArryIndexOf)  // 2\n```\n> 对于`indexOf`方法来说，在数组循环过程中会和传入的参数比对，如果是比对成功，那么终止循环，返回对比成功的下标。\n\n## lastIndexOf\n``` javascript\nlet tempArry = [1,2,3,4,5,4,3,4,5]\nlet tempArryLastIndexOf = tempArry.lastIndexOf(5);\nconsole.log(tempArry); // [1,2,3,4,5,4,3,4,5]\nconsole.log(tempArryLastIndexOf)  // 8\n```\n> lastIndexOf方法和indexOf作用一致，但查找方向不同，indexOf是正向查找，lastIndexOf是逆向查找，找到之后返回成功的下标\n\n<p class=\"tip\">小结：对于以上8个数组的内置方法，forEach方法仅仅只是为了循环，并不可以帮你做额外的事情；map方法相当于在循环的时候你告诉数组当前遍历的这个值需要改成什么样，那么它就会最后给什么样的数组；filter方法相当于在循环的时候数组遍历一个个对象，并问你这个是不是你要找的值，如果你说是，他就会给你返回一个到新的数组中，不是他就会剔除；reduce方法相当于循环遍历对象做统计（累加或者累减之类的）;some和every方法相当于在遍历的时候拿着一个个对象问你这个是不是你找的，只要你说了一遍是，那么他就会给你分别返回的是true和false；indexOf和lastIndexOf方法相当于你告诉它你要找什么值，找到之后立马返回给你它的门牌号。</p>\n\n## for...in\n``` javascript\nlet tempArry = [1, 2, 3, 4, 5];\nfor (let key in tempArry) {\n  console.log(key); // 依次输出 0,1,2,3,4\n}\n\nlet tempArryIn = {\n  '1': 'a',\n  '2': 'b',\n  '3': 'c'\n};\nfor (let key in tempArryIn) {\n console.log(key); // 依次输出 1,2,3\n```\n> 从结果得知,for...in遍历数组的时候是遍历数组的下标值，而在遍历对象的时候遍历的是key值\n\n<p class=\"tip\">在进行遍历的时候不推荐使用`for...in`</p>\n\n## for...of\n``` javascript\nlet tempArry = [1, 2, 3, 4, 5];\nfor(let value of tempArry) {\n  console.log(value); // 依次输入 1,2,3,4,5\n}\n```\n> `for...of`语句遍历的是值，而不是下标，但`for...of`不支持循环对象。\n\n<p class=\"tip\">总结：通过上面几种遍历方法可以看出，原始`for`的循环的效率和性能最高，尤其是在数据越多的时候它的优势体现的越明显，其他的方法可以根据需求灵活的选择。</p>","slug":"javascript-traverse","published":1,"updated":"2019-04-10T08:15:01.346Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2mo4mxf0006dt47ep1xxctf","content":"<p>对于数组中的遍历也许再熟悉不过，感觉从最开始接触<code>C</code>语言的时候就遇到了遍历…下面就一起来说说<code>javascript</code>中的遍历方法，以及他们之间的性能比较。</p>\n<h2 id=\"for-循环语句\"><a href=\"#for-循环语句\" class=\"headerlink\" title=\"for 循环语句\"></a>for 循环语句</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> tempArry = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// for 循环语句</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; tempArry.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(tempArry[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>性能解读：这是我们最熟悉的一种遍历方式，也是最简单，使用频率最高的。他的性能虽然不弱，但是由于每次遍历都需要重新定义变量，因此还可以进行改进</p>\n</blockquote>\n<h4 id=\"for-循环语句-改进\"><a href=\"#for-循环语句-改进\" class=\"headerlink\" title=\"for 循环语句 改进\"></a>for 循环语句 改进</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> tempArry = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, len = tempArry.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(tempArry[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>减少了变量的定义，提高了遍历的性能，而且这种遍历方式性能最优。</p>\n</blockquote>\n<h2 id=\"forEach\"><a href=\"#forEach\" class=\"headerlink\" title=\"forEach\"></a>forEach</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> tempArry = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\">tempArry.forEach(<span class=\"function\">(<span class=\"params\">value, key, arry</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value); <span class=\"comment\">// 依次输出 1,2,3,4,5，</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key); <span class=\"comment\">// 依次输出 0,1,2,3,4</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arry); <span class=\"comment\">// 始终输出 [1,2,3,4,5]</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>forEach</code>方法是数组内置方法，他的好处在于不用重新定义一系列变量，便于使用，但是从效率以及性能角度来说它是劣于原始for循环,而且<code>forEach</code>不支持<code>return</code>。</p>\n</blockquote>\n<h2 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> tempArry = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> tempArryMap = tempArry.map(<span class=\"function\">(<span class=\"params\">value, key, arry</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arry);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(tempArry); <span class=\"comment\">// 结果为 [1, 2, 3, 4, 5]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(tempArryMap); <span class=\"comment\">// 结果为 [2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>map</code>也是数组的内置方法，写法与<code>forEach</code>没有什么不一样的，不同点在于<code>map</code>可以改变当前循环的值，而<code>forEach</code>则不可以。因此<code>map</code>一般用来处理需要修改某一个数组的值，在效率以及性能上也不如原始的<code>for</code>循环。</p>\n</blockquote>\n<h2 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> tempArry = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> tempArryFilter = tempArry.filter(<span class=\"function\">(<span class=\"params\">value, key, arry</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arry);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (value === <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(tempArry); <span class=\"comment\">// 结果为 [1, 2, 3, 4, 5]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(tempArryFilter); <span class=\"comment\">// 结果为 [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>filter</code>也是数组内置的方法，<code>filter</code>和<code>map</code>不同，<code>map</code>目的是为了改变值，而<code>filter</code>目的是为了去掉不要的值，在循环的时候如果返回的是<code>false</code>那么就表示本次循环的不添加该值，返回<code>true</code>则相反是表示要添加到新建的数组中</p>\n</blockquote>\n<h2 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce\"></a>reduce</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> tempArry = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> tempArryReduce = tempArry.reduce(<span class=\"function\">(<span class=\"params\">count, value,key,arry</span>)=&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(count);  <span class=\"comment\">// 依次为  0,1,3,6,10</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value);  <span class=\"comment\">// 依次为 1,2,3,4,5</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key);  <span class=\"comment\">// 0,1,2,3,4</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arry)  <span class=\"comment\">// 始终为 [1,2,3,4,5]</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> count + value;</span><br><span class=\"line\">&#125;,<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(tempArry); <span class=\"comment\">// 结果为 [1, 2, 3, 4, 5]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(tempArryReduce)  <span class=\"comment\">// 结果为 16</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>reduce</code>的不同之处在于累加，和其他几个内置方法不同的地方，它的第二个参数不是<code>this</code>对象，而是初始累加值（如果不设置的话数组会乱掉），而且回调函数的的个数也不同，比其他的多了一个，而且还在在开始的多加了一个参数，第一个参数记录的是上一次循环的累加值</p>\n</blockquote>\n<h2 id=\"some\"><a href=\"#some\" class=\"headerlink\" title=\"some\"></a>some</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> tempArry = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> tempArrySome = tempArry.some(<span class=\"function\">(<span class=\"params\">value,key,arry</span>)=&gt;</span> &#123;  </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value);  <span class=\"comment\">// 依次为 1,2,3 </span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key);   <span class=\"comment\">// 0,1,2</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arry) <span class=\"comment\">// 始终为[1, 2, 3, 4, 5]</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> value === <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(tempArry); <span class=\"comment\">// [1, 2, 3, 4, 5]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(tempArrySome)  <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>some</code>的不同之处在它返回的布尔值，它的作用有点像filter，不过它的目的不是为了筛选返回数组，而是为了筛选该数组是否有满足你要的值，而且找到符合条件的值返回了一次<code>true</code>之后就不会再继续执行了</p>\n</blockquote>\n<h2 id=\"every\"><a href=\"#every\" class=\"headerlink\" title=\"every\"></a>every</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// [...].every(ck)函数,某一个为false，则返回false,如果全部返回true，则返回true  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> tempArry = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> tempArryEvery = tempArry.every(<span class=\"function\">(<span class=\"params\">value,key,arry</span>)=&gt;</span> &#123;  </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value);  <span class=\"comment\">// 1</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key);   <span class=\"comment\">// 0</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arry) <span class=\"comment\">// 始终为[1, 2, 3, 4, 5]</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> value === <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(tempArry); <span class=\"comment\">// [1, 2, 3, 4, 5]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(tempArryEvery)  <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>每个数组元素都执行一次<code>ck</code>函数，直到某个元素执行函数<code>ck</code>返回<code>false</code>,如果返回<code>false</code>则直接返回<code>false</code>,如果全部返回<code>true</code>，则返回<code>true</code></p>\n</blockquote>\n<h2 id=\"indexOf\"><a href=\"#indexOf\" class=\"headerlink\" title=\"indexOf\"></a>indexOf</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> tempArry = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> tempArryIndexOf = tempArry.indexOf(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(tempArry); <span class=\"comment\">// [1, 2, 3, 4, 5]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(tempArryIndexOf)  <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>对于<code>indexOf</code>方法来说，在数组循环过程中会和传入的参数比对，如果是比对成功，那么终止循环，返回对比成功的下标。</p>\n</blockquote>\n<h2 id=\"lastIndexOf\"><a href=\"#lastIndexOf\" class=\"headerlink\" title=\"lastIndexOf\"></a>lastIndexOf</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> tempArry = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> tempArryLastIndexOf = tempArry.lastIndexOf(<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(tempArry); <span class=\"comment\">// [1,2,3,4,5,4,3,4,5]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(tempArryLastIndexOf)  <span class=\"comment\">// 8</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>lastIndexOf方法和indexOf作用一致，但查找方向不同，indexOf是正向查找，lastIndexOf是逆向查找，找到之后返回成功的下标</p>\n</blockquote>\n<p class=\"tip\">小结：对于以上8个数组的内置方法，forEach方法仅仅只是为了循环，并不可以帮你做额外的事情；map方法相当于在循环的时候你告诉数组当前遍历的这个值需要改成什么样，那么它就会最后给什么样的数组；filter方法相当于在循环的时候数组遍历一个个对象，并问你这个是不是你要找的值，如果你说是，他就会给你返回一个到新的数组中，不是他就会剔除；reduce方法相当于循环遍历对象做统计（累加或者累减之类的）;some和every方法相当于在遍历的时候拿着一个个对象问你这个是不是你找的，只要你说了一遍是，那么他就会给你分别返回的是true和false；indexOf和lastIndexOf方法相当于你告诉它你要找什么值，找到之后立马返回给你它的门牌号。</p>\n\n<h2 id=\"for…in\"><a href=\"#for…in\" class=\"headerlink\" title=\"for…in\"></a>for…in</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> tempArry = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> tempArry) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key); <span class=\"comment\">// 依次输出 0,1,2,3,4</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> tempArryIn = &#123;</span><br><span class=\"line\">  <span class=\"string\">'1'</span>: <span class=\"string\">'a'</span>,</span><br><span class=\"line\">  <span class=\"string\">'2'</span>: <span class=\"string\">'b'</span>,</span><br><span class=\"line\">  <span class=\"string\">'3'</span>: <span class=\"string\">'c'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> tempArryIn) &#123;</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(key); <span class=\"comment\">// 依次输出 1,2,3</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>从结果得知,for…in遍历数组的时候是遍历数组的下标值，而在遍历对象的时候遍历的是key值</p>\n</blockquote>\n<p class=\"tip\">在进行遍历的时候不推荐使用<code>for...in</code></p>\n\n<h2 id=\"for…of\"><a href=\"#for…of\" class=\"headerlink\" title=\"for…of\"></a>for…of</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> tempArry = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> value <span class=\"keyword\">of</span> tempArry) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value); <span class=\"comment\">// 依次输入 1,2,3,4,5</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>for...of</code>语句遍历的是值，而不是下标，但<code>for...of</code>不支持循环对象。</p>\n</blockquote>\n<p class=\"tip\">总结：通过上面几种遍历方法可以看出，原始<code>for</code>的循环的效率和性能最高，尤其是在数据越多的时候它的优势体现的越明显，其他的方法可以根据需求灵活的选择。</p>","site":{"data":{}},"excerpt":"","more":"<p>对于数组中的遍历也许再熟悉不过，感觉从最开始接触<code>C</code>语言的时候就遇到了遍历…下面就一起来说说<code>javascript</code>中的遍历方法，以及他们之间的性能比较。</p>\n<h2 id=\"for-循环语句\"><a href=\"#for-循环语句\" class=\"headerlink\" title=\"for 循环语句\"></a>for 循环语句</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> tempArry = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// for 循环语句</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; tempArry.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(tempArry[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>性能解读：这是我们最熟悉的一种遍历方式，也是最简单，使用频率最高的。他的性能虽然不弱，但是由于每次遍历都需要重新定义变量，因此还可以进行改进</p>\n</blockquote>\n<h4 id=\"for-循环语句-改进\"><a href=\"#for-循环语句-改进\" class=\"headerlink\" title=\"for 循环语句 改进\"></a>for 循环语句 改进</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> tempArry = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, len = tempArry.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(tempArry[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>减少了变量的定义，提高了遍历的性能，而且这种遍历方式性能最优。</p>\n</blockquote>\n<h2 id=\"forEach\"><a href=\"#forEach\" class=\"headerlink\" title=\"forEach\"></a>forEach</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> tempArry = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\">tempArry.forEach(<span class=\"function\">(<span class=\"params\">value, key, arry</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value); <span class=\"comment\">// 依次输出 1,2,3,4,5，</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key); <span class=\"comment\">// 依次输出 0,1,2,3,4</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arry); <span class=\"comment\">// 始终输出 [1,2,3,4,5]</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>forEach</code>方法是数组内置方法，他的好处在于不用重新定义一系列变量，便于使用，但是从效率以及性能角度来说它是劣于原始for循环,而且<code>forEach</code>不支持<code>return</code>。</p>\n</blockquote>\n<h2 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> tempArry = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> tempArryMap = tempArry.map(<span class=\"function\">(<span class=\"params\">value, key, arry</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arry);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(tempArry); <span class=\"comment\">// 结果为 [1, 2, 3, 4, 5]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(tempArryMap); <span class=\"comment\">// 结果为 [2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>map</code>也是数组的内置方法，写法与<code>forEach</code>没有什么不一样的，不同点在于<code>map</code>可以改变当前循环的值，而<code>forEach</code>则不可以。因此<code>map</code>一般用来处理需要修改某一个数组的值，在效率以及性能上也不如原始的<code>for</code>循环。</p>\n</blockquote>\n<h2 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> tempArry = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> tempArryFilter = tempArry.filter(<span class=\"function\">(<span class=\"params\">value, key, arry</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arry);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (value === <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(tempArry); <span class=\"comment\">// 结果为 [1, 2, 3, 4, 5]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(tempArryFilter); <span class=\"comment\">// 结果为 [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>filter</code>也是数组内置的方法，<code>filter</code>和<code>map</code>不同，<code>map</code>目的是为了改变值，而<code>filter</code>目的是为了去掉不要的值，在循环的时候如果返回的是<code>false</code>那么就表示本次循环的不添加该值，返回<code>true</code>则相反是表示要添加到新建的数组中</p>\n</blockquote>\n<h2 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce\"></a>reduce</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> tempArry = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> tempArryReduce = tempArry.reduce(<span class=\"function\">(<span class=\"params\">count, value,key,arry</span>)=&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(count);  <span class=\"comment\">// 依次为  0,1,3,6,10</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value);  <span class=\"comment\">// 依次为 1,2,3,4,5</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key);  <span class=\"comment\">// 0,1,2,3,4</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arry)  <span class=\"comment\">// 始终为 [1,2,3,4,5]</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> count + value;</span><br><span class=\"line\">&#125;,<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(tempArry); <span class=\"comment\">// 结果为 [1, 2, 3, 4, 5]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(tempArryReduce)  <span class=\"comment\">// 结果为 16</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>reduce</code>的不同之处在于累加，和其他几个内置方法不同的地方，它的第二个参数不是<code>this</code>对象，而是初始累加值（如果不设置的话数组会乱掉），而且回调函数的的个数也不同，比其他的多了一个，而且还在在开始的多加了一个参数，第一个参数记录的是上一次循环的累加值</p>\n</blockquote>\n<h2 id=\"some\"><a href=\"#some\" class=\"headerlink\" title=\"some\"></a>some</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> tempArry = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> tempArrySome = tempArry.some(<span class=\"function\">(<span class=\"params\">value,key,arry</span>)=&gt;</span> &#123;  </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value);  <span class=\"comment\">// 依次为 1,2,3 </span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key);   <span class=\"comment\">// 0,1,2</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arry) <span class=\"comment\">// 始终为[1, 2, 3, 4, 5]</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> value === <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(tempArry); <span class=\"comment\">// [1, 2, 3, 4, 5]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(tempArrySome)  <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>some</code>的不同之处在它返回的布尔值，它的作用有点像filter，不过它的目的不是为了筛选返回数组，而是为了筛选该数组是否有满足你要的值，而且找到符合条件的值返回了一次<code>true</code>之后就不会再继续执行了</p>\n</blockquote>\n<h2 id=\"every\"><a href=\"#every\" class=\"headerlink\" title=\"every\"></a>every</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// [...].every(ck)函数,某一个为false，则返回false,如果全部返回true，则返回true  </span></span><br><span class=\"line\"><span class=\"keyword\">let</span> tempArry = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> tempArryEvery = tempArry.every(<span class=\"function\">(<span class=\"params\">value,key,arry</span>)=&gt;</span> &#123;  </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value);  <span class=\"comment\">// 1</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key);   <span class=\"comment\">// 0</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arry) <span class=\"comment\">// 始终为[1, 2, 3, 4, 5]</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> value === <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(tempArry); <span class=\"comment\">// [1, 2, 3, 4, 5]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(tempArryEvery)  <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>每个数组元素都执行一次<code>ck</code>函数，直到某个元素执行函数<code>ck</code>返回<code>false</code>,如果返回<code>false</code>则直接返回<code>false</code>,如果全部返回<code>true</code>，则返回<code>true</code></p>\n</blockquote>\n<h2 id=\"indexOf\"><a href=\"#indexOf\" class=\"headerlink\" title=\"indexOf\"></a>indexOf</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> tempArry = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> tempArryIndexOf = tempArry.indexOf(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(tempArry); <span class=\"comment\">// [1, 2, 3, 4, 5]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(tempArryIndexOf)  <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>对于<code>indexOf</code>方法来说，在数组循环过程中会和传入的参数比对，如果是比对成功，那么终止循环，返回对比成功的下标。</p>\n</blockquote>\n<h2 id=\"lastIndexOf\"><a href=\"#lastIndexOf\" class=\"headerlink\" title=\"lastIndexOf\"></a>lastIndexOf</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> tempArry = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> tempArryLastIndexOf = tempArry.lastIndexOf(<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(tempArry); <span class=\"comment\">// [1,2,3,4,5,4,3,4,5]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(tempArryLastIndexOf)  <span class=\"comment\">// 8</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>lastIndexOf方法和indexOf作用一致，但查找方向不同，indexOf是正向查找，lastIndexOf是逆向查找，找到之后返回成功的下标</p>\n</blockquote>\n<p class=\"tip\">小结：对于以上8个数组的内置方法，forEach方法仅仅只是为了循环，并不可以帮你做额外的事情；map方法相当于在循环的时候你告诉数组当前遍历的这个值需要改成什么样，那么它就会最后给什么样的数组；filter方法相当于在循环的时候数组遍历一个个对象，并问你这个是不是你要找的值，如果你说是，他就会给你返回一个到新的数组中，不是他就会剔除；reduce方法相当于循环遍历对象做统计（累加或者累减之类的）;some和every方法相当于在遍历的时候拿着一个个对象问你这个是不是你找的，只要你说了一遍是，那么他就会给你分别返回的是true和false；indexOf和lastIndexOf方法相当于你告诉它你要找什么值，找到之后立马返回给你它的门牌号。</p>\n\n<h2 id=\"for…in\"><a href=\"#for…in\" class=\"headerlink\" title=\"for…in\"></a>for…in</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> tempArry = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> tempArry) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key); <span class=\"comment\">// 依次输出 0,1,2,3,4</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> tempArryIn = &#123;</span><br><span class=\"line\">  <span class=\"string\">'1'</span>: <span class=\"string\">'a'</span>,</span><br><span class=\"line\">  <span class=\"string\">'2'</span>: <span class=\"string\">'b'</span>,</span><br><span class=\"line\">  <span class=\"string\">'3'</span>: <span class=\"string\">'c'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> tempArryIn) &#123;</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(key); <span class=\"comment\">// 依次输出 1,2,3</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>从结果得知,for…in遍历数组的时候是遍历数组的下标值，而在遍历对象的时候遍历的是key值</p>\n</blockquote>\n<p class=\"tip\">在进行遍历的时候不推荐使用<code>for...in</code></p>\n\n<h2 id=\"for…of\"><a href=\"#for…of\" class=\"headerlink\" title=\"for…of\"></a>for…of</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> tempArry = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> value <span class=\"keyword\">of</span> tempArry) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value); <span class=\"comment\">// 依次输入 1,2,3,4,5</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>for...of</code>语句遍历的是值，而不是下标，但<code>for...of</code>不支持循环对象。</p>\n</blockquote>\n<p class=\"tip\">总结：通过上面几种遍历方法可以看出，原始<code>for</code>的循环的效率和性能最高，尤其是在数据越多的时候它的优势体现的越明显，其他的方法可以根据需求灵活的选择。</p>"},{"title":"提前支付自己","date":"2018-03-19T16:01:30.000Z","summary":"提前支付自己","_content":"\n记得《穷爸爸富爸爸》书中提到提前支付自己的重要性。即通常大多数人在工资发下来之后，先还信用卡、还房贷车贷、还各种欠债，如果能有剩余的钱才会最后想到自己，而不是先支付自己即预留给自己强制储蓄或投资的钱，利用提前支付自己来形成定期积累财富同时挖掘自己去赚更多钱的能力。挺有哲学的。\n\n其实，我觉得在工作中也应该要有这样的思维，比如每天早上一开始，那时精力最好效率最高，可以抽一部分时间用来投资自己，用于英语学习、阅读书籍和知识、学习工作中需要用到的技术，而不是为了完成任务，匆匆的开始立马投入工作，等到下午或晚上工作完成差不多，但精力已消耗得差不多了，也无心开始自己的个人学习而忽略了最最重要的事；同时也避免很早开始工作，觉得时间还充足，就肆无忌惮产生一些时间的浪费。当然这个时间的安排也要相对合适，不能占用工作太多时间，免得真的将工作时间压缩太多，影响工作进度，导致晚上又要加班到很晚，造成心理和身体上的负担。\n\n应对措施：每天适当早一点来公司，那个时间相对打扰较少，是属于自己可以完整支配的时间，关掉手机、关掉电脑一切通讯工具，专心学习45分钟左右，完成自己微习惯中定义的一些目标。将最重要的事情完成了，接下来的一整天都会变得轻松容易。","source":"_posts/pay-yourself-first.md","raw":"---\ntitle: 提前支付自己\ndate: 2018-03-20 00:01:30\ntags: [feelings,生活]\nsummary: 提前支付自己\n---\n\n记得《穷爸爸富爸爸》书中提到提前支付自己的重要性。即通常大多数人在工资发下来之后，先还信用卡、还房贷车贷、还各种欠债，如果能有剩余的钱才会最后想到自己，而不是先支付自己即预留给自己强制储蓄或投资的钱，利用提前支付自己来形成定期积累财富同时挖掘自己去赚更多钱的能力。挺有哲学的。\n\n其实，我觉得在工作中也应该要有这样的思维，比如每天早上一开始，那时精力最好效率最高，可以抽一部分时间用来投资自己，用于英语学习、阅读书籍和知识、学习工作中需要用到的技术，而不是为了完成任务，匆匆的开始立马投入工作，等到下午或晚上工作完成差不多，但精力已消耗得差不多了，也无心开始自己的个人学习而忽略了最最重要的事；同时也避免很早开始工作，觉得时间还充足，就肆无忌惮产生一些时间的浪费。当然这个时间的安排也要相对合适，不能占用工作太多时间，免得真的将工作时间压缩太多，影响工作进度，导致晚上又要加班到很晚，造成心理和身体上的负担。\n\n应对措施：每天适当早一点来公司，那个时间相对打扰较少，是属于自己可以完整支配的时间，关掉手机、关掉电脑一切通讯工具，专心学习45分钟左右，完成自己微习惯中定义的一些目标。将最重要的事情完成了，接下来的一整天都会变得轻松容易。","slug":"pay-yourself-first","published":1,"updated":"2019-04-11T01:46:19.607Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2mo4mxh0008dt47cniwcjhx","content":"<p>记得《穷爸爸富爸爸》书中提到提前支付自己的重要性。即通常大多数人在工资发下来之后，先还信用卡、还房贷车贷、还各种欠债，如果能有剩余的钱才会最后想到自己，而不是先支付自己即预留给自己强制储蓄或投资的钱，利用提前支付自己来形成定期积累财富同时挖掘自己去赚更多钱的能力。挺有哲学的。</p>\n<p>其实，我觉得在工作中也应该要有这样的思维，比如每天早上一开始，那时精力最好效率最高，可以抽一部分时间用来投资自己，用于英语学习、阅读书籍和知识、学习工作中需要用到的技术，而不是为了完成任务，匆匆的开始立马投入工作，等到下午或晚上工作完成差不多，但精力已消耗得差不多了，也无心开始自己的个人学习而忽略了最最重要的事；同时也避免很早开始工作，觉得时间还充足，就肆无忌惮产生一些时间的浪费。当然这个时间的安排也要相对合适，不能占用工作太多时间，免得真的将工作时间压缩太多，影响工作进度，导致晚上又要加班到很晚，造成心理和身体上的负担。</p>\n<p>应对措施：每天适当早一点来公司，那个时间相对打扰较少，是属于自己可以完整支配的时间，关掉手机、关掉电脑一切通讯工具，专心学习45分钟左右，完成自己微习惯中定义的一些目标。将最重要的事情完成了，接下来的一整天都会变得轻松容易。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>记得《穷爸爸富爸爸》书中提到提前支付自己的重要性。即通常大多数人在工资发下来之后，先还信用卡、还房贷车贷、还各种欠债，如果能有剩余的钱才会最后想到自己，而不是先支付自己即预留给自己强制储蓄或投资的钱，利用提前支付自己来形成定期积累财富同时挖掘自己去赚更多钱的能力。挺有哲学的。</p>\n<p>其实，我觉得在工作中也应该要有这样的思维，比如每天早上一开始，那时精力最好效率最高，可以抽一部分时间用来投资自己，用于英语学习、阅读书籍和知识、学习工作中需要用到的技术，而不是为了完成任务，匆匆的开始立马投入工作，等到下午或晚上工作完成差不多，但精力已消耗得差不多了，也无心开始自己的个人学习而忽略了最最重要的事；同时也避免很早开始工作，觉得时间还充足，就肆无忌惮产生一些时间的浪费。当然这个时间的安排也要相对合适，不能占用工作太多时间，免得真的将工作时间压缩太多，影响工作进度，导致晚上又要加班到很晚，造成心理和身体上的负担。</p>\n<p>应对措施：每天适当早一点来公司，那个时间相对打扰较少，是属于自己可以完整支配的时间，关掉手机、关掉电脑一切通讯工具，专心学习45分钟左右，完成自己微习惯中定义的一些目标。将最重要的事情完成了，接下来的一整天都会变得轻松容易。</p>\n"},{"title":"前端API速查","date":"2019-04-11T01:40:36.000Z","summary":"在前端开发中，想要记住所有的api是一件不可能也没必要的事情，借助工具，借助前人的整理，你可以把精力放在更重要的事情上。以下是前端er日常开发中常用的cheatsheets","_content":"\n## [awesome cheatsheets collection](https://lecoupa.github.io/awesome-cheatsheets/)\nAwesome cheatsheets for popular programming languages, frameworks and development tools.\n They include everything you should know in one single file\n\n## [Rico's cheatsheets collection](https://devhints.io/) \n\n## [注释规范](https://devhints.io/jsdoc)\n![注释规范](https://ws1.sinaimg.cn/large/006tNc79gy1g1ygyiw8c1j31hj0u0qas.jpg)\n\n## [es2015 新特性](https://devhints.io/es6)\n![es2015](https://www.strilliant.com/images/1*l90SMm_aR9UD8m9QDu3kKA.png)\n\n## [Javascript](http://overapi.com/javascript)\n![javascript](https://www.strilliant.com/images/1*sqkshvsmr7hN4Ab2A7GJzg.png)\n\n## [js正则表达式](https://www.debuggex.com/cheatsheet/regex/javascript)\n![正则表达式](https://www.strilliant.com/images/1*jHRyyzwj9z11ouDkY9dK9Q.png)\n\n## [vue](https://vuejs-tips.github.io/cheatsheet/)\n![vuejs](https://www.strilliant.com/images/1*xKmyDitGEXGg1J9FBpbqHw.png)\n\n## [vuex](https://vuejs-tips.github.io/vuex-cheatsheet/)\n![vuex](https://www.strilliant.com/images/1*M-UIS7PPmvh_HuZVTqarzA.png)\n\n## [react](https://devhints.io/react)\n![react](https://www.strilliant.com/images/1*VhtpckI6V0tckQa3uM9MbA.png)\n\n## [redux](https://github.com/linkmesrl/react-journey-2016/blob/master/resources/egghead-redux-cheat-sheet-3-2-1.pdf)\n\n![redux](https://www.strilliant.com/images/1*KJQ-XK2yK-903OXHCRQpLw.png)\n\n## [Flexbox](https://yoksel.github.io/flex-cheatsheet/)\n![Flexbox](https://www.strilliant.com/images/1*q8xJa81twW6J-U_URHOJvQ.png)\n\n## [markdown](https://devhints.io/markdown)\n![markdown](https://ws2.sinaimg.cn/large/006tNc79gy1g1yg5r0wvnj31ny0u0afl.jpg)\n","source":"_posts/the-best-front-end-hacking-cheatsheets.md","raw":"---\ntitle: 前端API速查\ndate: 2019-04-11 09:40:36\ntags: [API,备忘单,sheet]\nsummary: 在前端开发中，想要记住所有的api是一件不可能也没必要的事情，借助工具，借助前人的整理，你可以把精力放在更重要的事情上。以下是前端er日常开发中常用的cheatsheets\n\n---\n\n## [awesome cheatsheets collection](https://lecoupa.github.io/awesome-cheatsheets/)\nAwesome cheatsheets for popular programming languages, frameworks and development tools.\n They include everything you should know in one single file\n\n## [Rico's cheatsheets collection](https://devhints.io/) \n\n## [注释规范](https://devhints.io/jsdoc)\n![注释规范](https://ws1.sinaimg.cn/large/006tNc79gy1g1ygyiw8c1j31hj0u0qas.jpg)\n\n## [es2015 新特性](https://devhints.io/es6)\n![es2015](https://www.strilliant.com/images/1*l90SMm_aR9UD8m9QDu3kKA.png)\n\n## [Javascript](http://overapi.com/javascript)\n![javascript](https://www.strilliant.com/images/1*sqkshvsmr7hN4Ab2A7GJzg.png)\n\n## [js正则表达式](https://www.debuggex.com/cheatsheet/regex/javascript)\n![正则表达式](https://www.strilliant.com/images/1*jHRyyzwj9z11ouDkY9dK9Q.png)\n\n## [vue](https://vuejs-tips.github.io/cheatsheet/)\n![vuejs](https://www.strilliant.com/images/1*xKmyDitGEXGg1J9FBpbqHw.png)\n\n## [vuex](https://vuejs-tips.github.io/vuex-cheatsheet/)\n![vuex](https://www.strilliant.com/images/1*M-UIS7PPmvh_HuZVTqarzA.png)\n\n## [react](https://devhints.io/react)\n![react](https://www.strilliant.com/images/1*VhtpckI6V0tckQa3uM9MbA.png)\n\n## [redux](https://github.com/linkmesrl/react-journey-2016/blob/master/resources/egghead-redux-cheat-sheet-3-2-1.pdf)\n\n![redux](https://www.strilliant.com/images/1*KJQ-XK2yK-903OXHCRQpLw.png)\n\n## [Flexbox](https://yoksel.github.io/flex-cheatsheet/)\n![Flexbox](https://www.strilliant.com/images/1*q8xJa81twW6J-U_URHOJvQ.png)\n\n## [markdown](https://devhints.io/markdown)\n![markdown](https://ws2.sinaimg.cn/large/006tNc79gy1g1yg5r0wvnj31ny0u0afl.jpg)\n","slug":"the-best-front-end-hacking-cheatsheets","published":1,"updated":"2019-06-11T07:23:30.605Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2mo4mxi000adt47plfrassl","content":"<h2 id=\"awesome-cheatsheets-collection\"><a href=\"#awesome-cheatsheets-collection\" class=\"headerlink\" title=\"awesome cheatsheets collection\"></a><a href=\"https://lecoupa.github.io/awesome-cheatsheets/\" target=\"_blank\" rel=\"noopener\">awesome cheatsheets collection</a></h2><p>Awesome cheatsheets for popular programming languages, frameworks and development tools.<br> They include everything you should know in one single file</p>\n<h2 id=\"Rico’s-cheatsheets-collection\"><a href=\"#Rico’s-cheatsheets-collection\" class=\"headerlink\" title=\"Rico’s cheatsheets collection\"></a><a href=\"https://devhints.io/\" target=\"_blank\" rel=\"noopener\">Rico’s cheatsheets collection</a></h2><h2 id=\"注释规范\"><a href=\"#注释规范\" class=\"headerlink\" title=\"注释规范\"></a><a href=\"https://devhints.io/jsdoc\" target=\"_blank\" rel=\"noopener\">注释规范</a></h2><p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1g1ygyiw8c1j31hj0u0qas.jpg\" alt=\"注释规范\"></p>\n<h2 id=\"es2015-新特性\"><a href=\"#es2015-新特性\" class=\"headerlink\" title=\"es2015 新特性\"></a><a href=\"https://devhints.io/es6\" target=\"_blank\" rel=\"noopener\">es2015 新特性</a></h2><p><img src=\"https://www.strilliant.com/images/1*l90SMm_aR9UD8m9QDu3kKA.png\" alt=\"es2015\"></p>\n<h2 id=\"Javascript\"><a href=\"#Javascript\" class=\"headerlink\" title=\"Javascript\"></a><a href=\"http://overapi.com/javascript\" target=\"_blank\" rel=\"noopener\">Javascript</a></h2><p><img src=\"https://www.strilliant.com/images/1*sqkshvsmr7hN4Ab2A7GJzg.png\" alt=\"javascript\"></p>\n<h2 id=\"js正则表达式\"><a href=\"#js正则表达式\" class=\"headerlink\" title=\"js正则表达式\"></a><a href=\"https://www.debuggex.com/cheatsheet/regex/javascript\" target=\"_blank\" rel=\"noopener\">js正则表达式</a></h2><p><img src=\"https://www.strilliant.com/images/1*jHRyyzwj9z11ouDkY9dK9Q.png\" alt=\"正则表达式\"></p>\n<h2 id=\"vue\"><a href=\"#vue\" class=\"headerlink\" title=\"vue\"></a><a href=\"https://vuejs-tips.github.io/cheatsheet/\" target=\"_blank\" rel=\"noopener\">vue</a></h2><p><img src=\"https://www.strilliant.com/images/1*xKmyDitGEXGg1J9FBpbqHw.png\" alt=\"vuejs\"></p>\n<h2 id=\"vuex\"><a href=\"#vuex\" class=\"headerlink\" title=\"vuex\"></a><a href=\"https://vuejs-tips.github.io/vuex-cheatsheet/\" target=\"_blank\" rel=\"noopener\">vuex</a></h2><p><img src=\"https://www.strilliant.com/images/1*M-UIS7PPmvh_HuZVTqarzA.png\" alt=\"vuex\"></p>\n<h2 id=\"react\"><a href=\"#react\" class=\"headerlink\" title=\"react\"></a><a href=\"https://devhints.io/react\" target=\"_blank\" rel=\"noopener\">react</a></h2><p><img src=\"https://www.strilliant.com/images/1*VhtpckI6V0tckQa3uM9MbA.png\" alt=\"react\"></p>\n<h2 id=\"redux\"><a href=\"#redux\" class=\"headerlink\" title=\"redux\"></a><a href=\"https://github.com/linkmesrl/react-journey-2016/blob/master/resources/egghead-redux-cheat-sheet-3-2-1.pdf\" target=\"_blank\" rel=\"noopener\">redux</a></h2><p><img src=\"https://www.strilliant.com/images/1*KJQ-XK2yK-903OXHCRQpLw.png\" alt=\"redux\"></p>\n<h2 id=\"Flexbox\"><a href=\"#Flexbox\" class=\"headerlink\" title=\"Flexbox\"></a><a href=\"https://yoksel.github.io/flex-cheatsheet/\" target=\"_blank\" rel=\"noopener\">Flexbox</a></h2><p><img src=\"https://www.strilliant.com/images/1*q8xJa81twW6J-U_URHOJvQ.png\" alt=\"Flexbox\"></p>\n<h2 id=\"markdown\"><a href=\"#markdown\" class=\"headerlink\" title=\"markdown\"></a><a href=\"https://devhints.io/markdown\" target=\"_blank\" rel=\"noopener\">markdown</a></h2><p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1g1yg5r0wvnj31ny0u0afl.jpg\" alt=\"markdown\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"awesome-cheatsheets-collection\"><a href=\"#awesome-cheatsheets-collection\" class=\"headerlink\" title=\"awesome cheatsheets collection\"></a><a href=\"https://lecoupa.github.io/awesome-cheatsheets/\" target=\"_blank\" rel=\"noopener\">awesome cheatsheets collection</a></h2><p>Awesome cheatsheets for popular programming languages, frameworks and development tools.<br> They include everything you should know in one single file</p>\n<h2 id=\"Rico’s-cheatsheets-collection\"><a href=\"#Rico’s-cheatsheets-collection\" class=\"headerlink\" title=\"Rico’s cheatsheets collection\"></a><a href=\"https://devhints.io/\" target=\"_blank\" rel=\"noopener\">Rico’s cheatsheets collection</a></h2><h2 id=\"注释规范\"><a href=\"#注释规范\" class=\"headerlink\" title=\"注释规范\"></a><a href=\"https://devhints.io/jsdoc\" target=\"_blank\" rel=\"noopener\">注释规范</a></h2><p><img src=\"https://ws1.sinaimg.cn/large/006tNc79gy1g1ygyiw8c1j31hj0u0qas.jpg\" alt=\"注释规范\"></p>\n<h2 id=\"es2015-新特性\"><a href=\"#es2015-新特性\" class=\"headerlink\" title=\"es2015 新特性\"></a><a href=\"https://devhints.io/es6\" target=\"_blank\" rel=\"noopener\">es2015 新特性</a></h2><p><img src=\"https://www.strilliant.com/images/1*l90SMm_aR9UD8m9QDu3kKA.png\" alt=\"es2015\"></p>\n<h2 id=\"Javascript\"><a href=\"#Javascript\" class=\"headerlink\" title=\"Javascript\"></a><a href=\"http://overapi.com/javascript\" target=\"_blank\" rel=\"noopener\">Javascript</a></h2><p><img src=\"https://www.strilliant.com/images/1*sqkshvsmr7hN4Ab2A7GJzg.png\" alt=\"javascript\"></p>\n<h2 id=\"js正则表达式\"><a href=\"#js正则表达式\" class=\"headerlink\" title=\"js正则表达式\"></a><a href=\"https://www.debuggex.com/cheatsheet/regex/javascript\" target=\"_blank\" rel=\"noopener\">js正则表达式</a></h2><p><img src=\"https://www.strilliant.com/images/1*jHRyyzwj9z11ouDkY9dK9Q.png\" alt=\"正则表达式\"></p>\n<h2 id=\"vue\"><a href=\"#vue\" class=\"headerlink\" title=\"vue\"></a><a href=\"https://vuejs-tips.github.io/cheatsheet/\" target=\"_blank\" rel=\"noopener\">vue</a></h2><p><img src=\"https://www.strilliant.com/images/1*xKmyDitGEXGg1J9FBpbqHw.png\" alt=\"vuejs\"></p>\n<h2 id=\"vuex\"><a href=\"#vuex\" class=\"headerlink\" title=\"vuex\"></a><a href=\"https://vuejs-tips.github.io/vuex-cheatsheet/\" target=\"_blank\" rel=\"noopener\">vuex</a></h2><p><img src=\"https://www.strilliant.com/images/1*M-UIS7PPmvh_HuZVTqarzA.png\" alt=\"vuex\"></p>\n<h2 id=\"react\"><a href=\"#react\" class=\"headerlink\" title=\"react\"></a><a href=\"https://devhints.io/react\" target=\"_blank\" rel=\"noopener\">react</a></h2><p><img src=\"https://www.strilliant.com/images/1*VhtpckI6V0tckQa3uM9MbA.png\" alt=\"react\"></p>\n<h2 id=\"redux\"><a href=\"#redux\" class=\"headerlink\" title=\"redux\"></a><a href=\"https://github.com/linkmesrl/react-journey-2016/blob/master/resources/egghead-redux-cheat-sheet-3-2-1.pdf\" target=\"_blank\" rel=\"noopener\">redux</a></h2><p><img src=\"https://www.strilliant.com/images/1*KJQ-XK2yK-903OXHCRQpLw.png\" alt=\"redux\"></p>\n<h2 id=\"Flexbox\"><a href=\"#Flexbox\" class=\"headerlink\" title=\"Flexbox\"></a><a href=\"https://yoksel.github.io/flex-cheatsheet/\" target=\"_blank\" rel=\"noopener\">Flexbox</a></h2><p><img src=\"https://www.strilliant.com/images/1*q8xJa81twW6J-U_URHOJvQ.png\" alt=\"Flexbox\"></p>\n<h2 id=\"markdown\"><a href=\"#markdown\" class=\"headerlink\" title=\"markdown\"></a><a href=\"https://devhints.io/markdown\" target=\"_blank\" rel=\"noopener\">markdown</a></h2><p><img src=\"https://ws2.sinaimg.cn/large/006tNc79gy1g1yg5r0wvnj31ny0u0afl.jpg\" alt=\"markdown\"></p>\n"},{"title":"vue 组件间通信","date":"2018-02-08T02:04:27.000Z","summary":"最近在学习vue方面的的知识，毫无疑问，对于vue来说，组件化是其一个很大的特点，一方面可以提高代码的可读性，另一方面可以少写很多的代码，利于代码的维护。对于组件之间数据通信是一个必须要掌握的知识点，通信之间的方式一共可以分为三种，父组件与子组件，子组件与父组件，同级组件间通信。","_content":"最近在学习vue方面的的知识，毫无疑问，对于vue来说，组件化是其一个很大的特点，一方面可以提高代码的可读性，另一方面可以少写很多的代码，利于代码的维护。对于组件之间数据通信是一个必须要掌握的知识点，通信之间的方式一共可以分为三种，父组件与子组件，子组件与父组件，同级组件间通信。\n### 父组件与子组件\n在vue中，父子组件的关系可以总结为 prop 向下传递，事件向上传递。父组件通过 prop 给子组件下发数据，子组件通过事件给父组件发送消息。\n<img src=\"/blog/img/vue-components-bus-01.png\">\n父组件\n``` vue\n<template> \n     <div class=\"components-bus-container\">\n        <children-one :fatherDataOne=\"fatherDataOne\"></children-one>\n     </div> \n</template>\n\n<script>\nexport default {\n    data() {\n        return {\n            fatherDataOne: '',\n        };\n    },\n}\n</script>\n```\n子组件\n``` vue\n<template>\n    <div class=\"children-one-content\">\n        <div>{{fatherDataOne}}</div>\n    </div>\n</template>\n\n<script>\nexport default {\n    data() {\n    },\n    props: ['fatherDataOne']\n}\n</script>\n```\n<p class='tip'>`:fatherDataOne`为数据绑定写法，可以灵活的进行数据设置，如果直接绑定数据，写成`fatherDataOne=\"someData\"`即可</p>\n### 子组件与父组件通信\n对于子组件将数据传给父组件，是通过`$emit`事件来实现的，在图中也可以体现，具体实现如下：\n子组件\n``` vue\n<template>\n    <div class=\"children-one-content\">\n        <div>{{fatherDataOne}}</div>\n        <div @click=\"tellParent\">点击传递数据</div>\n    </div>\n</template>\n\n<script>\nexport default {\n    data() {\n    },\n    props: ['fatherDataOne']，\n    methods: {\n        tellParent() {\n          this.$emit('listenOne', 'from childrenOne');\n        }\n    }\n}\n</script>\n```\n父组件\n``` vue\n<template> \n     <div class=\"components-bus-container\">\n        <children-one :fatherDataOne=\"fatherDataOne\" @listenOne='getCompomentOne'></children-one>\n     </div> \n</template>\n\n<script>\nexport default {\n  data() {\n      return {\n          fatherDataOne: '',\n      };\n  },\n  methods: {\n    getCompomentOne(param) {\n      console.log(param);\n    }\n  }\n}\n</script>\n```\n在父组件中绑定一个`listenOne`的事件，然后给这个事件添加`getCompomentOne`方法，当子组件children-one通过点击事件`tellParent`触发`listenOne`的时候，父组件里面的`getCompomentOne`方法就会执行，并且数据通过参数的形式传递给父组件，从而实现通信的功能。\n\n### 同级组件间通信\n对于同级间组件进行通信处理的方法是，新建一个Vue实例作为事件总线，具体实现如下：\n1.需要进行通信的同级组件引入`event.js`\n``` javascript\n\timport Vue from 'vue'; \n\tlet bus = new Vue(); \n\texport default bus; \n```\n2.组件`children-one`通过点击事件`sendMsgToTwo`触发`dataFromOne`\nchildren-one\n``` vue\n<template>\n    <div class=\"children-one-content\">\n        <div>{{fatherDataOne}}</div>\n        <div @click=\"tellParent\">点击向父组件通信</div>\n        <div @click=\"tellChildTwo\">点击向子组件2通信</div>\n    </div>\n</template>\n\n<script>\nimport bus from 'path/event'\nexport default {\n  data() {\n  },\n  props: ['fatherDataOne']，\n  methods: {\n    tellParent() {\n      this.$emit('listenOne', 'from childrenOne');\n    },\n    tellChildTwo() {\n      bus.$emit('dataFromOne', 'dataFromOne');\n    }\n  }\n}\n</script>\n```\n3.组件`children-two`中监听事件 `dataFromOne`\nchildren-two\n``` vue\n<template>\n    <div class=\"children-two-content\">\n    </div>\n</template>\n\n<script>\nimport bus from 'path/event'\nexport default {\n  data() {\n  },\n  methods: {\n    getMsgFromOne() {\n      bus.$on('dataFromOne', data => {\n        console.log(data);\n      });\n    }\n  },\n  mounted() {\n    this.getMsgFromOne();\n  }\n}\n</script>\n```\n当`children-one`触发`dataFromOne`时，组件`children-two`中的监听事件`dataFromOne`就会被触发，数据通过参数的形式传入，从而实现同级组件间通信。\n\n### 扩展\n##### 1.父组件操作子组件的方法\n利用$refs实现这个功能\n父组件\n``` vue\n<children-one :fatherDataOne=\"fatherDataOne\" @listenOne='getCompomentOne' ref=\"childrenOne\"></children-one>\n```\n那么就可以通过`this.$refs.childrenOne.childenFunction()`来操作子组件中的方法。\n##### 2.父组件将数据传给子组件，出现`undefined`情况\n当父组件传递的数据是异步取值的时候，可能出现首先传过去是空值，然后异步刷新。对于这种情况处理的方法是`v-if`，当父组件拿到数据后，将其设置为true，从而避免undefined的情况。\n \n### 高级用法\n对于一些简单的组件间的通信个人觉得这些方式够用了，如果一个页面涉及到很多的组件，那么也许这种方法不是那么简洁了，这是就需要用到`vue`中很重要的一个插件了`vuex`,以下为官网对`vuex`的介绍：\n[vuex](https://vuex.vuejs.org/)是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 [devtools extension](https://github.com/vuejs/vue-devtools)，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。\n如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的 global event bus 就足够您所需了。但是，如果您需要构建是一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。引用 Redux 的作者 Dan Abramov 的话说就是：\n\n> Flux 架构就像眼镜：您自会知道什么时候需要它。\n\n本文简单介绍了`vue`组件间的通信方式，如有错误，还望指出，大家一起交流学习。\n\n\n\n","source":"_posts/vue-component-communication.md","raw":"---\ntitle: vue 组件间通信\ndate: 2018-02-08 10:04:27\ntags: vue\nsummary: 最近在学习vue方面的的知识，毫无疑问，对于vue来说，组件化是其一个很大的特点，一方面可以提高代码的可读性，另一方面可以少写很多的代码，利于代码的维护。对于组件之间数据通信是一个必须要掌握的知识点，通信之间的方式一共可以分为三种，父组件与子组件，子组件与父组件，同级组件间通信。\n---\n最近在学习vue方面的的知识，毫无疑问，对于vue来说，组件化是其一个很大的特点，一方面可以提高代码的可读性，另一方面可以少写很多的代码，利于代码的维护。对于组件之间数据通信是一个必须要掌握的知识点，通信之间的方式一共可以分为三种，父组件与子组件，子组件与父组件，同级组件间通信。\n### 父组件与子组件\n在vue中，父子组件的关系可以总结为 prop 向下传递，事件向上传递。父组件通过 prop 给子组件下发数据，子组件通过事件给父组件发送消息。\n<img src=\"/blog/img/vue-components-bus-01.png\">\n父组件\n``` vue\n<template> \n     <div class=\"components-bus-container\">\n        <children-one :fatherDataOne=\"fatherDataOne\"></children-one>\n     </div> \n</template>\n\n<script>\nexport default {\n    data() {\n        return {\n            fatherDataOne: '',\n        };\n    },\n}\n</script>\n```\n子组件\n``` vue\n<template>\n    <div class=\"children-one-content\">\n        <div>{{fatherDataOne}}</div>\n    </div>\n</template>\n\n<script>\nexport default {\n    data() {\n    },\n    props: ['fatherDataOne']\n}\n</script>\n```\n<p class='tip'>`:fatherDataOne`为数据绑定写法，可以灵活的进行数据设置，如果直接绑定数据，写成`fatherDataOne=\"someData\"`即可</p>\n### 子组件与父组件通信\n对于子组件将数据传给父组件，是通过`$emit`事件来实现的，在图中也可以体现，具体实现如下：\n子组件\n``` vue\n<template>\n    <div class=\"children-one-content\">\n        <div>{{fatherDataOne}}</div>\n        <div @click=\"tellParent\">点击传递数据</div>\n    </div>\n</template>\n\n<script>\nexport default {\n    data() {\n    },\n    props: ['fatherDataOne']，\n    methods: {\n        tellParent() {\n          this.$emit('listenOne', 'from childrenOne');\n        }\n    }\n}\n</script>\n```\n父组件\n``` vue\n<template> \n     <div class=\"components-bus-container\">\n        <children-one :fatherDataOne=\"fatherDataOne\" @listenOne='getCompomentOne'></children-one>\n     </div> \n</template>\n\n<script>\nexport default {\n  data() {\n      return {\n          fatherDataOne: '',\n      };\n  },\n  methods: {\n    getCompomentOne(param) {\n      console.log(param);\n    }\n  }\n}\n</script>\n```\n在父组件中绑定一个`listenOne`的事件，然后给这个事件添加`getCompomentOne`方法，当子组件children-one通过点击事件`tellParent`触发`listenOne`的时候，父组件里面的`getCompomentOne`方法就会执行，并且数据通过参数的形式传递给父组件，从而实现通信的功能。\n\n### 同级组件间通信\n对于同级间组件进行通信处理的方法是，新建一个Vue实例作为事件总线，具体实现如下：\n1.需要进行通信的同级组件引入`event.js`\n``` javascript\n\timport Vue from 'vue'; \n\tlet bus = new Vue(); \n\texport default bus; \n```\n2.组件`children-one`通过点击事件`sendMsgToTwo`触发`dataFromOne`\nchildren-one\n``` vue\n<template>\n    <div class=\"children-one-content\">\n        <div>{{fatherDataOne}}</div>\n        <div @click=\"tellParent\">点击向父组件通信</div>\n        <div @click=\"tellChildTwo\">点击向子组件2通信</div>\n    </div>\n</template>\n\n<script>\nimport bus from 'path/event'\nexport default {\n  data() {\n  },\n  props: ['fatherDataOne']，\n  methods: {\n    tellParent() {\n      this.$emit('listenOne', 'from childrenOne');\n    },\n    tellChildTwo() {\n      bus.$emit('dataFromOne', 'dataFromOne');\n    }\n  }\n}\n</script>\n```\n3.组件`children-two`中监听事件 `dataFromOne`\nchildren-two\n``` vue\n<template>\n    <div class=\"children-two-content\">\n    </div>\n</template>\n\n<script>\nimport bus from 'path/event'\nexport default {\n  data() {\n  },\n  methods: {\n    getMsgFromOne() {\n      bus.$on('dataFromOne', data => {\n        console.log(data);\n      });\n    }\n  },\n  mounted() {\n    this.getMsgFromOne();\n  }\n}\n</script>\n```\n当`children-one`触发`dataFromOne`时，组件`children-two`中的监听事件`dataFromOne`就会被触发，数据通过参数的形式传入，从而实现同级组件间通信。\n\n### 扩展\n##### 1.父组件操作子组件的方法\n利用$refs实现这个功能\n父组件\n``` vue\n<children-one :fatherDataOne=\"fatherDataOne\" @listenOne='getCompomentOne' ref=\"childrenOne\"></children-one>\n```\n那么就可以通过`this.$refs.childrenOne.childenFunction()`来操作子组件中的方法。\n##### 2.父组件将数据传给子组件，出现`undefined`情况\n当父组件传递的数据是异步取值的时候，可能出现首先传过去是空值，然后异步刷新。对于这种情况处理的方法是`v-if`，当父组件拿到数据后，将其设置为true，从而避免undefined的情况。\n \n### 高级用法\n对于一些简单的组件间的通信个人觉得这些方式够用了，如果一个页面涉及到很多的组件，那么也许这种方法不是那么简洁了，这是就需要用到`vue`中很重要的一个插件了`vuex`,以下为官网对`vuex`的介绍：\n[vuex](https://vuex.vuejs.org/)是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 [devtools extension](https://github.com/vuejs/vue-devtools)，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。\n如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的 global event bus 就足够您所需了。但是，如果您需要构建是一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。引用 Redux 的作者 Dan Abramov 的话说就是：\n\n> Flux 架构就像眼镜：您自会知道什么时候需要它。\n\n本文简单介绍了`vue`组件间的通信方式，如有错误，还望指出，大家一起交流学习。\n\n\n\n","slug":"vue-component-communication","published":1,"updated":"2019-04-10T08:15:01.347Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2mo4mxk000cdt47yg157amy","content":"<p>最近在学习vue方面的的知识，毫无疑问，对于vue来说，组件化是其一个很大的特点，一方面可以提高代码的可读性，另一方面可以少写很多的代码，利于代码的维护。对于组件之间数据通信是一个必须要掌握的知识点，通信之间的方式一共可以分为三种，父组件与子组件，子组件与父组件，同级组件间通信。</p>\n<h3 id=\"父组件与子组件\"><a href=\"#父组件与子组件\" class=\"headerlink\" title=\"父组件与子组件\"></a>父组件与子组件</h3><p>在vue中，父子组件的关系可以总结为 prop 向下传递，事件向上传递。父组件通过 prop 给子组件下发数据，子组件通过事件给父组件发送消息。<br><img src=\"/blog/img/vue-components-bus-01.png\"><br>父组件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt; </span><br><span class=\"line\">     &lt;div class=&quot;components-bus-container&quot;&gt;</span><br><span class=\"line\">        &lt;children-one :fatherDataOne=&quot;fatherDataOne&quot;&gt;&lt;/children-one&gt;</span><br><span class=\"line\">     &lt;/div&gt; </span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    data() &#123;</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">            fatherDataOne: &apos;&apos;,</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>子组件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;div class=&quot;children-one-content&quot;&gt;</span><br><span class=\"line\">        &lt;div&gt;&#123;&#123;fatherDataOne&#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    data() &#123;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    props: [&apos;fatherDataOne&apos;]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p></p><p class=\"tip\"><code>:fatherDataOne</code>为数据绑定写法，可以灵活的进行数据设置，如果直接绑定数据，写成<code>fatherDataOne=&quot;someData&quot;</code>即可</p><p></p>\n<h3 id=\"子组件与父组件通信\"><a href=\"#子组件与父组件通信\" class=\"headerlink\" title=\"子组件与父组件通信\"></a>子组件与父组件通信</h3><p>对于子组件将数据传给父组件，是通过<code>$emit</code>事件来实现的，在图中也可以体现，具体实现如下：<br>子组件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;div class=&quot;children-one-content&quot;&gt;</span><br><span class=\"line\">        &lt;div&gt;&#123;&#123;fatherDataOne&#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">        &lt;div @click=&quot;tellParent&quot;&gt;点击传递数据&lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    data() &#123;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    props: [&apos;fatherDataOne&apos;]，</span><br><span class=\"line\">    methods: &#123;</span><br><span class=\"line\">        tellParent() &#123;</span><br><span class=\"line\">          this.$emit(&apos;listenOne&apos;, &apos;from childrenOne&apos;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>父组件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt; </span><br><span class=\"line\">     &lt;div class=&quot;components-bus-container&quot;&gt;</span><br><span class=\"line\">        &lt;children-one :fatherDataOne=&quot;fatherDataOne&quot; @listenOne=&apos;getCompomentOne&apos;&gt;&lt;/children-one&gt;</span><br><span class=\"line\">     &lt;/div&gt; </span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">      return &#123;</span><br><span class=\"line\">          fatherDataOne: &apos;&apos;,</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    getCompomentOne(param) &#123;</span><br><span class=\"line\">      console.log(param);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>在父组件中绑定一个<code>listenOne</code>的事件，然后给这个事件添加<code>getCompomentOne</code>方法，当子组件children-one通过点击事件<code>tellParent</code>触发<code>listenOne</code>的时候，父组件里面的<code>getCompomentOne</code>方法就会执行，并且数据通过参数的形式传递给父组件，从而实现通信的功能。</p>\n<h3 id=\"同级组件间通信\"><a href=\"#同级组件间通信\" class=\"headerlink\" title=\"同级组件间通信\"></a>同级组件间通信</h3><p>对于同级间组件进行通信处理的方法是，新建一个Vue实例作为事件总线，具体实现如下：<br>1.需要进行通信的同级组件引入<code>event.js</code><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span>; </span><br><span class=\"line\"><span class=\"keyword\">let</span> bus = <span class=\"keyword\">new</span> Vue(); </span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> bus;</span><br></pre></td></tr></table></figure></p>\n<p>2.组件<code>children-one</code>通过点击事件<code>sendMsgToTwo</code>触发<code>dataFromOne</code><br>children-one<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;div class=&quot;children-one-content&quot;&gt;</span><br><span class=\"line\">        &lt;div&gt;&#123;&#123;fatherDataOne&#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">        &lt;div @click=&quot;tellParent&quot;&gt;点击向父组件通信&lt;/div&gt;</span><br><span class=\"line\">        &lt;div @click=&quot;tellChildTwo&quot;&gt;点击向子组件2通信&lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import bus from &apos;path/event&apos;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  props: [&apos;fatherDataOne&apos;]，</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    tellParent() &#123;</span><br><span class=\"line\">      this.$emit(&apos;listenOne&apos;, &apos;from childrenOne&apos;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    tellChildTwo() &#123;</span><br><span class=\"line\">      bus.$emit(&apos;dataFromOne&apos;, &apos;dataFromOne&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>3.组件<code>children-two</code>中监听事件 <code>dataFromOne</code><br>children-two<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;div class=&quot;children-two-content&quot;&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import bus from &apos;path/event&apos;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    getMsgFromOne() &#123;</span><br><span class=\"line\">      bus.$on(&apos;dataFromOne&apos;, data =&gt; &#123;</span><br><span class=\"line\">        console.log(data);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mounted() &#123;</span><br><span class=\"line\">    this.getMsgFromOne();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>当<code>children-one</code>触发<code>dataFromOne</code>时，组件<code>children-two</code>中的监听事件<code>dataFromOne</code>就会被触发，数据通过参数的形式传入，从而实现同级组件间通信。</p>\n<h3 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h3><h5 id=\"1-父组件操作子组件的方法\"><a href=\"#1-父组件操作子组件的方法\" class=\"headerlink\" title=\"1.父组件操作子组件的方法\"></a>1.父组件操作子组件的方法</h5><p>利用$refs实现这个功能<br>父组件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;children-one :fatherDataOne=&quot;fatherDataOne&quot; @listenOne=&apos;getCompomentOne&apos; ref=&quot;childrenOne&quot;&gt;&lt;/children-one&gt;</span><br></pre></td></tr></table></figure></p>\n<p>那么就可以通过<code>this.$refs.childrenOne.childenFunction()</code>来操作子组件中的方法。</p>\n<h5 id=\"2-父组件将数据传给子组件，出现undefined情况\"><a href=\"#2-父组件将数据传给子组件，出现undefined情况\" class=\"headerlink\" title=\"2.父组件将数据传给子组件，出现undefined情况\"></a>2.父组件将数据传给子组件，出现<code>undefined</code>情况</h5><p>当父组件传递的数据是异步取值的时候，可能出现首先传过去是空值，然后异步刷新。对于这种情况处理的方法是<code>v-if</code>，当父组件拿到数据后，将其设置为true，从而避免undefined的情况。</p>\n<h3 id=\"高级用法\"><a href=\"#高级用法\" class=\"headerlink\" title=\"高级用法\"></a>高级用法</h3><p>对于一些简单的组件间的通信个人觉得这些方式够用了，如果一个页面涉及到很多的组件，那么也许这种方法不是那么简洁了，这是就需要用到<code>vue</code>中很重要的一个插件了<code>vuex</code>,以下为官网对<code>vuex</code>的介绍：<br><a href=\"https://vuex.vuejs.org/\" target=\"_blank\" rel=\"noopener\">vuex</a>是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 <a href=\"https://github.com/vuejs/vue-devtools\" target=\"_blank\" rel=\"noopener\">devtools extension</a>，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。<br>如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的 global event bus 就足够您所需了。但是，如果您需要构建是一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。引用 Redux 的作者 Dan Abramov 的话说就是：</p>\n<blockquote>\n<p>Flux 架构就像眼镜：您自会知道什么时候需要它。</p>\n</blockquote>\n<p>本文简单介绍了<code>vue</code>组件间的通信方式，如有错误，还望指出，大家一起交流学习。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近在学习vue方面的的知识，毫无疑问，对于vue来说，组件化是其一个很大的特点，一方面可以提高代码的可读性，另一方面可以少写很多的代码，利于代码的维护。对于组件之间数据通信是一个必须要掌握的知识点，通信之间的方式一共可以分为三种，父组件与子组件，子组件与父组件，同级组件间通信。</p>\n<h3 id=\"父组件与子组件\"><a href=\"#父组件与子组件\" class=\"headerlink\" title=\"父组件与子组件\"></a>父组件与子组件</h3><p>在vue中，父子组件的关系可以总结为 prop 向下传递，事件向上传递。父组件通过 prop 给子组件下发数据，子组件通过事件给父组件发送消息。<br><img src=\"/blog/img/vue-components-bus-01.png\"><br>父组件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt; </span><br><span class=\"line\">     &lt;div class=&quot;components-bus-container&quot;&gt;</span><br><span class=\"line\">        &lt;children-one :fatherDataOne=&quot;fatherDataOne&quot;&gt;&lt;/children-one&gt;</span><br><span class=\"line\">     &lt;/div&gt; </span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    data() &#123;</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">            fatherDataOne: &apos;&apos;,</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>子组件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;div class=&quot;children-one-content&quot;&gt;</span><br><span class=\"line\">        &lt;div&gt;&#123;&#123;fatherDataOne&#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    data() &#123;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    props: [&apos;fatherDataOne&apos;]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p></p><p class=\"tip\"><code>:fatherDataOne</code>为数据绑定写法，可以灵活的进行数据设置，如果直接绑定数据，写成<code>fatherDataOne=&quot;someData&quot;</code>即可</p><p></p>\n<h3 id=\"子组件与父组件通信\"><a href=\"#子组件与父组件通信\" class=\"headerlink\" title=\"子组件与父组件通信\"></a>子组件与父组件通信</h3><p>对于子组件将数据传给父组件，是通过<code>$emit</code>事件来实现的，在图中也可以体现，具体实现如下：<br>子组件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;div class=&quot;children-one-content&quot;&gt;</span><br><span class=\"line\">        &lt;div&gt;&#123;&#123;fatherDataOne&#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">        &lt;div @click=&quot;tellParent&quot;&gt;点击传递数据&lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    data() &#123;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    props: [&apos;fatherDataOne&apos;]，</span><br><span class=\"line\">    methods: &#123;</span><br><span class=\"line\">        tellParent() &#123;</span><br><span class=\"line\">          this.$emit(&apos;listenOne&apos;, &apos;from childrenOne&apos;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>父组件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt; </span><br><span class=\"line\">     &lt;div class=&quot;components-bus-container&quot;&gt;</span><br><span class=\"line\">        &lt;children-one :fatherDataOne=&quot;fatherDataOne&quot; @listenOne=&apos;getCompomentOne&apos;&gt;&lt;/children-one&gt;</span><br><span class=\"line\">     &lt;/div&gt; </span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">      return &#123;</span><br><span class=\"line\">          fatherDataOne: &apos;&apos;,</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    getCompomentOne(param) &#123;</span><br><span class=\"line\">      console.log(param);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>在父组件中绑定一个<code>listenOne</code>的事件，然后给这个事件添加<code>getCompomentOne</code>方法，当子组件children-one通过点击事件<code>tellParent</code>触发<code>listenOne</code>的时候，父组件里面的<code>getCompomentOne</code>方法就会执行，并且数据通过参数的形式传递给父组件，从而实现通信的功能。</p>\n<h3 id=\"同级组件间通信\"><a href=\"#同级组件间通信\" class=\"headerlink\" title=\"同级组件间通信\"></a>同级组件间通信</h3><p>对于同级间组件进行通信处理的方法是，新建一个Vue实例作为事件总线，具体实现如下：<br>1.需要进行通信的同级组件引入<code>event.js</code><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span>; </span><br><span class=\"line\"><span class=\"keyword\">let</span> bus = <span class=\"keyword\">new</span> Vue(); </span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> bus;</span><br></pre></td></tr></table></figure></p>\n<p>2.组件<code>children-one</code>通过点击事件<code>sendMsgToTwo</code>触发<code>dataFromOne</code><br>children-one<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;div class=&quot;children-one-content&quot;&gt;</span><br><span class=\"line\">        &lt;div&gt;&#123;&#123;fatherDataOne&#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">        &lt;div @click=&quot;tellParent&quot;&gt;点击向父组件通信&lt;/div&gt;</span><br><span class=\"line\">        &lt;div @click=&quot;tellChildTwo&quot;&gt;点击向子组件2通信&lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import bus from &apos;path/event&apos;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  props: [&apos;fatherDataOne&apos;]，</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    tellParent() &#123;</span><br><span class=\"line\">      this.$emit(&apos;listenOne&apos;, &apos;from childrenOne&apos;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    tellChildTwo() &#123;</span><br><span class=\"line\">      bus.$emit(&apos;dataFromOne&apos;, &apos;dataFromOne&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>3.组件<code>children-two</code>中监听事件 <code>dataFromOne</code><br>children-two<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;div class=&quot;children-two-content&quot;&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import bus from &apos;path/event&apos;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    getMsgFromOne() &#123;</span><br><span class=\"line\">      bus.$on(&apos;dataFromOne&apos;, data =&gt; &#123;</span><br><span class=\"line\">        console.log(data);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mounted() &#123;</span><br><span class=\"line\">    this.getMsgFromOne();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>当<code>children-one</code>触发<code>dataFromOne</code>时，组件<code>children-two</code>中的监听事件<code>dataFromOne</code>就会被触发，数据通过参数的形式传入，从而实现同级组件间通信。</p>\n<h3 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h3><h5 id=\"1-父组件操作子组件的方法\"><a href=\"#1-父组件操作子组件的方法\" class=\"headerlink\" title=\"1.父组件操作子组件的方法\"></a>1.父组件操作子组件的方法</h5><p>利用$refs实现这个功能<br>父组件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;children-one :fatherDataOne=&quot;fatherDataOne&quot; @listenOne=&apos;getCompomentOne&apos; ref=&quot;childrenOne&quot;&gt;&lt;/children-one&gt;</span><br></pre></td></tr></table></figure></p>\n<p>那么就可以通过<code>this.$refs.childrenOne.childenFunction()</code>来操作子组件中的方法。</p>\n<h5 id=\"2-父组件将数据传给子组件，出现undefined情况\"><a href=\"#2-父组件将数据传给子组件，出现undefined情况\" class=\"headerlink\" title=\"2.父组件将数据传给子组件，出现undefined情况\"></a>2.父组件将数据传给子组件，出现<code>undefined</code>情况</h5><p>当父组件传递的数据是异步取值的时候，可能出现首先传过去是空值，然后异步刷新。对于这种情况处理的方法是<code>v-if</code>，当父组件拿到数据后，将其设置为true，从而避免undefined的情况。</p>\n<h3 id=\"高级用法\"><a href=\"#高级用法\" class=\"headerlink\" title=\"高级用法\"></a>高级用法</h3><p>对于一些简单的组件间的通信个人觉得这些方式够用了，如果一个页面涉及到很多的组件，那么也许这种方法不是那么简洁了，这是就需要用到<code>vue</code>中很重要的一个插件了<code>vuex</code>,以下为官网对<code>vuex</code>的介绍：<br><a href=\"https://vuex.vuejs.org/\" target=\"_blank\" rel=\"noopener\">vuex</a>是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 <a href=\"https://github.com/vuejs/vue-devtools\" target=\"_blank\" rel=\"noopener\">devtools extension</a>，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。<br>如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的 global event bus 就足够您所需了。但是，如果您需要构建是一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。引用 Redux 的作者 Dan Abramov 的话说就是：</p>\n<blockquote>\n<p>Flux 架构就像眼镜：您自会知道什么时候需要它。</p>\n</blockquote>\n<p>本文简单介绍了<code>vue</code>组件间的通信方式，如有错误，还望指出，大家一起交流学习。</p>\n"},{"title":"vue-router 的一些记录","date":"2018-02-24T09:38:06.000Z","summary":"一直对 vue-router 有点敬畏之心，因为总感觉对他的理解模模糊糊的，今天看了一下官网文档，有了一点点的理解，时来兴起，就有了这篇文章。","_content":"一直对**vue-router**有点敬畏之心，因为总感觉对他的理解模模糊糊的，今天看了一下官网文档，有了一点点的理解，时来兴起，就有了这篇文章。\n### vue-router 传参\n在使用 vue-router 进行页面跳转的时候，有以下两种方式可以实现：\n* `<router-link>Home</router-link>`---声明式\n\n``` html\n<!-- 字符串 -->\n<router-link to=\"home\">Home</router-link>\n<!-- 渲染结果 -->\n<a href=\"home\">Home</a>\n\n<!-- 使用 v-bind 的 JS 表达式 -->\n<router-link v-bind:to=\"'home'\">Home</router-link>\n\n<!-- 不写 v-bind 也可以，就像绑定别的属性一样 -->\n<router-link :to=\"'home'\">Home</router-link>\n\n<!-- 同上 -->\n<router-link :to=\"{ path: 'home' }\">Home</router-link>\n\n<!-- 命名的路由 -->\n<router-link :to=\"{ name: 'user', params: { userId: 123 }}\">User</router-link>\n\n<!-- 带查询参数，下面的结果为 /register?plan=private -->\n<router-link :to=\"{ path: 'register', query: { plan: 'private' }}\">Register</router-link>\n```\n* `router.push(...)`---编程式\n\n该方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如：\n\n``` javascript\n// 字符串\nrouter.push('home')\n\n// 对象\nrouter.push({ path: 'home' })\n\n// 命名的路由\nrouter.push({ name: 'user', params: { userId: 123 }})\n\n// 带查询参数，变成 /register?plan=private\nrouter.push({ path: 'register', query: { plan: 'private' }})\n```\n<p class=\"tip\">注意：如果提供了 path，params 会被忽略，上述例子中的 query 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path：</p>\n\n``` javascript\nconst userId = 123\nrouter.push({ name: 'user', params: { userId }}) // -> /user/123\nrouter.push({ path: `/user/${userId}` }) // -> /user/123\n// 这里的 params 不生效\nrouter.push({ path: '/user', params: { userId }}) // -> /user\n```\n\n这两种方式传递参数的方式其实是一样的，从写法也可以大致看出，下面就对参数的传递方式进行介绍\n首先创建一个Router实例\n``` javascript\nconst router = new VueRouter({\n  routes: [\n    {\n      path: '/user',\n      name: 'user',\n      component: User\n    }\n  ]\n})\n```\n#### 1.使用params方式\n``` javascript\nrouter.push({ name: 'user', params: { userId: 123 }}) // -> /user\n```\n获取参数:\n``` javascript\nrouter.params.userId  //123\n```\n<p class=\"tip\">这种方式看上去不错，对于传递的参数没有在浏览器的地址栏显示，而是隐藏了。但是当我们再次刷新的时候,`router.params.userId`就变成了`undefined`，对于这个解决方法如下:</p>\n修改Router实例，在路由路径上增加该参数\n``` javascript\nconst router = new VueRouter({\n  routes: [\n    {\n      path: '/user/:userId',\n      name: 'user',\n      component: User\n    }\n  ]\n})\n```\n此时，浏览器的地址栏就会变成:/user/123,然后不管怎么刷新也会取到参数。其实使用`query`方式传递参数也可以避免这个问题。\n\n#### 2.使用query方式\n\n``` javascript\nrouter.push({ path: '/user', query: { userId: 123 }}) // ->/user?userId=123\n```\n获取参数:\n``` javascript\nrouter.query.userId  //123\n```","source":"_posts/vue-router.md","raw":"---\ntitle: vue-router 的一些记录\ndate: 2018-02-24 17:38:06\ntags: [vue]\nsummary: 一直对 vue-router 有点敬畏之心，因为总感觉对他的理解模模糊糊的，今天看了一下官网文档，有了一点点的理解，时来兴起，就有了这篇文章。\n---\n一直对**vue-router**有点敬畏之心，因为总感觉对他的理解模模糊糊的，今天看了一下官网文档，有了一点点的理解，时来兴起，就有了这篇文章。\n### vue-router 传参\n在使用 vue-router 进行页面跳转的时候，有以下两种方式可以实现：\n* `<router-link>Home</router-link>`---声明式\n\n``` html\n<!-- 字符串 -->\n<router-link to=\"home\">Home</router-link>\n<!-- 渲染结果 -->\n<a href=\"home\">Home</a>\n\n<!-- 使用 v-bind 的 JS 表达式 -->\n<router-link v-bind:to=\"'home'\">Home</router-link>\n\n<!-- 不写 v-bind 也可以，就像绑定别的属性一样 -->\n<router-link :to=\"'home'\">Home</router-link>\n\n<!-- 同上 -->\n<router-link :to=\"{ path: 'home' }\">Home</router-link>\n\n<!-- 命名的路由 -->\n<router-link :to=\"{ name: 'user', params: { userId: 123 }}\">User</router-link>\n\n<!-- 带查询参数，下面的结果为 /register?plan=private -->\n<router-link :to=\"{ path: 'register', query: { plan: 'private' }}\">Register</router-link>\n```\n* `router.push(...)`---编程式\n\n该方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如：\n\n``` javascript\n// 字符串\nrouter.push('home')\n\n// 对象\nrouter.push({ path: 'home' })\n\n// 命名的路由\nrouter.push({ name: 'user', params: { userId: 123 }})\n\n// 带查询参数，变成 /register?plan=private\nrouter.push({ path: 'register', query: { plan: 'private' }})\n```\n<p class=\"tip\">注意：如果提供了 path，params 会被忽略，上述例子中的 query 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path：</p>\n\n``` javascript\nconst userId = 123\nrouter.push({ name: 'user', params: { userId }}) // -> /user/123\nrouter.push({ path: `/user/${userId}` }) // -> /user/123\n// 这里的 params 不生效\nrouter.push({ path: '/user', params: { userId }}) // -> /user\n```\n\n这两种方式传递参数的方式其实是一样的，从写法也可以大致看出，下面就对参数的传递方式进行介绍\n首先创建一个Router实例\n``` javascript\nconst router = new VueRouter({\n  routes: [\n    {\n      path: '/user',\n      name: 'user',\n      component: User\n    }\n  ]\n})\n```\n#### 1.使用params方式\n``` javascript\nrouter.push({ name: 'user', params: { userId: 123 }}) // -> /user\n```\n获取参数:\n``` javascript\nrouter.params.userId  //123\n```\n<p class=\"tip\">这种方式看上去不错，对于传递的参数没有在浏览器的地址栏显示，而是隐藏了。但是当我们再次刷新的时候,`router.params.userId`就变成了`undefined`，对于这个解决方法如下:</p>\n修改Router实例，在路由路径上增加该参数\n``` javascript\nconst router = new VueRouter({\n  routes: [\n    {\n      path: '/user/:userId',\n      name: 'user',\n      component: User\n    }\n  ]\n})\n```\n此时，浏览器的地址栏就会变成:/user/123,然后不管怎么刷新也会取到参数。其实使用`query`方式传递参数也可以避免这个问题。\n\n#### 2.使用query方式\n\n``` javascript\nrouter.push({ path: '/user', query: { userId: 123 }}) // ->/user?userId=123\n```\n获取参数:\n``` javascript\nrouter.query.userId  //123\n```","slug":"vue-router","published":1,"updated":"2019-04-10T08:15:01.347Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2mo4mxl000ddt47fqhugyxf","content":"<p>一直对<strong>vue-router</strong>有点敬畏之心，因为总感觉对他的理解模模糊糊的，今天看了一下官网文档，有了一点点的理解，时来兴起，就有了这篇文章。</p>\n<h3 id=\"vue-router-传参\"><a href=\"#vue-router-传参\" class=\"headerlink\" title=\"vue-router 传参\"></a>vue-router 传参</h3><p>在使用 vue-router 进行页面跳转的时候，有以下两种方式可以实现：</p>\n<ul>\n<li><code>&lt;router-link&gt;Home&lt;/router-link&gt;</code>—声明式</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 字符串 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"home\"</span>&gt;</span>Home<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 渲染结果 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"home\"</span>&gt;</span>Home<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 使用 v-bind 的 JS 表达式 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">v-bind:to</span>=<span class=\"string\">\"'home'\"</span>&gt;</span>Home<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 不写 v-bind 也可以，就像绑定别的属性一样 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">:to</span>=<span class=\"string\">\"'home'\"</span>&gt;</span>Home<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 同上 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">:to</span>=<span class=\"string\">\"&#123; path: 'home' &#125;\"</span>&gt;</span>Home<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 命名的路由 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">:to</span>=<span class=\"string\">\"&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;\"</span>&gt;</span>User<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 带查询参数，下面的结果为 /register?plan=private --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">:to</span>=<span class=\"string\">\"&#123; path: 'register', query: &#123; plan: 'private' &#125;&#125;\"</span>&gt;</span>Register<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>router.push(...)</code>—编程式</li>\n</ul>\n<p>该方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 字符串</span></span><br><span class=\"line\">router.push(<span class=\"string\">'home'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对象</span></span><br><span class=\"line\">router.push(&#123; <span class=\"attr\">path</span>: <span class=\"string\">'home'</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 命名的路由</span></span><br><span class=\"line\">router.push(&#123; <span class=\"attr\">name</span>: <span class=\"string\">'user'</span>, <span class=\"attr\">params</span>: &#123; <span class=\"attr\">userId</span>: <span class=\"number\">123</span> &#125;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 带查询参数，变成 /register?plan=private</span></span><br><span class=\"line\">router.push(&#123; <span class=\"attr\">path</span>: <span class=\"string\">'register'</span>, <span class=\"attr\">query</span>: &#123; <span class=\"attr\">plan</span>: <span class=\"string\">'private'</span> &#125;&#125;)</span><br></pre></td></tr></table></figure>\n<p class=\"tip\">注意：如果提供了 path，params 会被忽略，上述例子中的 query 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path：</p>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> userId = <span class=\"number\">123</span></span><br><span class=\"line\">router.push(&#123; <span class=\"attr\">name</span>: <span class=\"string\">'user'</span>, <span class=\"attr\">params</span>: &#123; userId &#125;&#125;) <span class=\"comment\">// -&gt; /user/123</span></span><br><span class=\"line\">router.push(&#123; <span class=\"attr\">path</span>: <span class=\"string\">`/user/<span class=\"subst\">$&#123;userId&#125;</span>`</span> &#125;) <span class=\"comment\">// -&gt; /user/123</span></span><br><span class=\"line\"><span class=\"comment\">// 这里的 params 不生效</span></span><br><span class=\"line\">router.push(&#123; <span class=\"attr\">path</span>: <span class=\"string\">'/user'</span>, <span class=\"attr\">params</span>: &#123; userId &#125;&#125;) <span class=\"comment\">// -&gt; /user</span></span><br></pre></td></tr></table></figure>\n<p>这两种方式传递参数的方式其实是一样的，从写法也可以大致看出，下面就对参数的传递方式进行介绍<br>首先创建一个Router实例<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> VueRouter(&#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      path: <span class=\"string\">'/user'</span>,</span><br><span class=\"line\">      name: <span class=\"string\">'user'</span>,</span><br><span class=\"line\">      component: User</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"1-使用params方式\"><a href=\"#1-使用params方式\" class=\"headerlink\" title=\"1.使用params方式\"></a>1.使用params方式</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.push(&#123; <span class=\"attr\">name</span>: <span class=\"string\">'user'</span>, <span class=\"attr\">params</span>: &#123; <span class=\"attr\">userId</span>: <span class=\"number\">123</span> &#125;&#125;) <span class=\"comment\">// -&gt; /user</span></span><br></pre></td></tr></table></figure>\n<p>获取参数:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.params.userId  <span class=\"comment\">//123</span></span><br></pre></td></tr></table></figure></p>\n<p></p><p class=\"tip\">这种方式看上去不错，对于传递的参数没有在浏览器的地址栏显示，而是隐藏了。但是当我们再次刷新的时候,<code>router.params.userId</code>就变成了<code>undefined</code>，对于这个解决方法如下:</p><br>修改Router实例，在路由路径上增加该参数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> VueRouter(&#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      path: <span class=\"string\">'/user/:userId'</span>,</span><br><span class=\"line\">      name: <span class=\"string\">'user'</span>,</span><br><span class=\"line\">      component: User</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure><p></p>\n<p>此时，浏览器的地址栏就会变成:/user/123,然后不管怎么刷新也会取到参数。其实使用<code>query</code>方式传递参数也可以避免这个问题。</p>\n<h4 id=\"2-使用query方式\"><a href=\"#2-使用query方式\" class=\"headerlink\" title=\"2.使用query方式\"></a>2.使用query方式</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.push(&#123; <span class=\"attr\">path</span>: <span class=\"string\">'/user'</span>, <span class=\"attr\">query</span>: &#123; <span class=\"attr\">userId</span>: <span class=\"number\">123</span> &#125;&#125;) <span class=\"comment\">// -&gt;/user?userId=123</span></span><br></pre></td></tr></table></figure>\n<p>获取参数:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.query.userId  <span class=\"comment\">//123</span></span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>一直对<strong>vue-router</strong>有点敬畏之心，因为总感觉对他的理解模模糊糊的，今天看了一下官网文档，有了一点点的理解，时来兴起，就有了这篇文章。</p>\n<h3 id=\"vue-router-传参\"><a href=\"#vue-router-传参\" class=\"headerlink\" title=\"vue-router 传参\"></a>vue-router 传参</h3><p>在使用 vue-router 进行页面跳转的时候，有以下两种方式可以实现：</p>\n<ul>\n<li><code>&lt;router-link&gt;Home&lt;/router-link&gt;</code>—声明式</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 字符串 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"home\"</span>&gt;</span>Home<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 渲染结果 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"home\"</span>&gt;</span>Home<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 使用 v-bind 的 JS 表达式 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">v-bind:to</span>=<span class=\"string\">\"'home'\"</span>&gt;</span>Home<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 不写 v-bind 也可以，就像绑定别的属性一样 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">:to</span>=<span class=\"string\">\"'home'\"</span>&gt;</span>Home<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 同上 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">:to</span>=<span class=\"string\">\"&#123; path: 'home' &#125;\"</span>&gt;</span>Home<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 命名的路由 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">:to</span>=<span class=\"string\">\"&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;\"</span>&gt;</span>User<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 带查询参数，下面的结果为 /register?plan=private --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">:to</span>=<span class=\"string\">\"&#123; path: 'register', query: &#123; plan: 'private' &#125;&#125;\"</span>&gt;</span>Register<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>router.push(...)</code>—编程式</li>\n</ul>\n<p>该方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 字符串</span></span><br><span class=\"line\">router.push(<span class=\"string\">'home'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对象</span></span><br><span class=\"line\">router.push(&#123; <span class=\"attr\">path</span>: <span class=\"string\">'home'</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 命名的路由</span></span><br><span class=\"line\">router.push(&#123; <span class=\"attr\">name</span>: <span class=\"string\">'user'</span>, <span class=\"attr\">params</span>: &#123; <span class=\"attr\">userId</span>: <span class=\"number\">123</span> &#125;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 带查询参数，变成 /register?plan=private</span></span><br><span class=\"line\">router.push(&#123; <span class=\"attr\">path</span>: <span class=\"string\">'register'</span>, <span class=\"attr\">query</span>: &#123; <span class=\"attr\">plan</span>: <span class=\"string\">'private'</span> &#125;&#125;)</span><br></pre></td></tr></table></figure>\n<p class=\"tip\">注意：如果提供了 path，params 会被忽略，上述例子中的 query 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path：</p>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> userId = <span class=\"number\">123</span></span><br><span class=\"line\">router.push(&#123; <span class=\"attr\">name</span>: <span class=\"string\">'user'</span>, <span class=\"attr\">params</span>: &#123; userId &#125;&#125;) <span class=\"comment\">// -&gt; /user/123</span></span><br><span class=\"line\">router.push(&#123; <span class=\"attr\">path</span>: <span class=\"string\">`/user/<span class=\"subst\">$&#123;userId&#125;</span>`</span> &#125;) <span class=\"comment\">// -&gt; /user/123</span></span><br><span class=\"line\"><span class=\"comment\">// 这里的 params 不生效</span></span><br><span class=\"line\">router.push(&#123; <span class=\"attr\">path</span>: <span class=\"string\">'/user'</span>, <span class=\"attr\">params</span>: &#123; userId &#125;&#125;) <span class=\"comment\">// -&gt; /user</span></span><br></pre></td></tr></table></figure>\n<p>这两种方式传递参数的方式其实是一样的，从写法也可以大致看出，下面就对参数的传递方式进行介绍<br>首先创建一个Router实例<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> VueRouter(&#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      path: <span class=\"string\">'/user'</span>,</span><br><span class=\"line\">      name: <span class=\"string\">'user'</span>,</span><br><span class=\"line\">      component: User</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"1-使用params方式\"><a href=\"#1-使用params方式\" class=\"headerlink\" title=\"1.使用params方式\"></a>1.使用params方式</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.push(&#123; <span class=\"attr\">name</span>: <span class=\"string\">'user'</span>, <span class=\"attr\">params</span>: &#123; <span class=\"attr\">userId</span>: <span class=\"number\">123</span> &#125;&#125;) <span class=\"comment\">// -&gt; /user</span></span><br></pre></td></tr></table></figure>\n<p>获取参数:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.params.userId  <span class=\"comment\">//123</span></span><br></pre></td></tr></table></figure></p>\n<p></p><p class=\"tip\">这种方式看上去不错，对于传递的参数没有在浏览器的地址栏显示，而是隐藏了。但是当我们再次刷新的时候,<code>router.params.userId</code>就变成了<code>undefined</code>，对于这个解决方法如下:</p><br>修改Router实例，在路由路径上增加该参数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> VueRouter(&#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      path: <span class=\"string\">'/user/:userId'</span>,</span><br><span class=\"line\">      name: <span class=\"string\">'user'</span>,</span><br><span class=\"line\">      component: User</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure><p></p>\n<p>此时，浏览器的地址栏就会变成:/user/123,然后不管怎么刷新也会取到参数。其实使用<code>query</code>方式传递参数也可以避免这个问题。</p>\n<h4 id=\"2-使用query方式\"><a href=\"#2-使用query方式\" class=\"headerlink\" title=\"2.使用query方式\"></a>2.使用query方式</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.push(&#123; <span class=\"attr\">path</span>: <span class=\"string\">'/user'</span>, <span class=\"attr\">query</span>: &#123; <span class=\"attr\">userId</span>: <span class=\"number\">123</span> &#125;&#125;) <span class=\"comment\">// -&gt;/user?userId=123</span></span><br></pre></td></tr></table></figure>\n<p>获取参数:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.query.userId  <span class=\"comment\">//123</span></span><br></pre></td></tr></table></figure></p>\n"},{"title":"这样读书就够了","date":"2019-03-08T02:04:27.000Z","summary":"这两天在看一本书叫做《这样读书就够了》，这本书是拆书帮的创始人赵周老师的作品。在此之前无数次听说过拆书帮，但赵周老师是第一次接触，因为我报名参加了3月16及17赵周老师的线下课程，学费不便宜，3288两天，我抱着质疑的态度去审视他的作品，想要去看看这是何方神圣，但却没想到在他的书本中，我受到了启发，对于自己一直以来的学习的方式、自己知识焦虑的一种反射，以及未来改进的方向。","_content":"\n这两天在看一本书叫做《这样读书就够了》，这本书是拆书帮的创始人赵周老师的作品。在此之前无数次听说过拆书帮，但赵周老师是第一次接触，因为我报名参加了3月16及17赵周老师的线下课程，学费不便宜，3288两天，我抱着质疑的态度去审视他的作品，想要去看看这是何方神圣，但却没想到在他的书本中，我受到了启发，对于自己一直以来的学习的方式、自己知识焦虑的一种反射，以及未来改进的方向。\n\n这本书的核心是讲RIA便签阅读法，书中通过分析现代大部分读书难及学习中的误区并结合大量古今中外的案例以及分析各种级别的学习者来介绍以下几个核心观点，RIA是什么、为什么RIA好？RIA如何运用？\n\n###RIA是什么、为什么RIA好\n* 有些人有知识焦虑，所以疯狂的参加各种培训和付费课程，花费无数，坚持与否或者效果好坏暂且不讨论；\n* 有些人看完一本书，最后合上书，却只能用“写得好”、“印象深刻”等空泛的词来作为结束语，然后就没有了然后；\n* 有些人喜欢追求干货，不看过程，只看结论；\n* 有些人立下flag，一年要看多少本书；\n* 有些人从头一字不落看到尾，认为这样才是对书的尊重；\n* 有些人遇到晦涩难懂的部分，因此就放弃了再拿起这本书；\n\n各种各样的万象都有，大家都在学习，都在获取新知，那造成人与人千差万别的本质是什么？是读书的方式吗？是读书的多少吗？懂得很多道理，为什么还是过不好这一生？知识真的是价格昂贵，不可获得的吗？为什么大家更愿意付更高昂的费用参加培训或者购买付费课程？\n\n>图书=核心知识+书面表达\n培训=核心知识+口头表达\n培训=图书+I\n\n从上面的公式中我们可以看出知识其实并不贵，甚至是非常容易“获取”的，培训和书籍的差别在于I，那I是什么？I的能力我们是否可以自行习得？\n\n```I（Interpretation）（引导促进）＝以自我为中心＋激活经验＋促动参与＋催化应用 ```\n有了I，学习者更容易理解知识、印象更深刻。（体验） \n有了I，学习者将知识与自己的经验联系。（反思）\n\n有了反思和体验，从而我们才能更好的将这个知识拆我们所用A(`Appropriation`)\n\n所以RIA的本质是通过强化体验、反思总结并致用的过程。说白话点就是带着目的性以解决实际问题的方式去读书，并内化成自身知识体系。（这个和辉哥今早写的快速阅读的核心很像）\n\n### RIA如何运用\n以阅读致用类图书为例，在阅读的过程中，准备三色标签，分别用来做3类笔记（I、A1，A2）\n>I：用自己的语言重述知识\nA1:描述自己的相关经验\nA2:以后我怎样运用\n\n---\n### try\n看了这么久这本书的理论，那我也来试试用RIA法拆解我当下在读的《这样读书就够了》这本书\n**I**：学习的目的最终一定是学以致用，如何致用并不是口头一说，可通过以下方式来强化，那就是RIA的精髓：*用自己的语言复述知识；以往自己是如何做的；以后自己将打算怎么做*\n**A1**:上面讲到的有些人，都有我的影子，热衷报课程、认为报了某某课程看了某某书自己就能脱胎换骨，最后效果没有达到预期，以为是自己不够坚持；立看书flag，比如去年24本，今年36本，用量来感动自己；因为看到书名不错或者他人正在热读而选择一本书，随意又无计划；从头看到尾，一字不落，认为这样才算读完一本书，读完就读完了...\n**A2**:今后我会改掉我以往的学习心态，不管是什么方式的学习（不会从此排拆培训，必要的培训可以去参加，但不盲目），一定是带着问题结合自己的现状、困惑点并以运用知识为导向来学习。从选书、阅读方式、纪录习惯三个方面改进\n* 选书：主读和生活、工作、个人发展上困惑的问题相关的书籍；\n* 阅读方式：先看目录，了解内容的构成，精读核心知识部分，泛读或者不读其它内容，不再追求从头到尾，一字不落；\n* 记录：用RIA法就书中的核心知识点做纪录，尝试写书评和总结，强化记忆及方便以后使用","source":"_posts/the-way-to-reading.md","raw":"---\ntitle: 这样读书就够了\ndate: 2019-03-08 10:04:27\ntags: [读书,feelings]\nsummary: 这两天在看一本书叫做《这样读书就够了》，这本书是拆书帮的创始人赵周老师的作品。在此之前无数次听说过拆书帮，但赵周老师是第一次接触，因为我报名参加了3月16及17赵周老师的线下课程，学费不便宜，3288两天，我抱着质疑的态度去审视他的作品，想要去看看这是何方神圣，但却没想到在他的书本中，我受到了启发，对于自己一直以来的学习的方式、自己知识焦虑的一种反射，以及未来改进的方向。\n---\n\n这两天在看一本书叫做《这样读书就够了》，这本书是拆书帮的创始人赵周老师的作品。在此之前无数次听说过拆书帮，但赵周老师是第一次接触，因为我报名参加了3月16及17赵周老师的线下课程，学费不便宜，3288两天，我抱着质疑的态度去审视他的作品，想要去看看这是何方神圣，但却没想到在他的书本中，我受到了启发，对于自己一直以来的学习的方式、自己知识焦虑的一种反射，以及未来改进的方向。\n\n这本书的核心是讲RIA便签阅读法，书中通过分析现代大部分读书难及学习中的误区并结合大量古今中外的案例以及分析各种级别的学习者来介绍以下几个核心观点，RIA是什么、为什么RIA好？RIA如何运用？\n\n###RIA是什么、为什么RIA好\n* 有些人有知识焦虑，所以疯狂的参加各种培训和付费课程，花费无数，坚持与否或者效果好坏暂且不讨论；\n* 有些人看完一本书，最后合上书，却只能用“写得好”、“印象深刻”等空泛的词来作为结束语，然后就没有了然后；\n* 有些人喜欢追求干货，不看过程，只看结论；\n* 有些人立下flag，一年要看多少本书；\n* 有些人从头一字不落看到尾，认为这样才是对书的尊重；\n* 有些人遇到晦涩难懂的部分，因此就放弃了再拿起这本书；\n\n各种各样的万象都有，大家都在学习，都在获取新知，那造成人与人千差万别的本质是什么？是读书的方式吗？是读书的多少吗？懂得很多道理，为什么还是过不好这一生？知识真的是价格昂贵，不可获得的吗？为什么大家更愿意付更高昂的费用参加培训或者购买付费课程？\n\n>图书=核心知识+书面表达\n培训=核心知识+口头表达\n培训=图书+I\n\n从上面的公式中我们可以看出知识其实并不贵，甚至是非常容易“获取”的，培训和书籍的差别在于I，那I是什么？I的能力我们是否可以自行习得？\n\n```I（Interpretation）（引导促进）＝以自我为中心＋激活经验＋促动参与＋催化应用 ```\n有了I，学习者更容易理解知识、印象更深刻。（体验） \n有了I，学习者将知识与自己的经验联系。（反思）\n\n有了反思和体验，从而我们才能更好的将这个知识拆我们所用A(`Appropriation`)\n\n所以RIA的本质是通过强化体验、反思总结并致用的过程。说白话点就是带着目的性以解决实际问题的方式去读书，并内化成自身知识体系。（这个和辉哥今早写的快速阅读的核心很像）\n\n### RIA如何运用\n以阅读致用类图书为例，在阅读的过程中，准备三色标签，分别用来做3类笔记（I、A1，A2）\n>I：用自己的语言重述知识\nA1:描述自己的相关经验\nA2:以后我怎样运用\n\n---\n### try\n看了这么久这本书的理论，那我也来试试用RIA法拆解我当下在读的《这样读书就够了》这本书\n**I**：学习的目的最终一定是学以致用，如何致用并不是口头一说，可通过以下方式来强化，那就是RIA的精髓：*用自己的语言复述知识；以往自己是如何做的；以后自己将打算怎么做*\n**A1**:上面讲到的有些人，都有我的影子，热衷报课程、认为报了某某课程看了某某书自己就能脱胎换骨，最后效果没有达到预期，以为是自己不够坚持；立看书flag，比如去年24本，今年36本，用量来感动自己；因为看到书名不错或者他人正在热读而选择一本书，随意又无计划；从头看到尾，一字不落，认为这样才算读完一本书，读完就读完了...\n**A2**:今后我会改掉我以往的学习心态，不管是什么方式的学习（不会从此排拆培训，必要的培训可以去参加，但不盲目），一定是带着问题结合自己的现状、困惑点并以运用知识为导向来学习。从选书、阅读方式、纪录习惯三个方面改进\n* 选书：主读和生活、工作、个人发展上困惑的问题相关的书籍；\n* 阅读方式：先看目录，了解内容的构成，精读核心知识部分，泛读或者不读其它内容，不再追求从头到尾，一字不落；\n* 记录：用RIA法就书中的核心知识点做纪录，尝试写书评和总结，强化记忆及方便以后使用","slug":"the-way-to-reading","published":1,"updated":"2019-04-11T01:50:14.079Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2mo4mya0017dt472yiu8675","content":"<p>这两天在看一本书叫做《这样读书就够了》，这本书是拆书帮的创始人赵周老师的作品。在此之前无数次听说过拆书帮，但赵周老师是第一次接触，因为我报名参加了3月16及17赵周老师的线下课程，学费不便宜，3288两天，我抱着质疑的态度去审视他的作品，想要去看看这是何方神圣，但却没想到在他的书本中，我受到了启发，对于自己一直以来的学习的方式、自己知识焦虑的一种反射，以及未来改进的方向。</p>\n<p>这本书的核心是讲RIA便签阅读法，书中通过分析现代大部分读书难及学习中的误区并结合大量古今中外的案例以及分析各种级别的学习者来介绍以下几个核心观点，RIA是什么、为什么RIA好？RIA如何运用？</p>\n<p>###RIA是什么、为什么RIA好</p>\n<ul>\n<li>有些人有知识焦虑，所以疯狂的参加各种培训和付费课程，花费无数，坚持与否或者效果好坏暂且不讨论；</li>\n<li>有些人看完一本书，最后合上书，却只能用“写得好”、“印象深刻”等空泛的词来作为结束语，然后就没有了然后；</li>\n<li>有些人喜欢追求干货，不看过程，只看结论；</li>\n<li>有些人立下flag，一年要看多少本书；</li>\n<li>有些人从头一字不落看到尾，认为这样才是对书的尊重；</li>\n<li>有些人遇到晦涩难懂的部分，因此就放弃了再拿起这本书；</li>\n</ul>\n<p>各种各样的万象都有，大家都在学习，都在获取新知，那造成人与人千差万别的本质是什么？是读书的方式吗？是读书的多少吗？懂得很多道理，为什么还是过不好这一生？知识真的是价格昂贵，不可获得的吗？为什么大家更愿意付更高昂的费用参加培训或者购买付费课程？</p>\n<blockquote>\n<p>图书=核心知识+书面表达<br>培训=核心知识+口头表达<br>培训=图书+I</p>\n</blockquote>\n<p>从上面的公式中我们可以看出知识其实并不贵，甚至是非常容易“获取”的，培训和书籍的差别在于I，那I是什么？I的能力我们是否可以自行习得？</p>\n<p><code>I（Interpretation）（引导促进）＝以自我为中心＋激活经验＋促动参与＋催化应用</code><br>有了I，学习者更容易理解知识、印象更深刻。（体验）<br>有了I，学习者将知识与自己的经验联系。（反思）</p>\n<p>有了反思和体验，从而我们才能更好的将这个知识拆我们所用A(<code>Appropriation</code>)</p>\n<p>所以RIA的本质是通过强化体验、反思总结并致用的过程。说白话点就是带着目的性以解决实际问题的方式去读书，并内化成自身知识体系。（这个和辉哥今早写的快速阅读的核心很像）</p>\n<h3 id=\"RIA如何运用\"><a href=\"#RIA如何运用\" class=\"headerlink\" title=\"RIA如何运用\"></a>RIA如何运用</h3><p>以阅读致用类图书为例，在阅读的过程中，准备三色标签，分别用来做3类笔记（I、A1，A2）</p>\n<blockquote>\n<p>I：用自己的语言重述知识<br>A1:描述自己的相关经验<br>A2:以后我怎样运用</p>\n</blockquote>\n<hr>\n<h3 id=\"try\"><a href=\"#try\" class=\"headerlink\" title=\"try\"></a>try</h3><p>看了这么久这本书的理论，那我也来试试用RIA法拆解我当下在读的《这样读书就够了》这本书<br><strong>I</strong>：学习的目的最终一定是学以致用，如何致用并不是口头一说，可通过以下方式来强化，那就是RIA的精髓：<em>用自己的语言复述知识；以往自己是如何做的；以后自己将打算怎么做</em><br><strong>A1</strong>:上面讲到的有些人，都有我的影子，热衷报课程、认为报了某某课程看了某某书自己就能脱胎换骨，最后效果没有达到预期，以为是自己不够坚持；立看书flag，比如去年24本，今年36本，用量来感动自己；因为看到书名不错或者他人正在热读而选择一本书，随意又无计划；从头看到尾，一字不落，认为这样才算读完一本书，读完就读完了…<br><strong>A2</strong>:今后我会改掉我以往的学习心态，不管是什么方式的学习（不会从此排拆培训，必要的培训可以去参加，但不盲目），一定是带着问题结合自己的现状、困惑点并以运用知识为导向来学习。从选书、阅读方式、纪录习惯三个方面改进</p>\n<ul>\n<li>选书：主读和生活、工作、个人发展上困惑的问题相关的书籍；</li>\n<li>阅读方式：先看目录，了解内容的构成，精读核心知识部分，泛读或者不读其它内容，不再追求从头到尾，一字不落；</li>\n<li>记录：用RIA法就书中的核心知识点做纪录，尝试写书评和总结，强化记忆及方便以后使用</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>这两天在看一本书叫做《这样读书就够了》，这本书是拆书帮的创始人赵周老师的作品。在此之前无数次听说过拆书帮，但赵周老师是第一次接触，因为我报名参加了3月16及17赵周老师的线下课程，学费不便宜，3288两天，我抱着质疑的态度去审视他的作品，想要去看看这是何方神圣，但却没想到在他的书本中，我受到了启发，对于自己一直以来的学习的方式、自己知识焦虑的一种反射，以及未来改进的方向。</p>\n<p>这本书的核心是讲RIA便签阅读法，书中通过分析现代大部分读书难及学习中的误区并结合大量古今中外的案例以及分析各种级别的学习者来介绍以下几个核心观点，RIA是什么、为什么RIA好？RIA如何运用？</p>\n<p>###RIA是什么、为什么RIA好</p>\n<ul>\n<li>有些人有知识焦虑，所以疯狂的参加各种培训和付费课程，花费无数，坚持与否或者效果好坏暂且不讨论；</li>\n<li>有些人看完一本书，最后合上书，却只能用“写得好”、“印象深刻”等空泛的词来作为结束语，然后就没有了然后；</li>\n<li>有些人喜欢追求干货，不看过程，只看结论；</li>\n<li>有些人立下flag，一年要看多少本书；</li>\n<li>有些人从头一字不落看到尾，认为这样才是对书的尊重；</li>\n<li>有些人遇到晦涩难懂的部分，因此就放弃了再拿起这本书；</li>\n</ul>\n<p>各种各样的万象都有，大家都在学习，都在获取新知，那造成人与人千差万别的本质是什么？是读书的方式吗？是读书的多少吗？懂得很多道理，为什么还是过不好这一生？知识真的是价格昂贵，不可获得的吗？为什么大家更愿意付更高昂的费用参加培训或者购买付费课程？</p>\n<blockquote>\n<p>图书=核心知识+书面表达<br>培训=核心知识+口头表达<br>培训=图书+I</p>\n</blockquote>\n<p>从上面的公式中我们可以看出知识其实并不贵，甚至是非常容易“获取”的，培训和书籍的差别在于I，那I是什么？I的能力我们是否可以自行习得？</p>\n<p><code>I（Interpretation）（引导促进）＝以自我为中心＋激活经验＋促动参与＋催化应用</code><br>有了I，学习者更容易理解知识、印象更深刻。（体验）<br>有了I，学习者将知识与自己的经验联系。（反思）</p>\n<p>有了反思和体验，从而我们才能更好的将这个知识拆我们所用A(<code>Appropriation</code>)</p>\n<p>所以RIA的本质是通过强化体验、反思总结并致用的过程。说白话点就是带着目的性以解决实际问题的方式去读书，并内化成自身知识体系。（这个和辉哥今早写的快速阅读的核心很像）</p>\n<h3 id=\"RIA如何运用\"><a href=\"#RIA如何运用\" class=\"headerlink\" title=\"RIA如何运用\"></a>RIA如何运用</h3><p>以阅读致用类图书为例，在阅读的过程中，准备三色标签，分别用来做3类笔记（I、A1，A2）</p>\n<blockquote>\n<p>I：用自己的语言重述知识<br>A1:描述自己的相关经验<br>A2:以后我怎样运用</p>\n</blockquote>\n<hr>\n<h3 id=\"try\"><a href=\"#try\" class=\"headerlink\" title=\"try\"></a>try</h3><p>看了这么久这本书的理论，那我也来试试用RIA法拆解我当下在读的《这样读书就够了》这本书<br><strong>I</strong>：学习的目的最终一定是学以致用，如何致用并不是口头一说，可通过以下方式来强化，那就是RIA的精髓：<em>用自己的语言复述知识；以往自己是如何做的；以后自己将打算怎么做</em><br><strong>A1</strong>:上面讲到的有些人，都有我的影子，热衷报课程、认为报了某某课程看了某某书自己就能脱胎换骨，最后效果没有达到预期，以为是自己不够坚持；立看书flag，比如去年24本，今年36本，用量来感动自己；因为看到书名不错或者他人正在热读而选择一本书，随意又无计划；从头看到尾，一字不落，认为这样才算读完一本书，读完就读完了…<br><strong>A2</strong>:今后我会改掉我以往的学习心态，不管是什么方式的学习（不会从此排拆培训，必要的培训可以去参加，但不盲目），一定是带着问题结合自己的现状、困惑点并以运用知识为导向来学习。从选书、阅读方式、纪录习惯三个方面改进</p>\n<ul>\n<li>选书：主读和生活、工作、个人发展上困惑的问题相关的书籍；</li>\n<li>阅读方式：先看目录，了解内容的构成，精读核心知识部分，泛读或者不读其它内容，不再追求从头到尾，一字不落；</li>\n<li>记录：用RIA法就书中的核心知识点做纪录，尝试写书评和总结，强化记忆及方便以后使用</li>\n</ul>\n"},{"title":"2018书单","date":"2019-01-01T01:50:03.000Z","summary":"2018年总共阅读了24本“闲书”，平均下来，一个月两本，两周一本。读一本好书，如同交了一个益友，盘点下今年交到的那些益友。（按阅读时间顺序记录）","_content":"\n**1.《时间的朋友》**\n*这本书是罗振宇老师2017年的跨年演讲的文字版。从企业发展到国家宏图、中国式思考、六个脑洞。最深刻的是类比机器学习，每个人都可以找到好的人生算法，不断重复迭代，直到得到最优的结果。**岁月不饶人，而我又何曾饶过岁月**。被罗胖胖的个人魅力所吸引，他那温暖但有力量的言语和高超的讲演水平吸引着我，会一直追随下去。*\n\n![时间的朋友](https://upload-images.jianshu.io/upload_images/8878545-78206c1a7260b10f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/120)\n推荐指数：🌟🌟🌟🌟\n\n**2.《小狗钱钱》**\n*通过童话故事的形式，讲述一个12岁小女孩领养的一只叫钱钱的狗，这是一只懂理财的狗，在钱钱的引领下，小主人了解了金钱和财富的秘密，以及理财和投资的方法。*\n\n![小狗钱钱](https://upload-images.jianshu.io/upload_images/8878545-a847b139f9d97c85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240)\n推荐指数：🌟🌟🌟\n\n**3.《我的人生我做主》**\n*简七理财系列很简短简单的一本书，有很多案例，适合小白阅读，40分钟的地铁时间就很快读完了，理财基础概念的入门书。*\n推荐指数：🌟🌟\n\n**4.《极简投资》**\n*简七系列的第二本，和上本一样，秉承简单清晰的概念，了解如何对资产进行几种相关性低的产品，分散风险，同时在一定的周期（半年/一年）重配，保证比例的稳定*\n推荐指数：🌟🌟\n\n**5.《简七-小白理财第一课》**\n*简七系列第三本，整体感觉同上。小白系列的入门书*\n推荐指数：🌟🌟\n\n**6.《跃迁》**\n*得到上的网红书，古典老师的作品。个人觉得书籍前半部分内容鲜明，理论感较强，但后半部分就有点水，让人怀疑是否出自同一个人之作。\n摘抄部分原文干货*\n>1.时代高手的特性——懂得如何驱动自己持续的努力和积累，也懂得借助社会和科技趋势放大自己努力的收益\n2.今天，知识可以从外面供给，注意力却必须内在拥有。如果你没有驯服注意力的能力，你的时间、思维会被完全打碎。\n3.高手就是在高价值领域，持续做正确动作的人。\n4.通过二八原则学习知识，利用系统平台红利，和最优秀的人联机，实现资源互换。\n\n![跃迁](https://upload-images.jianshu.io/upload_images/8878545-118b0f1d9fb47c1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240)\n推荐指数：🌟🌟🌟🌟\n\n**7.《知行合一王阳明》**\n*耗时12个小时读完了这本书，跟着作者一起，了解了王阳明一生的经历。从最初的怀才不遇，中途的仕途险恶，晚年的疾病缠身，领略一代伟人遇到任何问题坚持本心的毅力。\n>“无善无恶心之体，\n有善有恶意之动，\n知善知恶是良知，\n为善去恶是格物。”\n\n伟人的心学不是理念，是生存和解决问题的工具，值得我一生去学习和践行。这本书我会再二刷、多刷。*\n![知行合一王阳明](https://upload-images.jianshu.io/upload_images/8878545-40612c5945e5d0c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240)\n\n推荐指数：🌟🌟🌟🌟🌟\n\n**8.《见识》**\n*年初收到的赠书，拖到7月份才开始看,差点错失了一本好书。书中内容也是吴军老师摘自得到中大家最为关心的部分，如创业、职业生涯、人生本质及智慧、理性的投资观、风险意识等。相对于所有的外部资源及个人因素，个人的成就取决与你的“见识”*\n![《见识》](https://upload-images.jianshu.io/upload_images/8878545-b7d74a69c7d4094a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240)\n推荐指数：🌟🌟🌟🌟🌟\n**9.《小岛经济学》**\n*以一个荒岛上三个人的生活作为开端，阐述了经济是如何应运而生的。丰富的插图和故事，读起来还是挺有趣味的。但还是看得云里雾里，对故事以及背后的关联还没有形成一个基本的认知。导致现在合上书，完全无法概述书中的理论，但好在识别出这是一本好书，以后会经常拿出来翻阅。\n这本书的宣传语是：*\n>小岛经济学=经济学原理+经济学概论+国富论\n\n*这样看来，也就轻易的原谅了自己这个小白和知识的浅薄😊*\n![小岛经济学](https://upload-images.jianshu.io/upload_images/8878545-09afd54a528ab1dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240)\n推荐指数：🌟🌟🌟🌟🌟\n\n**10.《指数基金》**\n*“银行螺丝钉”的作品，雪球上的一个大V。\n指数基金，一个可以跑赢通货膨胀及70%以上的市场参与者。\n这个理念巴菲特老爷子及彼得.林奇也都多次在各种场合有提到过。*\n推荐指数：🌟🌟🌟\n\n**11.《硬派健身》**\n*一本健身先健脑的理论知识科普书，可以结合着运动一起理解可能会更深刻。\n获取到了很多新的理念：如人体的大肌群是胸、背、臀、腿，健身时把注意力放在局部位置而不是大肌群是一件事倍功半的事情;长时间慢跑或快走并非好的健身方式;节食是最不可取的；间歇性训练比长时间不间断训练效果更好等等*\n![《硬派健身》](https://upload-images.jianshu.io/upload_images/8878545-e1e37e549528652a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240)\n推荐指数：🌟🌟🌟\n\n**12.《论韭菜的自我修养》**\n*抛开今年7月网上曝光的录音事件导致的李笑来老师人设坍塌，以及此本书被众人吐槽是他个人的洗白之作，客观的讲，他对“韭菜”心理的研究是非常透彻的，书中有很多观点可以用与自我检视*\n> 韭菜行为一：在牛市进场，在熊市离场\n韭菜行为二：通过打探小道消息或他人推荐来决定交易的方向，而不是通过学习、独立思考和判断\n韭菜行为三：频繁交易\n韭菜行为四：一进场就把子弹用光\n韭菜行为五：忽略自我投资\n\n![《论韭菜的自我修养》](https://upload-images.jianshu.io/upload_images/8878545-4c719f47bd89e99a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240)\n推荐指数：🌟🌟🌟\n\n**13.《侣行1》**\n*此本书是二刷了，自从16年知道270和梁红，以及他们独特的游历方式，就深深的被他们吸引，他们的节目及书籍也是一部不落。侣行1是他们游历的开始，跟着270轻松幽默的笔触，知道了摩加迪沙-索马里——一个充满战火的国度；奥伊米亚康——世界上有人类居住的最冷的地方，最低温度达零下71摄氏度，在这里，270正式向梁红求婚；切尔诺贝利——历史上最严重的核电事故发生地，被魔鬼接管的区域。马鲁姆火山——成为中国火山探险第一人*\n推荐指数：🌟🌟🌟🌟\n\n**14.《侣行2》**\n*8月份270和梁红宣布这个系列暂停一段时间，想想以后再难从荧幕中看到这对夫妻坚韧的个性、爽朗的笑容、鼓舞人心的行径，心中着实有些不舍，又拿出这个系列刷了一遍。这次270带领几个小伙伴一起，从上海开着帆船一路来到南极，途径济州岛、洛杉矶、圣地亚哥等地来到南极，一路上经历千辛万苦，狂风暴雨，身体极限，最终在270这个精神领袖的带领下来到南极，并在这冰雪圣洁之地举行了婚礼，出席婚礼的除了一起同行的几个好友还有岛上的原住民——企鹅。在北极求婚，在南极结婚，这酷酷的行为真的很“270”*\n\n推荐指数：🌟🌟🌟🌟\n\n**15.《这些年，马云犯过的10个错误》**\n*吴晓波老师的作品，作为现在风口浪尖上的阿里和马云，和市面上一边倒的吹捧不同，本书还是较为客观的指出了阿里大国建成的过程中的一些问题，如当年办公室选址的错误、重用空降部队而忽略了外来物种在本土文化中生存的不适、对资金的运用存在形式主义、错误的收购了雅虎，形成现在鸡肋的局面等*\n推荐指数：🌟🌟🌟\n\n**16.《北方的空地》**\n*因为《七十七天》这部电影知道了这本书，书的作者杨柳松也是电影的原型，一个真正的汉子，以自力的方式孤身完成羌塘的穿越，历时77天，没有赞助、没有商业、没有炒作，仅仅是因为自己喜欢，就去了。*\n> 何为人生，何为看透，不过是一种妥协，不想再让脆弱心灵瞎折腾。把握短暂的一生，便是对自己生命最大的追问。\n\n![《北方的空地》](https://upload-images.jianshu.io/upload_images/8878545-249cdc9bc106abaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240)\n推荐指数：🌟🌟🌟🌟\n\n**17.《吃掉那只青蛙》**\n*一本GTD的工具书。每天吃3只“青蛙”——即生活工作中那些重要棘手且高价值区间的事情。和时间管理四象限中的理论不谋而合，从短期讲，将主要精力放在重要且紧急的事情上，从长期讲，讲主要精力放在重要不紧急的事情上。*\n![吃掉那只青蛙](https://upload-images.jianshu.io/upload_images/8878545-b279915ff0e7f565.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240)\n推荐指数：🌟🌟🌟🌟\n\n**18.《微习惯》**\n*微习惯是习惯的儿子！\n本书讲述了为什么微习惯重要？为什么意志力不可靠？如何养成微习惯？\n有点啰嗦，但整体理念还是不错，值得践行*\n![《微习惯》](https://upload-images.jianshu.io/upload_images/8878545-788235cd28526e03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240)\n推荐指数：🌟🌟🌟🌟\n\n**19.《秘密》**\n*东野圭吾先生的小说，真是一部高产的小说家。看他的书很放松且有种想要一口气读完的吸引力，历时4个小时的地铁时间读完。和他其它以往的作品不同，没有历险，没有谋杀，没有悬疑或推理，就是一个普通中年老人絮絮叨叨的生活小事，却不时又透露出人性的多面性。*\n![《秘密》](https://upload-images.jianshu.io/upload_images/8878545-761a5f2bc00ff72a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240)\n\n推荐指数：🌟🌟🌟\n\n**20.《半小时漫画中国史 1、2、3》**\n*非常适合低龄儿童或者我这种对历史一无所知的人的阅读。虽说是半小时，但这1、2、3部读完却花了5个小时左右，整体来讲，朗朗上口，一气呵成，诙谐幽默，在傻笑中看完，历史原来如此有趣，这么多活灵活现的历史人物和事迹，真真是意犹未尽，期待后续的4。*\n![半小时漫画中国史](https://upload-images.jianshu.io/upload_images/8878545-d99a7f96744fb98c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240)\n推荐指数：🌟🌟🌟🌟🌟\n\n**21.《半小时漫画世界史 》**\n*这本书主要描述了欧洲史，包括希腊和罗马的时代，黑暗的中世纪等，还有斯巴达300勇士。除此之外，也写了美国和日本的一些事情。一本还算不错的科普书*\n![半小时漫画世界史](https://upload-images.jianshu.io/upload_images/8878545-f651cbb2fed9a7ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240)\n推荐指数：🌟🌟🌟🌟\n\n22.《撒哈拉的故事》\n*三毛的生活，并不是刻意的多姿多彩，而是她用心感受生活，喜欢生活。我觉得三毛是一个很会生活的人，她也有情绪，但她的教养让她得到西班牙人或者沙哈拉威人、甚至如荷西上司那样的欧洲人的尊重，一个善待自己的人才会即使面对变幻莫测的撒哈拉，把坟场搬的家装点成撒哈拉王国，过着诗一般的生活*\n![image.png](https://upload-images.jianshu.io/upload_images/8878545-a534698f60df7ec5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n推荐指数：🌟🌟🌟🌟🌟\n\n23.《稻草人手记》\n*看完撒哈拉的故事，迷上了三毛的文字，于是又翻出了这本继续阅读。简简单单的文字记录了生活中的点点滴滴，似乎都是小事，但是似乎又都是不平凡的大事。这就是这本书给我的整体感觉。*\n![image.png](https://upload-images.jianshu.io/upload_images/8878545-b153ae6701d09b18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240)\n\n推荐指数：🌟🌟🌟🌟\n\n24.《温柔的夜》\n*延续她一贯的行文风格，讲述她在加纳利群岛上的生活。不得不再次感叹，这真是一个不平凡的女子，生命中有种简单的璀璨。*\n![温柔的夜](https://upload-images.jianshu.io/upload_images/8878545-9f11297265baff4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240)\n推荐指数：🌟🌟🌟🌟","source":"_posts/2018-read-book.md","raw":"---\ntitle: 2018书单\ndate: 2019-01-01 09:50:03\ntags: [读书,feelings]\nsummary: 2018年总共阅读了24本“闲书”，平均下来，一个月两本，两周一本。读一本好书，如同交了一个益友，盘点下今年交到的那些益友。（按阅读时间顺序记录）\n\n---\n\n**1.《时间的朋友》**\n*这本书是罗振宇老师2017年的跨年演讲的文字版。从企业发展到国家宏图、中国式思考、六个脑洞。最深刻的是类比机器学习，每个人都可以找到好的人生算法，不断重复迭代，直到得到最优的结果。**岁月不饶人，而我又何曾饶过岁月**。被罗胖胖的个人魅力所吸引，他那温暖但有力量的言语和高超的讲演水平吸引着我，会一直追随下去。*\n\n![时间的朋友](https://upload-images.jianshu.io/upload_images/8878545-78206c1a7260b10f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/120)\n推荐指数：🌟🌟🌟🌟\n\n**2.《小狗钱钱》**\n*通过童话故事的形式，讲述一个12岁小女孩领养的一只叫钱钱的狗，这是一只懂理财的狗，在钱钱的引领下，小主人了解了金钱和财富的秘密，以及理财和投资的方法。*\n\n![小狗钱钱](https://upload-images.jianshu.io/upload_images/8878545-a847b139f9d97c85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240)\n推荐指数：🌟🌟🌟\n\n**3.《我的人生我做主》**\n*简七理财系列很简短简单的一本书，有很多案例，适合小白阅读，40分钟的地铁时间就很快读完了，理财基础概念的入门书。*\n推荐指数：🌟🌟\n\n**4.《极简投资》**\n*简七系列的第二本，和上本一样，秉承简单清晰的概念，了解如何对资产进行几种相关性低的产品，分散风险，同时在一定的周期（半年/一年）重配，保证比例的稳定*\n推荐指数：🌟🌟\n\n**5.《简七-小白理财第一课》**\n*简七系列第三本，整体感觉同上。小白系列的入门书*\n推荐指数：🌟🌟\n\n**6.《跃迁》**\n*得到上的网红书，古典老师的作品。个人觉得书籍前半部分内容鲜明，理论感较强，但后半部分就有点水，让人怀疑是否出自同一个人之作。\n摘抄部分原文干货*\n>1.时代高手的特性——懂得如何驱动自己持续的努力和积累，也懂得借助社会和科技趋势放大自己努力的收益\n2.今天，知识可以从外面供给，注意力却必须内在拥有。如果你没有驯服注意力的能力，你的时间、思维会被完全打碎。\n3.高手就是在高价值领域，持续做正确动作的人。\n4.通过二八原则学习知识，利用系统平台红利，和最优秀的人联机，实现资源互换。\n\n![跃迁](https://upload-images.jianshu.io/upload_images/8878545-118b0f1d9fb47c1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240)\n推荐指数：🌟🌟🌟🌟\n\n**7.《知行合一王阳明》**\n*耗时12个小时读完了这本书，跟着作者一起，了解了王阳明一生的经历。从最初的怀才不遇，中途的仕途险恶，晚年的疾病缠身，领略一代伟人遇到任何问题坚持本心的毅力。\n>“无善无恶心之体，\n有善有恶意之动，\n知善知恶是良知，\n为善去恶是格物。”\n\n伟人的心学不是理念，是生存和解决问题的工具，值得我一生去学习和践行。这本书我会再二刷、多刷。*\n![知行合一王阳明](https://upload-images.jianshu.io/upload_images/8878545-40612c5945e5d0c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240)\n\n推荐指数：🌟🌟🌟🌟🌟\n\n**8.《见识》**\n*年初收到的赠书，拖到7月份才开始看,差点错失了一本好书。书中内容也是吴军老师摘自得到中大家最为关心的部分，如创业、职业生涯、人生本质及智慧、理性的投资观、风险意识等。相对于所有的外部资源及个人因素，个人的成就取决与你的“见识”*\n![《见识》](https://upload-images.jianshu.io/upload_images/8878545-b7d74a69c7d4094a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240)\n推荐指数：🌟🌟🌟🌟🌟\n**9.《小岛经济学》**\n*以一个荒岛上三个人的生活作为开端，阐述了经济是如何应运而生的。丰富的插图和故事，读起来还是挺有趣味的。但还是看得云里雾里，对故事以及背后的关联还没有形成一个基本的认知。导致现在合上书，完全无法概述书中的理论，但好在识别出这是一本好书，以后会经常拿出来翻阅。\n这本书的宣传语是：*\n>小岛经济学=经济学原理+经济学概论+国富论\n\n*这样看来，也就轻易的原谅了自己这个小白和知识的浅薄😊*\n![小岛经济学](https://upload-images.jianshu.io/upload_images/8878545-09afd54a528ab1dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240)\n推荐指数：🌟🌟🌟🌟🌟\n\n**10.《指数基金》**\n*“银行螺丝钉”的作品，雪球上的一个大V。\n指数基金，一个可以跑赢通货膨胀及70%以上的市场参与者。\n这个理念巴菲特老爷子及彼得.林奇也都多次在各种场合有提到过。*\n推荐指数：🌟🌟🌟\n\n**11.《硬派健身》**\n*一本健身先健脑的理论知识科普书，可以结合着运动一起理解可能会更深刻。\n获取到了很多新的理念：如人体的大肌群是胸、背、臀、腿，健身时把注意力放在局部位置而不是大肌群是一件事倍功半的事情;长时间慢跑或快走并非好的健身方式;节食是最不可取的；间歇性训练比长时间不间断训练效果更好等等*\n![《硬派健身》](https://upload-images.jianshu.io/upload_images/8878545-e1e37e549528652a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240)\n推荐指数：🌟🌟🌟\n\n**12.《论韭菜的自我修养》**\n*抛开今年7月网上曝光的录音事件导致的李笑来老师人设坍塌，以及此本书被众人吐槽是他个人的洗白之作，客观的讲，他对“韭菜”心理的研究是非常透彻的，书中有很多观点可以用与自我检视*\n> 韭菜行为一：在牛市进场，在熊市离场\n韭菜行为二：通过打探小道消息或他人推荐来决定交易的方向，而不是通过学习、独立思考和判断\n韭菜行为三：频繁交易\n韭菜行为四：一进场就把子弹用光\n韭菜行为五：忽略自我投资\n\n![《论韭菜的自我修养》](https://upload-images.jianshu.io/upload_images/8878545-4c719f47bd89e99a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240)\n推荐指数：🌟🌟🌟\n\n**13.《侣行1》**\n*此本书是二刷了，自从16年知道270和梁红，以及他们独特的游历方式，就深深的被他们吸引，他们的节目及书籍也是一部不落。侣行1是他们游历的开始，跟着270轻松幽默的笔触，知道了摩加迪沙-索马里——一个充满战火的国度；奥伊米亚康——世界上有人类居住的最冷的地方，最低温度达零下71摄氏度，在这里，270正式向梁红求婚；切尔诺贝利——历史上最严重的核电事故发生地，被魔鬼接管的区域。马鲁姆火山——成为中国火山探险第一人*\n推荐指数：🌟🌟🌟🌟\n\n**14.《侣行2》**\n*8月份270和梁红宣布这个系列暂停一段时间，想想以后再难从荧幕中看到这对夫妻坚韧的个性、爽朗的笑容、鼓舞人心的行径，心中着实有些不舍，又拿出这个系列刷了一遍。这次270带领几个小伙伴一起，从上海开着帆船一路来到南极，途径济州岛、洛杉矶、圣地亚哥等地来到南极，一路上经历千辛万苦，狂风暴雨，身体极限，最终在270这个精神领袖的带领下来到南极，并在这冰雪圣洁之地举行了婚礼，出席婚礼的除了一起同行的几个好友还有岛上的原住民——企鹅。在北极求婚，在南极结婚，这酷酷的行为真的很“270”*\n\n推荐指数：🌟🌟🌟🌟\n\n**15.《这些年，马云犯过的10个错误》**\n*吴晓波老师的作品，作为现在风口浪尖上的阿里和马云，和市面上一边倒的吹捧不同，本书还是较为客观的指出了阿里大国建成的过程中的一些问题，如当年办公室选址的错误、重用空降部队而忽略了外来物种在本土文化中生存的不适、对资金的运用存在形式主义、错误的收购了雅虎，形成现在鸡肋的局面等*\n推荐指数：🌟🌟🌟\n\n**16.《北方的空地》**\n*因为《七十七天》这部电影知道了这本书，书的作者杨柳松也是电影的原型，一个真正的汉子，以自力的方式孤身完成羌塘的穿越，历时77天，没有赞助、没有商业、没有炒作，仅仅是因为自己喜欢，就去了。*\n> 何为人生，何为看透，不过是一种妥协，不想再让脆弱心灵瞎折腾。把握短暂的一生，便是对自己生命最大的追问。\n\n![《北方的空地》](https://upload-images.jianshu.io/upload_images/8878545-249cdc9bc106abaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240)\n推荐指数：🌟🌟🌟🌟\n\n**17.《吃掉那只青蛙》**\n*一本GTD的工具书。每天吃3只“青蛙”——即生活工作中那些重要棘手且高价值区间的事情。和时间管理四象限中的理论不谋而合，从短期讲，将主要精力放在重要且紧急的事情上，从长期讲，讲主要精力放在重要不紧急的事情上。*\n![吃掉那只青蛙](https://upload-images.jianshu.io/upload_images/8878545-b279915ff0e7f565.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240)\n推荐指数：🌟🌟🌟🌟\n\n**18.《微习惯》**\n*微习惯是习惯的儿子！\n本书讲述了为什么微习惯重要？为什么意志力不可靠？如何养成微习惯？\n有点啰嗦，但整体理念还是不错，值得践行*\n![《微习惯》](https://upload-images.jianshu.io/upload_images/8878545-788235cd28526e03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240)\n推荐指数：🌟🌟🌟🌟\n\n**19.《秘密》**\n*东野圭吾先生的小说，真是一部高产的小说家。看他的书很放松且有种想要一口气读完的吸引力，历时4个小时的地铁时间读完。和他其它以往的作品不同，没有历险，没有谋杀，没有悬疑或推理，就是一个普通中年老人絮絮叨叨的生活小事，却不时又透露出人性的多面性。*\n![《秘密》](https://upload-images.jianshu.io/upload_images/8878545-761a5f2bc00ff72a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240)\n\n推荐指数：🌟🌟🌟\n\n**20.《半小时漫画中国史 1、2、3》**\n*非常适合低龄儿童或者我这种对历史一无所知的人的阅读。虽说是半小时，但这1、2、3部读完却花了5个小时左右，整体来讲，朗朗上口，一气呵成，诙谐幽默，在傻笑中看完，历史原来如此有趣，这么多活灵活现的历史人物和事迹，真真是意犹未尽，期待后续的4。*\n![半小时漫画中国史](https://upload-images.jianshu.io/upload_images/8878545-d99a7f96744fb98c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240)\n推荐指数：🌟🌟🌟🌟🌟\n\n**21.《半小时漫画世界史 》**\n*这本书主要描述了欧洲史，包括希腊和罗马的时代，黑暗的中世纪等，还有斯巴达300勇士。除此之外，也写了美国和日本的一些事情。一本还算不错的科普书*\n![半小时漫画世界史](https://upload-images.jianshu.io/upload_images/8878545-f651cbb2fed9a7ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240)\n推荐指数：🌟🌟🌟🌟\n\n22.《撒哈拉的故事》\n*三毛的生活，并不是刻意的多姿多彩，而是她用心感受生活，喜欢生活。我觉得三毛是一个很会生活的人，她也有情绪，但她的教养让她得到西班牙人或者沙哈拉威人、甚至如荷西上司那样的欧洲人的尊重，一个善待自己的人才会即使面对变幻莫测的撒哈拉，把坟场搬的家装点成撒哈拉王国，过着诗一般的生活*\n![image.png](https://upload-images.jianshu.io/upload_images/8878545-a534698f60df7ec5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n推荐指数：🌟🌟🌟🌟🌟\n\n23.《稻草人手记》\n*看完撒哈拉的故事，迷上了三毛的文字，于是又翻出了这本继续阅读。简简单单的文字记录了生活中的点点滴滴，似乎都是小事，但是似乎又都是不平凡的大事。这就是这本书给我的整体感觉。*\n![image.png](https://upload-images.jianshu.io/upload_images/8878545-b153ae6701d09b18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240)\n\n推荐指数：🌟🌟🌟🌟\n\n24.《温柔的夜》\n*延续她一贯的行文风格，讲述她在加纳利群岛上的生活。不得不再次感叹，这真是一个不平凡的女子，生命中有种简单的璀璨。*\n![温柔的夜](https://upload-images.jianshu.io/upload_images/8878545-9f11297265baff4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240)\n推荐指数：🌟🌟🌟🌟","slug":"2018-read-book","published":1,"updated":"2019-04-11T02:01:24.473Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2mo4myc0019dt47tfxoxkly","content":"<p><strong>1.《时间的朋友》</strong><br><em>这本书是罗振宇老师2017年的跨年演讲的文字版。从企业发展到国家宏图、中国式思考、六个脑洞。最深刻的是类比机器学习，每个人都可以找到好的人生算法，不断重复迭代，直到得到最优的结果。<strong>岁月不饶人，而我又何曾饶过岁月</strong>。被罗胖胖的个人魅力所吸引，他那温暖但有力量的言语和高超的讲演水平吸引着我，会一直追随下去。</em></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8878545-78206c1a7260b10f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/120\" alt=\"时间的朋友\"><br>推荐指数：🌟🌟🌟🌟</p>\n<p><strong>2.《小狗钱钱》</strong><br><em>通过童话故事的形式，讲述一个12岁小女孩领养的一只叫钱钱的狗，这是一只懂理财的狗，在钱钱的引领下，小主人了解了金钱和财富的秘密，以及理财和投资的方法。</em></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8878545-a847b139f9d97c85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240\" alt=\"小狗钱钱\"><br>推荐指数：🌟🌟🌟</p>\n<p><strong>3.《我的人生我做主》</strong><br><em>简七理财系列很简短简单的一本书，有很多案例，适合小白阅读，40分钟的地铁时间就很快读完了，理财基础概念的入门书。</em><br>推荐指数：🌟🌟</p>\n<p><strong>4.《极简投资》</strong><br><em>简七系列的第二本，和上本一样，秉承简单清晰的概念，了解如何对资产进行几种相关性低的产品，分散风险，同时在一定的周期（半年/一年）重配，保证比例的稳定</em><br>推荐指数：🌟🌟</p>\n<p><strong>5.《简七-小白理财第一课》</strong><br><em>简七系列第三本，整体感觉同上。小白系列的入门书</em><br>推荐指数：🌟🌟</p>\n<p><strong>6.《跃迁》</strong><br><em>得到上的网红书，古典老师的作品。个人觉得书籍前半部分内容鲜明，理论感较强，但后半部分就有点水，让人怀疑是否出自同一个人之作。<br>摘抄部分原文干货</em></p>\n<blockquote>\n<p>1.时代高手的特性——懂得如何驱动自己持续的努力和积累，也懂得借助社会和科技趋势放大自己努力的收益<br>2.今天，知识可以从外面供给，注意力却必须内在拥有。如果你没有驯服注意力的能力，你的时间、思维会被完全打碎。<br>3.高手就是在高价值领域，持续做正确动作的人。<br>4.通过二八原则学习知识，利用系统平台红利，和最优秀的人联机，实现资源互换。</p>\n</blockquote>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8878545-118b0f1d9fb47c1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240\" alt=\"跃迁\"><br>推荐指数：🌟🌟🌟🌟</p>\n<p><strong>7.《知行合一王阳明》</strong><br>*耗时12个小时读完了这本书，跟着作者一起，了解了王阳明一生的经历。从最初的怀才不遇，中途的仕途险恶，晚年的疾病缠身，领略一代伟人遇到任何问题坚持本心的毅力。</p>\n<blockquote>\n<p>“无善无恶心之体，<br>有善有恶意之动，<br>知善知恶是良知，<br>为善去恶是格物。”</p>\n</blockquote>\n<p>伟人的心学不是理念，是生存和解决问题的工具，值得我一生去学习和践行。这本书我会再二刷、多刷。*<br><img src=\"https://upload-images.jianshu.io/upload_images/8878545-40612c5945e5d0c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240\" alt=\"知行合一王阳明\"></p>\n<p>推荐指数：🌟🌟🌟🌟🌟</p>\n<p><strong>8.《见识》</strong><br><em>年初收到的赠书，拖到7月份才开始看,差点错失了一本好书。书中内容也是吴军老师摘自得到中大家最为关心的部分，如创业、职业生涯、人生本质及智慧、理性的投资观、风险意识等。相对于所有的外部资源及个人因素，个人的成就取决与你的“见识”</em><br><img src=\"https://upload-images.jianshu.io/upload_images/8878545-b7d74a69c7d4094a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240\" alt=\"《见识》\"><br>推荐指数：🌟🌟🌟🌟🌟<br><strong>9.《小岛经济学》</strong><br><em>以一个荒岛上三个人的生活作为开端，阐述了经济是如何应运而生的。丰富的插图和故事，读起来还是挺有趣味的。但还是看得云里雾里，对故事以及背后的关联还没有形成一个基本的认知。导致现在合上书，完全无法概述书中的理论，但好在识别出这是一本好书，以后会经常拿出来翻阅。<br>这本书的宣传语是：</em></p>\n<blockquote>\n<p>小岛经济学=经济学原理+经济学概论+国富论</p>\n</blockquote>\n<p><em>这样看来，也就轻易的原谅了自己这个小白和知识的浅薄😊</em><br><img src=\"https://upload-images.jianshu.io/upload_images/8878545-09afd54a528ab1dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240\" alt=\"小岛经济学\"><br>推荐指数：🌟🌟🌟🌟🌟</p>\n<p><strong>10.《指数基金》</strong><br><em>“银行螺丝钉”的作品，雪球上的一个大V。<br>指数基金，一个可以跑赢通货膨胀及70%以上的市场参与者。<br>这个理念巴菲特老爷子及彼得.林奇也都多次在各种场合有提到过。</em><br>推荐指数：🌟🌟🌟</p>\n<p><strong>11.《硬派健身》</strong><br><em>一本健身先健脑的理论知识科普书，可以结合着运动一起理解可能会更深刻。<br>获取到了很多新的理念：如人体的大肌群是胸、背、臀、腿，健身时把注意力放在局部位置而不是大肌群是一件事倍功半的事情;长时间慢跑或快走并非好的健身方式;节食是最不可取的；间歇性训练比长时间不间断训练效果更好等等</em><br><img src=\"https://upload-images.jianshu.io/upload_images/8878545-e1e37e549528652a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240\" alt=\"《硬派健身》\"><br>推荐指数：🌟🌟🌟</p>\n<p><strong>12.《论韭菜的自我修养》</strong><br><em>抛开今年7月网上曝光的录音事件导致的李笑来老师人设坍塌，以及此本书被众人吐槽是他个人的洗白之作，客观的讲，他对“韭菜”心理的研究是非常透彻的，书中有很多观点可以用与自我检视</em></p>\n<blockquote>\n<p>韭菜行为一：在牛市进场，在熊市离场<br>韭菜行为二：通过打探小道消息或他人推荐来决定交易的方向，而不是通过学习、独立思考和判断<br>韭菜行为三：频繁交易<br>韭菜行为四：一进场就把子弹用光<br>韭菜行为五：忽略自我投资</p>\n</blockquote>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8878545-4c719f47bd89e99a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240\" alt=\"《论韭菜的自我修养》\"><br>推荐指数：🌟🌟🌟</p>\n<p><strong>13.《侣行1》</strong><br><em>此本书是二刷了，自从16年知道270和梁红，以及他们独特的游历方式，就深深的被他们吸引，他们的节目及书籍也是一部不落。侣行1是他们游历的开始，跟着270轻松幽默的笔触，知道了摩加迪沙-索马里——一个充满战火的国度；奥伊米亚康——世界上有人类居住的最冷的地方，最低温度达零下71摄氏度，在这里，270正式向梁红求婚；切尔诺贝利——历史上最严重的核电事故发生地，被魔鬼接管的区域。马鲁姆火山——成为中国火山探险第一人</em><br>推荐指数：🌟🌟🌟🌟</p>\n<p><strong>14.《侣行2》</strong><br><em>8月份270和梁红宣布这个系列暂停一段时间，想想以后再难从荧幕中看到这对夫妻坚韧的个性、爽朗的笑容、鼓舞人心的行径，心中着实有些不舍，又拿出这个系列刷了一遍。这次270带领几个小伙伴一起，从上海开着帆船一路来到南极，途径济州岛、洛杉矶、圣地亚哥等地来到南极，一路上经历千辛万苦，狂风暴雨，身体极限，最终在270这个精神领袖的带领下来到南极，并在这冰雪圣洁之地举行了婚礼，出席婚礼的除了一起同行的几个好友还有岛上的原住民——企鹅。在北极求婚，在南极结婚，这酷酷的行为真的很“270”</em></p>\n<p>推荐指数：🌟🌟🌟🌟</p>\n<p><strong>15.《这些年，马云犯过的10个错误》</strong><br><em>吴晓波老师的作品，作为现在风口浪尖上的阿里和马云，和市面上一边倒的吹捧不同，本书还是较为客观的指出了阿里大国建成的过程中的一些问题，如当年办公室选址的错误、重用空降部队而忽略了外来物种在本土文化中生存的不适、对资金的运用存在形式主义、错误的收购了雅虎，形成现在鸡肋的局面等</em><br>推荐指数：🌟🌟🌟</p>\n<p><strong>16.《北方的空地》</strong><br><em>因为《七十七天》这部电影知道了这本书，书的作者杨柳松也是电影的原型，一个真正的汉子，以自力的方式孤身完成羌塘的穿越，历时77天，没有赞助、没有商业、没有炒作，仅仅是因为自己喜欢，就去了。</em></p>\n<blockquote>\n<p>何为人生，何为看透，不过是一种妥协，不想再让脆弱心灵瞎折腾。把握短暂的一生，便是对自己生命最大的追问。</p>\n</blockquote>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8878545-249cdc9bc106abaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240\" alt=\"《北方的空地》\"><br>推荐指数：🌟🌟🌟🌟</p>\n<p><strong>17.《吃掉那只青蛙》</strong><br><em>一本GTD的工具书。每天吃3只“青蛙”——即生活工作中那些重要棘手且高价值区间的事情。和时间管理四象限中的理论不谋而合，从短期讲，将主要精力放在重要且紧急的事情上，从长期讲，讲主要精力放在重要不紧急的事情上。</em><br><img src=\"https://upload-images.jianshu.io/upload_images/8878545-b279915ff0e7f565.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240\" alt=\"吃掉那只青蛙\"><br>推荐指数：🌟🌟🌟🌟</p>\n<p><strong>18.《微习惯》</strong><br><em>微习惯是习惯的儿子！<br>本书讲述了为什么微习惯重要？为什么意志力不可靠？如何养成微习惯？<br>有点啰嗦，但整体理念还是不错，值得践行</em><br><img src=\"https://upload-images.jianshu.io/upload_images/8878545-788235cd28526e03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240\" alt=\"《微习惯》\"><br>推荐指数：🌟🌟🌟🌟</p>\n<p><strong>19.《秘密》</strong><br><em>东野圭吾先生的小说，真是一部高产的小说家。看他的书很放松且有种想要一口气读完的吸引力，历时4个小时的地铁时间读完。和他其它以往的作品不同，没有历险，没有谋杀，没有悬疑或推理，就是一个普通中年老人絮絮叨叨的生活小事，却不时又透露出人性的多面性。</em><br><img src=\"https://upload-images.jianshu.io/upload_images/8878545-761a5f2bc00ff72a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240\" alt=\"《秘密》\"></p>\n<p>推荐指数：🌟🌟🌟</p>\n<p><strong>20.《半小时漫画中国史 1、2、3》</strong><br><em>非常适合低龄儿童或者我这种对历史一无所知的人的阅读。虽说是半小时，但这1、2、3部读完却花了5个小时左右，整体来讲，朗朗上口，一气呵成，诙谐幽默，在傻笑中看完，历史原来如此有趣，这么多活灵活现的历史人物和事迹，真真是意犹未尽，期待后续的4。</em><br><img src=\"https://upload-images.jianshu.io/upload_images/8878545-d99a7f96744fb98c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240\" alt=\"半小时漫画中国史\"><br>推荐指数：🌟🌟🌟🌟🌟</p>\n<p><strong>21.《半小时漫画世界史 》</strong><br><em>这本书主要描述了欧洲史，包括希腊和罗马的时代，黑暗的中世纪等，还有斯巴达300勇士。除此之外，也写了美国和日本的一些事情。一本还算不错的科普书</em><br><img src=\"https://upload-images.jianshu.io/upload_images/8878545-f651cbb2fed9a7ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240\" alt=\"半小时漫画世界史\"><br>推荐指数：🌟🌟🌟🌟</p>\n<p>22.《撒哈拉的故事》<br><em>三毛的生活，并不是刻意的多姿多彩，而是她用心感受生活，喜欢生活。我觉得三毛是一个很会生活的人，她也有情绪，但她的教养让她得到西班牙人或者沙哈拉威人、甚至如荷西上司那样的欧洲人的尊重，一个善待自己的人才会即使面对变幻莫测的撒哈拉，把坟场搬的家装点成撒哈拉王国，过着诗一般的生活</em><br><img src=\"https://upload-images.jianshu.io/upload_images/8878545-a534698f60df7ec5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br>推荐指数：🌟🌟🌟🌟🌟</p>\n<p>23.《稻草人手记》<br><em>看完撒哈拉的故事，迷上了三毛的文字，于是又翻出了这本继续阅读。简简单单的文字记录了生活中的点点滴滴，似乎都是小事，但是似乎又都是不平凡的大事。这就是这本书给我的整体感觉。</em><br><img src=\"https://upload-images.jianshu.io/upload_images/8878545-b153ae6701d09b18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240\" alt=\"image.png\"></p>\n<p>推荐指数：🌟🌟🌟🌟</p>\n<p>24.《温柔的夜》<br><em>延续她一贯的行文风格，讲述她在加纳利群岛上的生活。不得不再次感叹，这真是一个不平凡的女子，生命中有种简单的璀璨。</em><br><img src=\"https://upload-images.jianshu.io/upload_images/8878545-9f11297265baff4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240\" alt=\"温柔的夜\"><br>推荐指数：🌟🌟🌟🌟</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>1.《时间的朋友》</strong><br><em>这本书是罗振宇老师2017年的跨年演讲的文字版。从企业发展到国家宏图、中国式思考、六个脑洞。最深刻的是类比机器学习，每个人都可以找到好的人生算法，不断重复迭代，直到得到最优的结果。<strong>岁月不饶人，而我又何曾饶过岁月</strong>。被罗胖胖的个人魅力所吸引，他那温暖但有力量的言语和高超的讲演水平吸引着我，会一直追随下去。</em></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8878545-78206c1a7260b10f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/120\" alt=\"时间的朋友\"><br>推荐指数：🌟🌟🌟🌟</p>\n<p><strong>2.《小狗钱钱》</strong><br><em>通过童话故事的形式，讲述一个12岁小女孩领养的一只叫钱钱的狗，这是一只懂理财的狗，在钱钱的引领下，小主人了解了金钱和财富的秘密，以及理财和投资的方法。</em></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8878545-a847b139f9d97c85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240\" alt=\"小狗钱钱\"><br>推荐指数：🌟🌟🌟</p>\n<p><strong>3.《我的人生我做主》</strong><br><em>简七理财系列很简短简单的一本书，有很多案例，适合小白阅读，40分钟的地铁时间就很快读完了，理财基础概念的入门书。</em><br>推荐指数：🌟🌟</p>\n<p><strong>4.《极简投资》</strong><br><em>简七系列的第二本，和上本一样，秉承简单清晰的概念，了解如何对资产进行几种相关性低的产品，分散风险，同时在一定的周期（半年/一年）重配，保证比例的稳定</em><br>推荐指数：🌟🌟</p>\n<p><strong>5.《简七-小白理财第一课》</strong><br><em>简七系列第三本，整体感觉同上。小白系列的入门书</em><br>推荐指数：🌟🌟</p>\n<p><strong>6.《跃迁》</strong><br><em>得到上的网红书，古典老师的作品。个人觉得书籍前半部分内容鲜明，理论感较强，但后半部分就有点水，让人怀疑是否出自同一个人之作。<br>摘抄部分原文干货</em></p>\n<blockquote>\n<p>1.时代高手的特性——懂得如何驱动自己持续的努力和积累，也懂得借助社会和科技趋势放大自己努力的收益<br>2.今天，知识可以从外面供给，注意力却必须内在拥有。如果你没有驯服注意力的能力，你的时间、思维会被完全打碎。<br>3.高手就是在高价值领域，持续做正确动作的人。<br>4.通过二八原则学习知识，利用系统平台红利，和最优秀的人联机，实现资源互换。</p>\n</blockquote>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8878545-118b0f1d9fb47c1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240\" alt=\"跃迁\"><br>推荐指数：🌟🌟🌟🌟</p>\n<p><strong>7.《知行合一王阳明》</strong><br>*耗时12个小时读完了这本书，跟着作者一起，了解了王阳明一生的经历。从最初的怀才不遇，中途的仕途险恶，晚年的疾病缠身，领略一代伟人遇到任何问题坚持本心的毅力。</p>\n<blockquote>\n<p>“无善无恶心之体，<br>有善有恶意之动，<br>知善知恶是良知，<br>为善去恶是格物。”</p>\n</blockquote>\n<p>伟人的心学不是理念，是生存和解决问题的工具，值得我一生去学习和践行。这本书我会再二刷、多刷。*<br><img src=\"https://upload-images.jianshu.io/upload_images/8878545-40612c5945e5d0c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240\" alt=\"知行合一王阳明\"></p>\n<p>推荐指数：🌟🌟🌟🌟🌟</p>\n<p><strong>8.《见识》</strong><br><em>年初收到的赠书，拖到7月份才开始看,差点错失了一本好书。书中内容也是吴军老师摘自得到中大家最为关心的部分，如创业、职业生涯、人生本质及智慧、理性的投资观、风险意识等。相对于所有的外部资源及个人因素，个人的成就取决与你的“见识”</em><br><img src=\"https://upload-images.jianshu.io/upload_images/8878545-b7d74a69c7d4094a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240\" alt=\"《见识》\"><br>推荐指数：🌟🌟🌟🌟🌟<br><strong>9.《小岛经济学》</strong><br><em>以一个荒岛上三个人的生活作为开端，阐述了经济是如何应运而生的。丰富的插图和故事，读起来还是挺有趣味的。但还是看得云里雾里，对故事以及背后的关联还没有形成一个基本的认知。导致现在合上书，完全无法概述书中的理论，但好在识别出这是一本好书，以后会经常拿出来翻阅。<br>这本书的宣传语是：</em></p>\n<blockquote>\n<p>小岛经济学=经济学原理+经济学概论+国富论</p>\n</blockquote>\n<p><em>这样看来，也就轻易的原谅了自己这个小白和知识的浅薄😊</em><br><img src=\"https://upload-images.jianshu.io/upload_images/8878545-09afd54a528ab1dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240\" alt=\"小岛经济学\"><br>推荐指数：🌟🌟🌟🌟🌟</p>\n<p><strong>10.《指数基金》</strong><br><em>“银行螺丝钉”的作品，雪球上的一个大V。<br>指数基金，一个可以跑赢通货膨胀及70%以上的市场参与者。<br>这个理念巴菲特老爷子及彼得.林奇也都多次在各种场合有提到过。</em><br>推荐指数：🌟🌟🌟</p>\n<p><strong>11.《硬派健身》</strong><br><em>一本健身先健脑的理论知识科普书，可以结合着运动一起理解可能会更深刻。<br>获取到了很多新的理念：如人体的大肌群是胸、背、臀、腿，健身时把注意力放在局部位置而不是大肌群是一件事倍功半的事情;长时间慢跑或快走并非好的健身方式;节食是最不可取的；间歇性训练比长时间不间断训练效果更好等等</em><br><img src=\"https://upload-images.jianshu.io/upload_images/8878545-e1e37e549528652a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240\" alt=\"《硬派健身》\"><br>推荐指数：🌟🌟🌟</p>\n<p><strong>12.《论韭菜的自我修养》</strong><br><em>抛开今年7月网上曝光的录音事件导致的李笑来老师人设坍塌，以及此本书被众人吐槽是他个人的洗白之作，客观的讲，他对“韭菜”心理的研究是非常透彻的，书中有很多观点可以用与自我检视</em></p>\n<blockquote>\n<p>韭菜行为一：在牛市进场，在熊市离场<br>韭菜行为二：通过打探小道消息或他人推荐来决定交易的方向，而不是通过学习、独立思考和判断<br>韭菜行为三：频繁交易<br>韭菜行为四：一进场就把子弹用光<br>韭菜行为五：忽略自我投资</p>\n</blockquote>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8878545-4c719f47bd89e99a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240\" alt=\"《论韭菜的自我修养》\"><br>推荐指数：🌟🌟🌟</p>\n<p><strong>13.《侣行1》</strong><br><em>此本书是二刷了，自从16年知道270和梁红，以及他们独特的游历方式，就深深的被他们吸引，他们的节目及书籍也是一部不落。侣行1是他们游历的开始，跟着270轻松幽默的笔触，知道了摩加迪沙-索马里——一个充满战火的国度；奥伊米亚康——世界上有人类居住的最冷的地方，最低温度达零下71摄氏度，在这里，270正式向梁红求婚；切尔诺贝利——历史上最严重的核电事故发生地，被魔鬼接管的区域。马鲁姆火山——成为中国火山探险第一人</em><br>推荐指数：🌟🌟🌟🌟</p>\n<p><strong>14.《侣行2》</strong><br><em>8月份270和梁红宣布这个系列暂停一段时间，想想以后再难从荧幕中看到这对夫妻坚韧的个性、爽朗的笑容、鼓舞人心的行径，心中着实有些不舍，又拿出这个系列刷了一遍。这次270带领几个小伙伴一起，从上海开着帆船一路来到南极，途径济州岛、洛杉矶、圣地亚哥等地来到南极，一路上经历千辛万苦，狂风暴雨，身体极限，最终在270这个精神领袖的带领下来到南极，并在这冰雪圣洁之地举行了婚礼，出席婚礼的除了一起同行的几个好友还有岛上的原住民——企鹅。在北极求婚，在南极结婚，这酷酷的行为真的很“270”</em></p>\n<p>推荐指数：🌟🌟🌟🌟</p>\n<p><strong>15.《这些年，马云犯过的10个错误》</strong><br><em>吴晓波老师的作品，作为现在风口浪尖上的阿里和马云，和市面上一边倒的吹捧不同，本书还是较为客观的指出了阿里大国建成的过程中的一些问题，如当年办公室选址的错误、重用空降部队而忽略了外来物种在本土文化中生存的不适、对资金的运用存在形式主义、错误的收购了雅虎，形成现在鸡肋的局面等</em><br>推荐指数：🌟🌟🌟</p>\n<p><strong>16.《北方的空地》</strong><br><em>因为《七十七天》这部电影知道了这本书，书的作者杨柳松也是电影的原型，一个真正的汉子，以自力的方式孤身完成羌塘的穿越，历时77天，没有赞助、没有商业、没有炒作，仅仅是因为自己喜欢，就去了。</em></p>\n<blockquote>\n<p>何为人生，何为看透，不过是一种妥协，不想再让脆弱心灵瞎折腾。把握短暂的一生，便是对自己生命最大的追问。</p>\n</blockquote>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/8878545-249cdc9bc106abaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240\" alt=\"《北方的空地》\"><br>推荐指数：🌟🌟🌟🌟</p>\n<p><strong>17.《吃掉那只青蛙》</strong><br><em>一本GTD的工具书。每天吃3只“青蛙”——即生活工作中那些重要棘手且高价值区间的事情。和时间管理四象限中的理论不谋而合，从短期讲，将主要精力放在重要且紧急的事情上，从长期讲，讲主要精力放在重要不紧急的事情上。</em><br><img src=\"https://upload-images.jianshu.io/upload_images/8878545-b279915ff0e7f565.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240\" alt=\"吃掉那只青蛙\"><br>推荐指数：🌟🌟🌟🌟</p>\n<p><strong>18.《微习惯》</strong><br><em>微习惯是习惯的儿子！<br>本书讲述了为什么微习惯重要？为什么意志力不可靠？如何养成微习惯？<br>有点啰嗦，但整体理念还是不错，值得践行</em><br><img src=\"https://upload-images.jianshu.io/upload_images/8878545-788235cd28526e03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240\" alt=\"《微习惯》\"><br>推荐指数：🌟🌟🌟🌟</p>\n<p><strong>19.《秘密》</strong><br><em>东野圭吾先生的小说，真是一部高产的小说家。看他的书很放松且有种想要一口气读完的吸引力，历时4个小时的地铁时间读完。和他其它以往的作品不同，没有历险，没有谋杀，没有悬疑或推理，就是一个普通中年老人絮絮叨叨的生活小事，却不时又透露出人性的多面性。</em><br><img src=\"https://upload-images.jianshu.io/upload_images/8878545-761a5f2bc00ff72a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240\" alt=\"《秘密》\"></p>\n<p>推荐指数：🌟🌟🌟</p>\n<p><strong>20.《半小时漫画中国史 1、2、3》</strong><br><em>非常适合低龄儿童或者我这种对历史一无所知的人的阅读。虽说是半小时，但这1、2、3部读完却花了5个小时左右，整体来讲，朗朗上口，一气呵成，诙谐幽默，在傻笑中看完，历史原来如此有趣，这么多活灵活现的历史人物和事迹，真真是意犹未尽，期待后续的4。</em><br><img src=\"https://upload-images.jianshu.io/upload_images/8878545-d99a7f96744fb98c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240\" alt=\"半小时漫画中国史\"><br>推荐指数：🌟🌟🌟🌟🌟</p>\n<p><strong>21.《半小时漫画世界史 》</strong><br><em>这本书主要描述了欧洲史，包括希腊和罗马的时代，黑暗的中世纪等，还有斯巴达300勇士。除此之外，也写了美国和日本的一些事情。一本还算不错的科普书</em><br><img src=\"https://upload-images.jianshu.io/upload_images/8878545-f651cbb2fed9a7ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240\" alt=\"半小时漫画世界史\"><br>推荐指数：🌟🌟🌟🌟</p>\n<p>22.《撒哈拉的故事》<br><em>三毛的生活，并不是刻意的多姿多彩，而是她用心感受生活，喜欢生活。我觉得三毛是一个很会生活的人，她也有情绪，但她的教养让她得到西班牙人或者沙哈拉威人、甚至如荷西上司那样的欧洲人的尊重，一个善待自己的人才会即使面对变幻莫测的撒哈拉，把坟场搬的家装点成撒哈拉王国，过着诗一般的生活</em><br><img src=\"https://upload-images.jianshu.io/upload_images/8878545-a534698f60df7ec5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br>推荐指数：🌟🌟🌟🌟🌟</p>\n<p>23.《稻草人手记》<br><em>看完撒哈拉的故事，迷上了三毛的文字，于是又翻出了这本继续阅读。简简单单的文字记录了生活中的点点滴滴，似乎都是小事，但是似乎又都是不平凡的大事。这就是这本书给我的整体感觉。</em><br><img src=\"https://upload-images.jianshu.io/upload_images/8878545-b153ae6701d09b18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240\" alt=\"image.png\"></p>\n<p>推荐指数：🌟🌟🌟🌟</p>\n<p>24.《温柔的夜》<br><em>延续她一贯的行文风格，讲述她在加纳利群岛上的生活。不得不再次感叹，这真是一个不平凡的女子，生命中有种简单的璀璨。</em><br><img src=\"https://upload-images.jianshu.io/upload_images/8878545-9f11297265baff4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240\" alt=\"温柔的夜\"><br>推荐指数：🌟🌟🌟🌟</p>\n"},{"layout":"[post]","title":"git操作中的merge和rebase","date":"2019-06-12T01:36:09.000Z","sumarry":null,"_content":"\ngit操作经常使用，如拉取、推送、合并代码等操作都是日常开发中必不可少的，尤其是合并代码的时候,`rebase`和`merge`自然是都会用到的，但从来没有深究过这两种合并代码的方式到底有何差别，使用场景是什么，今天决定一探究竟并记录下来。\n\n# 用途\n首先，两者的诞生都是为了解决同样的问题：将一个分支的改变合并到另一个分支上。但两者的实现方式还是有很多差异。\n\n具体差异借助一个开发中常用的场景来加以说明：当你在一个开发分支上开发一个新功能的时候，团队其他人在`master`上`commit`了若干个新的提交，于是分支的历史变成了如下图这样。由于`master`上的`commit`对你正在使用的开发分支`feature`是有意义的，为了将`master`上的`commit`合入你的开发`feature`分支上，你有两个选择：`merge`或者`rebase`\n![提交历史](http://ww1.sinaimg.cn/large/a64e5cc2gy1fhi8ke7gu5j20bg07zdfq.jpg)\n\n# 选择merge\n```vim\ngit checkout feature \ngit merge master\n```\n合并后，feature分支的提交历史变成了如下图\n![merge后feature分支的提交log](http://ww1.sinaimg.cn/large/a64e5cc2gy1fhi8kt3q6aj20da07wa9z.jpg)\n\n从图中我们可以看到，最终两个分支的历史以分叉线的方式汇合到一起，且在汇合出是一个多出来的新的commit `Merge branch 'master' into feature`.\n以上是没有出现冲突的情况，但出现冲突是非常常见的事情，同样以例子来说明\n`featue`和`master`分支同时修改了`a.js`和`b.js`，`git merge master`出现冲突提示，解决后feature最终的提交历史变成如下图：\n![feature git log](http://ww3.sinaimg.cn/large/006tNc79gy1g3zm8omwaxj31qo0gytet.jpg)\n\n**由此我们可以得出使用merge操作的特征**\n* merge是一个非破坏性的操作，原有的已经存在的提交（时间先后顺序、`log`线）等都得到了保留\n* 产生了一个外来的代表合并的`commit`。如果`master`分支非常活跃，会对`feature`造成大量的历史污染，造成其他开发者难以看懂或理解你的项目的历史记录。\n* 出现冲突时，只需解决一次冲突，解决完冲突后会产生一个`commit`，该commit即代表了合并也包含了最终冲突解决结果\n\n\n# 选择 rebase\n```vim\ngit checkout feature \ngit rebase master\n```\n合并后，feature分支的提交历史变成了如下图\n![rebase后feature分支的提交log](http://ww1.sinaimg.cn/large/a64e5cc2gy1fhi8kzq9r3j20fq07vwee.jpg)\n\n从上图我们可以看出，整个master分支移动到了feature分支上，且没有使用一个代表 merging 的 commit，整个项目提交历史很清晰。\n\n同样，当出现冲突时，rebase是如何解决冲突的？以同样的例子操作为例，操作如下图\n![rebase conflict](http://ww2.sinaimg.cn/large/006tNc79gy1g3zmoxe9qaj30u00x5dn7.jpg)\n从图中我们可以看出，执行`git rebase master`之后提示b.js有冲突，手动解决后，执行`git rebase --continue`,又提示一次让解决`b.js`的冲突，重复上述操作后，最终`feature`分支的提交历史如下图\n![rebase conflict git log](http://ww4.sinaimg.cn/large/006tNc79gy1g3zmv0y4ukj319k0d2gp5.jpg)\n从日志中可以看到，最终并没有产生一个解决冲突的提交\n**由此我们可以得出使用rebase操作的特征**\n* 没有引入不必要的commit\n* 整个提交历史是线性无分叉的，便于阅读及清晰操作整个历史记录。但清晰的commit的代价就是失去了可追溯性，因为从现有的提交历史中，已无法得知是在哪个时间点及提交点将上游的master分支合并进入feature分支的。\n* 出现冲突时，可能需要多次解决冲突（具体以feature分支的提交点中和master分支中有几次出现了冲突为准），解决完冲突后需要以命令`git rebase --continue `继续变基，且不会产生额外的commit。\n## 交互式rebase\nrebase还有一个更高级的用法：交互式变基,除了完成最终的分支合并之外，交互式变基可以帮助我们在变基过程中，增加自己的操作（**合并提交、拆分提交、删除提交**），然后再变基。虽然平时使用得不多，但借助它也可以产生一些神奇的效果，在此也一并简单介绍下。\n\n交互式rebase对应命令\n```vim\ngit reabse -i <branch>\n```\n\n### 合并提交\n假设我要将下图中标红框的部分合并成一个提交\n![交互式rebase combine](http://ww2.sinaimg.cn/large/006tNc79gy1g3zjagpsyoj312o080416.jpg)\n首先要找到起始commit的前一个提交，即`e3017604`,执行`git rebase -i e3017604`,\n此时会唤起编辑器，并带出`e3017604`前的所有提交，按时间顺序展示，首行是最早的提交，末行是最新的提交，如下图\n ![交互式rebase combine](http://ww1.sinaimg.cn/large/006tNc79gy1g3zjge0z4oj30sw0jkn00.jpg)\n每行格式如下\n```\n(action) (partial-sha) (short commit message)\n```\naction 有很多种，默认是`pick`\n![action](http://ww1.sinaimg.cn/large/006tNc79gy1g3zjmn15vxj31g60cedpn.jpg)\n现在我们想把后三个提交合并到第一个中去，这里需要用到 `squash`，该 `action` 表示 使用该提交，但是把它与前一提交合并，所以只需把后四个的 `action` 改为 `squash` 即可。\n![squash](http://ww2.sinaimg.cn/large/006tNc79gy1g3zjpepa0bj30mq0aodhd.jpg)\n\n保存之后，会唤出编辑器提示创建一个新的提交信息,编辑好提交信息保存即可。\n合并完之后历史记录变成如下图：\n\n![combine](http://ww4.sinaimg.cn/large/006tNc79gy1g3zk422n50j316s082wg9.jpg)\n### 拆分提交\n如果我想把某个commit拆分成多个commit，可以使用`edit` action,该action告诉git说**我要使用该提交，但是先在这里停一下，等我把该提交拆分好后再继续执行下一步**\n\n初始提交历史如下图：\n![split commit](http://ww4.sinaimg.cn/large/006tNc79gy1g3zkgn7mzuj317g0a4ad8.jpg)\n红框标出的`master commit 5`这个提交中包含了两个文件修改，新增`b.js`和修改`a.js`,我现在想把它拆分成两个提交，一个提交修改一个文件，那我可以这样做\n执行`git rebase -i 9d257fe8`，然后修改 `27c84ed` 这个 commit 的 action 为 `edit`,如下图\n![edit](http://ww1.sinaimg.cn/large/006tNc79gy1g3zkhuymc4j30se0b8wg2.jpg)\n保存并退出后，提示执行`git commit --amend`对commit信息进行重新编辑\n我们这里是要拆分 commit，所以要先对 commit 内容 reset，然后重新提交，按照如下图的操作一步步提交:\n![commit history](http://ww1.sinaimg.cn/large/006tNc79gy1g3zkxjw8nzj30sy0iyae8.jpg)\n执行完成后`git rebase --contine`，即达到了我们想要的效果，即把一个提交拆分成了两个提交，最终结果如下图\n![result](http://ww4.sinaimg.cn/large/006tNc79gy1g3zklfx4roj316i09ujul.jpg)\n\n### 删除提交\n\n如果想删除某个提交，使用 ` git rebase -i *** ` 后直接在编辑器中使用drop action删除那一行 commit 即可,如果出现冲突，手动解决冲突后再执行` git rebase --continue `即可\n下图为我执行操作删除'master commit 4'这个提交点及最终的执行结果\n![](http://ww4.sinaimg.cn/large/006tNc79gy1g3zlgmqe3gj30y20ho0wi.jpg)\n![](http://ww1.sinaimg.cn/large/006tNc79gy1g3zlhedw0bj317007mmzq.jpg)\n\n# 总结\n最后，对这两个命令做个总结。\n![总结](http://ww4.sinaimg.cn/large/006tNc79gy1g3znx8capzj31h40dwk64.jpg)\n\n这两个命令各有优劣，很难概括哪一个最好，那到底该如何选择呢？\n个人理解：\n*  团队成员对两种命令的熟悉程度\n* 个人喜好：比如有人倾向清晰的阅读性，有人不喜欢多次处理冲突\n\n一般建议：\n* 开发过程中，合并上游分支（如master）要频繁（切忌两耳不闻窗外事，一心闷头写代码）时使用rebase，有冲突提前就fix掉\n* 测试通过后合并到上游分支时，可以使用merge，保证所有提交点的可追溯性\n\n**不管选择哪个，作为一个开发人员，两种合并方式的异同都建议大家掌握。**\n\n# 参考资料\n[Merging vs. Rebasing](https://www.atlassian.com/git/tutorials/merging-vs-rebasing)\n[merge和rebase的区别](https://www.cnblogs.com/xueweihan/p/5743327.html)\n","source":"_posts/the-difference-between-git-merge-and-git-rebase.md","raw":"---\nlayout: '[post]'\ntitle: git操作中的merge和rebase\ndate: 2019-06-12 09:36:09\ntags: git merge rebase\nsumarry: \n---\n\ngit操作经常使用，如拉取、推送、合并代码等操作都是日常开发中必不可少的，尤其是合并代码的时候,`rebase`和`merge`自然是都会用到的，但从来没有深究过这两种合并代码的方式到底有何差别，使用场景是什么，今天决定一探究竟并记录下来。\n\n# 用途\n首先，两者的诞生都是为了解决同样的问题：将一个分支的改变合并到另一个分支上。但两者的实现方式还是有很多差异。\n\n具体差异借助一个开发中常用的场景来加以说明：当你在一个开发分支上开发一个新功能的时候，团队其他人在`master`上`commit`了若干个新的提交，于是分支的历史变成了如下图这样。由于`master`上的`commit`对你正在使用的开发分支`feature`是有意义的，为了将`master`上的`commit`合入你的开发`feature`分支上，你有两个选择：`merge`或者`rebase`\n![提交历史](http://ww1.sinaimg.cn/large/a64e5cc2gy1fhi8ke7gu5j20bg07zdfq.jpg)\n\n# 选择merge\n```vim\ngit checkout feature \ngit merge master\n```\n合并后，feature分支的提交历史变成了如下图\n![merge后feature分支的提交log](http://ww1.sinaimg.cn/large/a64e5cc2gy1fhi8kt3q6aj20da07wa9z.jpg)\n\n从图中我们可以看到，最终两个分支的历史以分叉线的方式汇合到一起，且在汇合出是一个多出来的新的commit `Merge branch 'master' into feature`.\n以上是没有出现冲突的情况，但出现冲突是非常常见的事情，同样以例子来说明\n`featue`和`master`分支同时修改了`a.js`和`b.js`，`git merge master`出现冲突提示，解决后feature最终的提交历史变成如下图：\n![feature git log](http://ww3.sinaimg.cn/large/006tNc79gy1g3zm8omwaxj31qo0gytet.jpg)\n\n**由此我们可以得出使用merge操作的特征**\n* merge是一个非破坏性的操作，原有的已经存在的提交（时间先后顺序、`log`线）等都得到了保留\n* 产生了一个外来的代表合并的`commit`。如果`master`分支非常活跃，会对`feature`造成大量的历史污染，造成其他开发者难以看懂或理解你的项目的历史记录。\n* 出现冲突时，只需解决一次冲突，解决完冲突后会产生一个`commit`，该commit即代表了合并也包含了最终冲突解决结果\n\n\n# 选择 rebase\n```vim\ngit checkout feature \ngit rebase master\n```\n合并后，feature分支的提交历史变成了如下图\n![rebase后feature分支的提交log](http://ww1.sinaimg.cn/large/a64e5cc2gy1fhi8kzq9r3j20fq07vwee.jpg)\n\n从上图我们可以看出，整个master分支移动到了feature分支上，且没有使用一个代表 merging 的 commit，整个项目提交历史很清晰。\n\n同样，当出现冲突时，rebase是如何解决冲突的？以同样的例子操作为例，操作如下图\n![rebase conflict](http://ww2.sinaimg.cn/large/006tNc79gy1g3zmoxe9qaj30u00x5dn7.jpg)\n从图中我们可以看出，执行`git rebase master`之后提示b.js有冲突，手动解决后，执行`git rebase --continue`,又提示一次让解决`b.js`的冲突，重复上述操作后，最终`feature`分支的提交历史如下图\n![rebase conflict git log](http://ww4.sinaimg.cn/large/006tNc79gy1g3zmv0y4ukj319k0d2gp5.jpg)\n从日志中可以看到，最终并没有产生一个解决冲突的提交\n**由此我们可以得出使用rebase操作的特征**\n* 没有引入不必要的commit\n* 整个提交历史是线性无分叉的，便于阅读及清晰操作整个历史记录。但清晰的commit的代价就是失去了可追溯性，因为从现有的提交历史中，已无法得知是在哪个时间点及提交点将上游的master分支合并进入feature分支的。\n* 出现冲突时，可能需要多次解决冲突（具体以feature分支的提交点中和master分支中有几次出现了冲突为准），解决完冲突后需要以命令`git rebase --continue `继续变基，且不会产生额外的commit。\n## 交互式rebase\nrebase还有一个更高级的用法：交互式变基,除了完成最终的分支合并之外，交互式变基可以帮助我们在变基过程中，增加自己的操作（**合并提交、拆分提交、删除提交**），然后再变基。虽然平时使用得不多，但借助它也可以产生一些神奇的效果，在此也一并简单介绍下。\n\n交互式rebase对应命令\n```vim\ngit reabse -i <branch>\n```\n\n### 合并提交\n假设我要将下图中标红框的部分合并成一个提交\n![交互式rebase combine](http://ww2.sinaimg.cn/large/006tNc79gy1g3zjagpsyoj312o080416.jpg)\n首先要找到起始commit的前一个提交，即`e3017604`,执行`git rebase -i e3017604`,\n此时会唤起编辑器，并带出`e3017604`前的所有提交，按时间顺序展示，首行是最早的提交，末行是最新的提交，如下图\n ![交互式rebase combine](http://ww1.sinaimg.cn/large/006tNc79gy1g3zjge0z4oj30sw0jkn00.jpg)\n每行格式如下\n```\n(action) (partial-sha) (short commit message)\n```\naction 有很多种，默认是`pick`\n![action](http://ww1.sinaimg.cn/large/006tNc79gy1g3zjmn15vxj31g60cedpn.jpg)\n现在我们想把后三个提交合并到第一个中去，这里需要用到 `squash`，该 `action` 表示 使用该提交，但是把它与前一提交合并，所以只需把后四个的 `action` 改为 `squash` 即可。\n![squash](http://ww2.sinaimg.cn/large/006tNc79gy1g3zjpepa0bj30mq0aodhd.jpg)\n\n保存之后，会唤出编辑器提示创建一个新的提交信息,编辑好提交信息保存即可。\n合并完之后历史记录变成如下图：\n\n![combine](http://ww4.sinaimg.cn/large/006tNc79gy1g3zk422n50j316s082wg9.jpg)\n### 拆分提交\n如果我想把某个commit拆分成多个commit，可以使用`edit` action,该action告诉git说**我要使用该提交，但是先在这里停一下，等我把该提交拆分好后再继续执行下一步**\n\n初始提交历史如下图：\n![split commit](http://ww4.sinaimg.cn/large/006tNc79gy1g3zkgn7mzuj317g0a4ad8.jpg)\n红框标出的`master commit 5`这个提交中包含了两个文件修改，新增`b.js`和修改`a.js`,我现在想把它拆分成两个提交，一个提交修改一个文件，那我可以这样做\n执行`git rebase -i 9d257fe8`，然后修改 `27c84ed` 这个 commit 的 action 为 `edit`,如下图\n![edit](http://ww1.sinaimg.cn/large/006tNc79gy1g3zkhuymc4j30se0b8wg2.jpg)\n保存并退出后，提示执行`git commit --amend`对commit信息进行重新编辑\n我们这里是要拆分 commit，所以要先对 commit 内容 reset，然后重新提交，按照如下图的操作一步步提交:\n![commit history](http://ww1.sinaimg.cn/large/006tNc79gy1g3zkxjw8nzj30sy0iyae8.jpg)\n执行完成后`git rebase --contine`，即达到了我们想要的效果，即把一个提交拆分成了两个提交，最终结果如下图\n![result](http://ww4.sinaimg.cn/large/006tNc79gy1g3zklfx4roj316i09ujul.jpg)\n\n### 删除提交\n\n如果想删除某个提交，使用 ` git rebase -i *** ` 后直接在编辑器中使用drop action删除那一行 commit 即可,如果出现冲突，手动解决冲突后再执行` git rebase --continue `即可\n下图为我执行操作删除'master commit 4'这个提交点及最终的执行结果\n![](http://ww4.sinaimg.cn/large/006tNc79gy1g3zlgmqe3gj30y20ho0wi.jpg)\n![](http://ww1.sinaimg.cn/large/006tNc79gy1g3zlhedw0bj317007mmzq.jpg)\n\n# 总结\n最后，对这两个命令做个总结。\n![总结](http://ww4.sinaimg.cn/large/006tNc79gy1g3znx8capzj31h40dwk64.jpg)\n\n这两个命令各有优劣，很难概括哪一个最好，那到底该如何选择呢？\n个人理解：\n*  团队成员对两种命令的熟悉程度\n* 个人喜好：比如有人倾向清晰的阅读性，有人不喜欢多次处理冲突\n\n一般建议：\n* 开发过程中，合并上游分支（如master）要频繁（切忌两耳不闻窗外事，一心闷头写代码）时使用rebase，有冲突提前就fix掉\n* 测试通过后合并到上游分支时，可以使用merge，保证所有提交点的可追溯性\n\n**不管选择哪个，作为一个开发人员，两种合并方式的异同都建议大家掌握。**\n\n# 参考资料\n[Merging vs. Rebasing](https://www.atlassian.com/git/tutorials/merging-vs-rebasing)\n[merge和rebase的区别](https://www.cnblogs.com/xueweihan/p/5743327.html)\n","slug":"the-difference-between-git-merge-and-git-rebase","published":1,"updated":"2019-06-13T10:27:03.305Z","comments":1,"photos":[],"link":"","_id":"ck2mo4mye001cdt47wpiff9v3","content":"<p>git操作经常使用，如拉取、推送、合并代码等操作都是日常开发中必不可少的，尤其是合并代码的时候,<code>rebase</code>和<code>merge</code>自然是都会用到的，但从来没有深究过这两种合并代码的方式到底有何差别，使用场景是什么，今天决定一探究竟并记录下来。</p>\n<h1 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h1><p>首先，两者的诞生都是为了解决同样的问题：将一个分支的改变合并到另一个分支上。但两者的实现方式还是有很多差异。</p>\n<p>具体差异借助一个开发中常用的场景来加以说明：当你在一个开发分支上开发一个新功能的时候，团队其他人在<code>master</code>上<code>commit</code>了若干个新的提交，于是分支的历史变成了如下图这样。由于<code>master</code>上的<code>commit</code>对你正在使用的开发分支<code>feature</code>是有意义的，为了将<code>master</code>上的<code>commit</code>合入你的开发<code>feature</code>分支上，你有两个选择：<code>merge</code>或者<code>rebase</code><br><img src=\"http://ww1.sinaimg.cn/large/a64e5cc2gy1fhi8ke7gu5j20bg07zdfq.jpg\" alt=\"提交历史\"></p>\n<h1 id=\"选择merge\"><a href=\"#选择merge\" class=\"headerlink\" title=\"选择merge\"></a>选择merge</h1><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout feature </span><br><span class=\"line\">git merge master</span><br></pre></td></tr></table></figure>\n<p>合并后，feature分支的提交历史变成了如下图<br><img src=\"http://ww1.sinaimg.cn/large/a64e5cc2gy1fhi8kt3q6aj20da07wa9z.jpg\" alt=\"merge后feature分支的提交log\"></p>\n<p>从图中我们可以看到，最终两个分支的历史以分叉线的方式汇合到一起，且在汇合出是一个多出来的新的commit <code>Merge branch &#39;master&#39; into feature</code>.<br>以上是没有出现冲突的情况，但出现冲突是非常常见的事情，同样以例子来说明<br><code>featue</code>和<code>master</code>分支同时修改了<code>a.js</code>和<code>b.js</code>，<code>git merge master</code>出现冲突提示，解决后feature最终的提交历史变成如下图：<br><img src=\"http://ww3.sinaimg.cn/large/006tNc79gy1g3zm8omwaxj31qo0gytet.jpg\" alt=\"feature git log\"></p>\n<p><strong>由此我们可以得出使用merge操作的特征</strong></p>\n<ul>\n<li>merge是一个非破坏性的操作，原有的已经存在的提交（时间先后顺序、<code>log</code>线）等都得到了保留</li>\n<li>产生了一个外来的代表合并的<code>commit</code>。如果<code>master</code>分支非常活跃，会对<code>feature</code>造成大量的历史污染，造成其他开发者难以看懂或理解你的项目的历史记录。</li>\n<li>出现冲突时，只需解决一次冲突，解决完冲突后会产生一个<code>commit</code>，该commit即代表了合并也包含了最终冲突解决结果</li>\n</ul>\n<h1 id=\"选择-rebase\"><a href=\"#选择-rebase\" class=\"headerlink\" title=\"选择 rebase\"></a>选择 rebase</h1><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout feature </span><br><span class=\"line\">git rebase master</span><br></pre></td></tr></table></figure>\n<p>合并后，feature分支的提交历史变成了如下图<br><img src=\"http://ww1.sinaimg.cn/large/a64e5cc2gy1fhi8kzq9r3j20fq07vwee.jpg\" alt=\"rebase后feature分支的提交log\"></p>\n<p>从上图我们可以看出，整个master分支移动到了feature分支上，且没有使用一个代表 merging 的 commit，整个项目提交历史很清晰。</p>\n<p>同样，当出现冲突时，rebase是如何解决冲突的？以同样的例子操作为例，操作如下图<br><img src=\"http://ww2.sinaimg.cn/large/006tNc79gy1g3zmoxe9qaj30u00x5dn7.jpg\" alt=\"rebase conflict\"><br>从图中我们可以看出，执行<code>git rebase master</code>之后提示b.js有冲突，手动解决后，执行<code>git rebase --continue</code>,又提示一次让解决<code>b.js</code>的冲突，重复上述操作后，最终<code>feature</code>分支的提交历史如下图<br><img src=\"http://ww4.sinaimg.cn/large/006tNc79gy1g3zmv0y4ukj319k0d2gp5.jpg\" alt=\"rebase conflict git log\"><br>从日志中可以看到，最终并没有产生一个解决冲突的提交<br><strong>由此我们可以得出使用rebase操作的特征</strong></p>\n<ul>\n<li>没有引入不必要的commit</li>\n<li>整个提交历史是线性无分叉的，便于阅读及清晰操作整个历史记录。但清晰的commit的代价就是失去了可追溯性，因为从现有的提交历史中，已无法得知是在哪个时间点及提交点将上游的master分支合并进入feature分支的。</li>\n<li>出现冲突时，可能需要多次解决冲突（具体以feature分支的提交点中和master分支中有几次出现了冲突为准），解决完冲突后需要以命令<code>git rebase --continue</code>继续变基，且不会产生额外的commit。<h2 id=\"交互式rebase\"><a href=\"#交互式rebase\" class=\"headerlink\" title=\"交互式rebase\"></a>交互式rebase</h2>rebase还有一个更高级的用法：交互式变基,除了完成最终的分支合并之外，交互式变基可以帮助我们在变基过程中，增加自己的操作（<strong>合并提交、拆分提交、删除提交</strong>），然后再变基。虽然平时使用得不多，但借助它也可以产生一些神奇的效果，在此也一并简单介绍下。</li>\n</ul>\n<p>交互式rebase对应命令<br><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reabse -i <span class=\"symbol\">&lt;branch&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"合并提交\"><a href=\"#合并提交\" class=\"headerlink\" title=\"合并提交\"></a>合并提交</h3><p>假设我要将下图中标红框的部分合并成一个提交<br><img src=\"http://ww2.sinaimg.cn/large/006tNc79gy1g3zjagpsyoj312o080416.jpg\" alt=\"交互式rebase combine\"><br>首先要找到起始commit的前一个提交，即<code>e3017604</code>,执行<code>git rebase -i e3017604</code>,<br>此时会唤起编辑器，并带出<code>e3017604</code>前的所有提交，按时间顺序展示，首行是最早的提交，末行是最新的提交，如下图<br> <img src=\"http://ww1.sinaimg.cn/large/006tNc79gy1g3zjge0z4oj30sw0jkn00.jpg\" alt=\"交互式rebase combine\"><br>每行格式如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(action) (partial-sha) (short commit message)</span><br></pre></td></tr></table></figure></p>\n<p>action 有很多种，默认是<code>pick</code><br><img src=\"http://ww1.sinaimg.cn/large/006tNc79gy1g3zjmn15vxj31g60cedpn.jpg\" alt=\"action\"><br>现在我们想把后三个提交合并到第一个中去，这里需要用到 <code>squash</code>，该 <code>action</code> 表示 使用该提交，但是把它与前一提交合并，所以只需把后四个的 <code>action</code> 改为 <code>squash</code> 即可。<br><img src=\"http://ww2.sinaimg.cn/large/006tNc79gy1g3zjpepa0bj30mq0aodhd.jpg\" alt=\"squash\"></p>\n<p>保存之后，会唤出编辑器提示创建一个新的提交信息,编辑好提交信息保存即可。<br>合并完之后历史记录变成如下图：</p>\n<p><img src=\"http://ww4.sinaimg.cn/large/006tNc79gy1g3zk422n50j316s082wg9.jpg\" alt=\"combine\"></p>\n<h3 id=\"拆分提交\"><a href=\"#拆分提交\" class=\"headerlink\" title=\"拆分提交\"></a>拆分提交</h3><p>如果我想把某个commit拆分成多个commit，可以使用<code>edit</code> action,该action告诉git说<strong>我要使用该提交，但是先在这里停一下，等我把该提交拆分好后再继续执行下一步</strong></p>\n<p>初始提交历史如下图：<br><img src=\"http://ww4.sinaimg.cn/large/006tNc79gy1g3zkgn7mzuj317g0a4ad8.jpg\" alt=\"split commit\"><br>红框标出的<code>master commit 5</code>这个提交中包含了两个文件修改，新增<code>b.js</code>和修改<code>a.js</code>,我现在想把它拆分成两个提交，一个提交修改一个文件，那我可以这样做<br>执行<code>git rebase -i 9d257fe8</code>，然后修改 <code>27c84ed</code> 这个 commit 的 action 为 <code>edit</code>,如下图<br><img src=\"http://ww1.sinaimg.cn/large/006tNc79gy1g3zkhuymc4j30se0b8wg2.jpg\" alt=\"edit\"><br>保存并退出后，提示执行<code>git commit --amend</code>对commit信息进行重新编辑<br>我们这里是要拆分 commit，所以要先对 commit 内容 reset，然后重新提交，按照如下图的操作一步步提交:<br><img src=\"http://ww1.sinaimg.cn/large/006tNc79gy1g3zkxjw8nzj30sy0iyae8.jpg\" alt=\"commit history\"><br>执行完成后<code>git rebase --contine</code>，即达到了我们想要的效果，即把一个提交拆分成了两个提交，最终结果如下图<br><img src=\"http://ww4.sinaimg.cn/large/006tNc79gy1g3zklfx4roj316i09ujul.jpg\" alt=\"result\"></p>\n<h3 id=\"删除提交\"><a href=\"#删除提交\" class=\"headerlink\" title=\"删除提交\"></a>删除提交</h3><p>如果想删除某个提交，使用 <code>git rebase -i ***</code> 后直接在编辑器中使用drop action删除那一行 commit 即可,如果出现冲突，手动解决冲突后再执行<code>git rebase --continue</code>即可<br>下图为我执行操作删除’master commit 4’这个提交点及最终的执行结果<br><img src=\"http://ww4.sinaimg.cn/large/006tNc79gy1g3zlgmqe3gj30y20ho0wi.jpg\" alt><br><img src=\"http://ww1.sinaimg.cn/large/006tNc79gy1g3zlhedw0bj317007mmzq.jpg\" alt></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>最后，对这两个命令做个总结。<br><img src=\"http://ww4.sinaimg.cn/large/006tNc79gy1g3znx8capzj31h40dwk64.jpg\" alt=\"总结\"></p>\n<p>这两个命令各有优劣，很难概括哪一个最好，那到底该如何选择呢？<br>个人理解：</p>\n<ul>\n<li>团队成员对两种命令的熟悉程度</li>\n<li>个人喜好：比如有人倾向清晰的阅读性，有人不喜欢多次处理冲突</li>\n</ul>\n<p>一般建议：</p>\n<ul>\n<li>开发过程中，合并上游分支（如master）要频繁（切忌两耳不闻窗外事，一心闷头写代码）时使用rebase，有冲突提前就fix掉</li>\n<li>测试通过后合并到上游分支时，可以使用merge，保证所有提交点的可追溯性</li>\n</ul>\n<p><strong>不管选择哪个，作为一个开发人员，两种合并方式的异同都建议大家掌握。</strong></p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://www.atlassian.com/git/tutorials/merging-vs-rebasing\" target=\"_blank\" rel=\"noopener\">Merging vs. Rebasing</a><br><a href=\"https://www.cnblogs.com/xueweihan/p/5743327.html\" target=\"_blank\" rel=\"noopener\">merge和rebase的区别</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>git操作经常使用，如拉取、推送、合并代码等操作都是日常开发中必不可少的，尤其是合并代码的时候,<code>rebase</code>和<code>merge</code>自然是都会用到的，但从来没有深究过这两种合并代码的方式到底有何差别，使用场景是什么，今天决定一探究竟并记录下来。</p>\n<h1 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h1><p>首先，两者的诞生都是为了解决同样的问题：将一个分支的改变合并到另一个分支上。但两者的实现方式还是有很多差异。</p>\n<p>具体差异借助一个开发中常用的场景来加以说明：当你在一个开发分支上开发一个新功能的时候，团队其他人在<code>master</code>上<code>commit</code>了若干个新的提交，于是分支的历史变成了如下图这样。由于<code>master</code>上的<code>commit</code>对你正在使用的开发分支<code>feature</code>是有意义的，为了将<code>master</code>上的<code>commit</code>合入你的开发<code>feature</code>分支上，你有两个选择：<code>merge</code>或者<code>rebase</code><br><img src=\"http://ww1.sinaimg.cn/large/a64e5cc2gy1fhi8ke7gu5j20bg07zdfq.jpg\" alt=\"提交历史\"></p>\n<h1 id=\"选择merge\"><a href=\"#选择merge\" class=\"headerlink\" title=\"选择merge\"></a>选择merge</h1><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout feature </span><br><span class=\"line\">git merge master</span><br></pre></td></tr></table></figure>\n<p>合并后，feature分支的提交历史变成了如下图<br><img src=\"http://ww1.sinaimg.cn/large/a64e5cc2gy1fhi8kt3q6aj20da07wa9z.jpg\" alt=\"merge后feature分支的提交log\"></p>\n<p>从图中我们可以看到，最终两个分支的历史以分叉线的方式汇合到一起，且在汇合出是一个多出来的新的commit <code>Merge branch &#39;master&#39; into feature</code>.<br>以上是没有出现冲突的情况，但出现冲突是非常常见的事情，同样以例子来说明<br><code>featue</code>和<code>master</code>分支同时修改了<code>a.js</code>和<code>b.js</code>，<code>git merge master</code>出现冲突提示，解决后feature最终的提交历史变成如下图：<br><img src=\"http://ww3.sinaimg.cn/large/006tNc79gy1g3zm8omwaxj31qo0gytet.jpg\" alt=\"feature git log\"></p>\n<p><strong>由此我们可以得出使用merge操作的特征</strong></p>\n<ul>\n<li>merge是一个非破坏性的操作，原有的已经存在的提交（时间先后顺序、<code>log</code>线）等都得到了保留</li>\n<li>产生了一个外来的代表合并的<code>commit</code>。如果<code>master</code>分支非常活跃，会对<code>feature</code>造成大量的历史污染，造成其他开发者难以看懂或理解你的项目的历史记录。</li>\n<li>出现冲突时，只需解决一次冲突，解决完冲突后会产生一个<code>commit</code>，该commit即代表了合并也包含了最终冲突解决结果</li>\n</ul>\n<h1 id=\"选择-rebase\"><a href=\"#选择-rebase\" class=\"headerlink\" title=\"选择 rebase\"></a>选择 rebase</h1><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout feature </span><br><span class=\"line\">git rebase master</span><br></pre></td></tr></table></figure>\n<p>合并后，feature分支的提交历史变成了如下图<br><img src=\"http://ww1.sinaimg.cn/large/a64e5cc2gy1fhi8kzq9r3j20fq07vwee.jpg\" alt=\"rebase后feature分支的提交log\"></p>\n<p>从上图我们可以看出，整个master分支移动到了feature分支上，且没有使用一个代表 merging 的 commit，整个项目提交历史很清晰。</p>\n<p>同样，当出现冲突时，rebase是如何解决冲突的？以同样的例子操作为例，操作如下图<br><img src=\"http://ww2.sinaimg.cn/large/006tNc79gy1g3zmoxe9qaj30u00x5dn7.jpg\" alt=\"rebase conflict\"><br>从图中我们可以看出，执行<code>git rebase master</code>之后提示b.js有冲突，手动解决后，执行<code>git rebase --continue</code>,又提示一次让解决<code>b.js</code>的冲突，重复上述操作后，最终<code>feature</code>分支的提交历史如下图<br><img src=\"http://ww4.sinaimg.cn/large/006tNc79gy1g3zmv0y4ukj319k0d2gp5.jpg\" alt=\"rebase conflict git log\"><br>从日志中可以看到，最终并没有产生一个解决冲突的提交<br><strong>由此我们可以得出使用rebase操作的特征</strong></p>\n<ul>\n<li>没有引入不必要的commit</li>\n<li>整个提交历史是线性无分叉的，便于阅读及清晰操作整个历史记录。但清晰的commit的代价就是失去了可追溯性，因为从现有的提交历史中，已无法得知是在哪个时间点及提交点将上游的master分支合并进入feature分支的。</li>\n<li>出现冲突时，可能需要多次解决冲突（具体以feature分支的提交点中和master分支中有几次出现了冲突为准），解决完冲突后需要以命令<code>git rebase --continue</code>继续变基，且不会产生额外的commit。<h2 id=\"交互式rebase\"><a href=\"#交互式rebase\" class=\"headerlink\" title=\"交互式rebase\"></a>交互式rebase</h2>rebase还有一个更高级的用法：交互式变基,除了完成最终的分支合并之外，交互式变基可以帮助我们在变基过程中，增加自己的操作（<strong>合并提交、拆分提交、删除提交</strong>），然后再变基。虽然平时使用得不多，但借助它也可以产生一些神奇的效果，在此也一并简单介绍下。</li>\n</ul>\n<p>交互式rebase对应命令<br><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reabse -i <span class=\"symbol\">&lt;branch&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"合并提交\"><a href=\"#合并提交\" class=\"headerlink\" title=\"合并提交\"></a>合并提交</h3><p>假设我要将下图中标红框的部分合并成一个提交<br><img src=\"http://ww2.sinaimg.cn/large/006tNc79gy1g3zjagpsyoj312o080416.jpg\" alt=\"交互式rebase combine\"><br>首先要找到起始commit的前一个提交，即<code>e3017604</code>,执行<code>git rebase -i e3017604</code>,<br>此时会唤起编辑器，并带出<code>e3017604</code>前的所有提交，按时间顺序展示，首行是最早的提交，末行是最新的提交，如下图<br> <img src=\"http://ww1.sinaimg.cn/large/006tNc79gy1g3zjge0z4oj30sw0jkn00.jpg\" alt=\"交互式rebase combine\"><br>每行格式如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(action) (partial-sha) (short commit message)</span><br></pre></td></tr></table></figure></p>\n<p>action 有很多种，默认是<code>pick</code><br><img src=\"http://ww1.sinaimg.cn/large/006tNc79gy1g3zjmn15vxj31g60cedpn.jpg\" alt=\"action\"><br>现在我们想把后三个提交合并到第一个中去，这里需要用到 <code>squash</code>，该 <code>action</code> 表示 使用该提交，但是把它与前一提交合并，所以只需把后四个的 <code>action</code> 改为 <code>squash</code> 即可。<br><img src=\"http://ww2.sinaimg.cn/large/006tNc79gy1g3zjpepa0bj30mq0aodhd.jpg\" alt=\"squash\"></p>\n<p>保存之后，会唤出编辑器提示创建一个新的提交信息,编辑好提交信息保存即可。<br>合并完之后历史记录变成如下图：</p>\n<p><img src=\"http://ww4.sinaimg.cn/large/006tNc79gy1g3zk422n50j316s082wg9.jpg\" alt=\"combine\"></p>\n<h3 id=\"拆分提交\"><a href=\"#拆分提交\" class=\"headerlink\" title=\"拆分提交\"></a>拆分提交</h3><p>如果我想把某个commit拆分成多个commit，可以使用<code>edit</code> action,该action告诉git说<strong>我要使用该提交，但是先在这里停一下，等我把该提交拆分好后再继续执行下一步</strong></p>\n<p>初始提交历史如下图：<br><img src=\"http://ww4.sinaimg.cn/large/006tNc79gy1g3zkgn7mzuj317g0a4ad8.jpg\" alt=\"split commit\"><br>红框标出的<code>master commit 5</code>这个提交中包含了两个文件修改，新增<code>b.js</code>和修改<code>a.js</code>,我现在想把它拆分成两个提交，一个提交修改一个文件，那我可以这样做<br>执行<code>git rebase -i 9d257fe8</code>，然后修改 <code>27c84ed</code> 这个 commit 的 action 为 <code>edit</code>,如下图<br><img src=\"http://ww1.sinaimg.cn/large/006tNc79gy1g3zkhuymc4j30se0b8wg2.jpg\" alt=\"edit\"><br>保存并退出后，提示执行<code>git commit --amend</code>对commit信息进行重新编辑<br>我们这里是要拆分 commit，所以要先对 commit 内容 reset，然后重新提交，按照如下图的操作一步步提交:<br><img src=\"http://ww1.sinaimg.cn/large/006tNc79gy1g3zkxjw8nzj30sy0iyae8.jpg\" alt=\"commit history\"><br>执行完成后<code>git rebase --contine</code>，即达到了我们想要的效果，即把一个提交拆分成了两个提交，最终结果如下图<br><img src=\"http://ww4.sinaimg.cn/large/006tNc79gy1g3zklfx4roj316i09ujul.jpg\" alt=\"result\"></p>\n<h3 id=\"删除提交\"><a href=\"#删除提交\" class=\"headerlink\" title=\"删除提交\"></a>删除提交</h3><p>如果想删除某个提交，使用 <code>git rebase -i ***</code> 后直接在编辑器中使用drop action删除那一行 commit 即可,如果出现冲突，手动解决冲突后再执行<code>git rebase --continue</code>即可<br>下图为我执行操作删除’master commit 4’这个提交点及最终的执行结果<br><img src=\"http://ww4.sinaimg.cn/large/006tNc79gy1g3zlgmqe3gj30y20ho0wi.jpg\" alt><br><img src=\"http://ww1.sinaimg.cn/large/006tNc79gy1g3zlhedw0bj317007mmzq.jpg\" alt></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>最后，对这两个命令做个总结。<br><img src=\"http://ww4.sinaimg.cn/large/006tNc79gy1g3znx8capzj31h40dwk64.jpg\" alt=\"总结\"></p>\n<p>这两个命令各有优劣，很难概括哪一个最好，那到底该如何选择呢？<br>个人理解：</p>\n<ul>\n<li>团队成员对两种命令的熟悉程度</li>\n<li>个人喜好：比如有人倾向清晰的阅读性，有人不喜欢多次处理冲突</li>\n</ul>\n<p>一般建议：</p>\n<ul>\n<li>开发过程中，合并上游分支（如master）要频繁（切忌两耳不闻窗外事，一心闷头写代码）时使用rebase，有冲突提前就fix掉</li>\n<li>测试通过后合并到上游分支时，可以使用merge，保证所有提交点的可追溯性</li>\n</ul>\n<p><strong>不管选择哪个，作为一个开发人员，两种合并方式的异同都建议大家掌握。</strong></p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://www.atlassian.com/git/tutorials/merging-vs-rebasing\" target=\"_blank\" rel=\"noopener\">Merging vs. Rebasing</a><br><a href=\"https://www.cnblogs.com/xueweihan/p/5743327.html\" target=\"_blank\" rel=\"noopener\">merge和rebase的区别</a></p>\n"},{"title":"学习笔记-js中难点梳理","date":"2019-06-18T01:44:30.000Z","_content":"\n`js`的语言特性导致有很多知识点在日常开发中容易混淆或者难理解的，在此通过代码示例和文字总结加深理解，同时也方便后续复习查阅\n\n# this\n与其它语言相比，函数的`this`关键字在`javascript`中表现略不同。此外，在严格模式、非严格模式及`es2015`的箭头函数中也各有不同。\n\n** 一般情况下（箭头函数除外）,`this`的指向与声明位置无关，与调用位置有关 **\n\n```js\nvar name=\"window\";\nvar obj={\n  name:'obj',\n  showName:function(){\n    console.log(this.name);\n  }\n}\nvar otherObj={\n  name:'otherObj',\n  showName:obj.showName\n}\nobj.showName(); //obj\notherObj.showName();//otherObj\n```\n\n<p class=\"tip\">\n  此时调用`showName`方法的是`obj`，故`this`指向`obj`\n</p>\n\n```js\n\nvar anotherObj={\n  name:'anotherObj',\n  showName:function(){\n    //tempFunc =function(){console.log(this.name)}\n    var tempFunc=obj.showName;\n    tempFunc();\n  }\n}\nvar anonymousObj={\n  name:'anonymousObj',\n  foo:function(){\n    console.log(this.name)\n  },\n  showName:function(){\n    //this.foo=function(){\n    //   console.log(this.name)\n    // }\n    // cb=this.foo,cb是一个匿名函数，\n    // 匿名函数在执行时，this也是指向window\n    (function(cb){\n      cb();\n    })(this.foo)\n  }\n}\n\nanotherObj.showName() ;//undefined\nanonymousObj.showName();//undefined\n```\n<p class=\"tip\">\n  1. 在`anotherObj`的作用域中调用的`tempFunc`，`tempFunc`中的`this`无明确指向，故指向`window`\n  2. 在`anonymousObj`的作用域中执行匿名函数，this也是指向window\n</p>\n\n```js\nvar obj={\n  name:'obj',\n  showName:function(){\n    console.log(this.name);\n  }\n}\nvar anotherObj={\n  name:'anotherObj',\n  showName:function(){\n    var tempFunc=obj.showName;\n    tempFunc();\n  }\n}\nobj.showName.apply();//undefined 此时虽然时obj调用showName方法\nobj.showName.apply(anotherObj); //anotherObj \n```\n<p class=\"tip\">\n  `apply`可以改变`this`的指向为第一个参数\n  故在`obj.showName.apply()`中this指向空，即window\n  在`obj.showName.apply(anotherObj)`中this指向空anotherObj\n</p>\n\n```js\nvar arrowObj={\n  name:'arrowObj',\n  showName:()=>{\n    //this 指向undefined（即全局对象window），具体可查看babel转义后的结果\n    console.log(this.name); \n  }\n}\nvar arrowObj1={\n  name:'arrowObj1',\n  showName:function(){\n    setTimeout(()=>{\n      console.log(this.name);\n    },0)\n  }\n}\narrowObj.showName();//undefined\narrowObj1.showName(); //'arrowObj1'\n\n```\n<p class=\"tip\">\n  在es6中，箭头函数（又称lamdba表达式），是在声明的时候绑定this的而非调用时\n</p>\n\n```js\n(function(){\n  \"use strict\";\n  var name='snowdrop'\n  console.log(this.name); //Uncaught TypeError: Cannot read property 'name' of undefined  \n  function fun() { return this; }\n  console.assert(fun() === undefined);\n  console.assert(fun.apply(null) === null);\n  console.assert(fun.call(undefined) === undefined);\n})()\n```\n<p class=\"tip\">\n  在严格模式和非严格模式下，this的指向还略有不同\n  从上述结果可知，严格模式下，this没有明确指向时,指向undefinde而非window\n</p>\n\n**从上述代码片段及运行结果可得知，`this`有以下特性（坑）**\n\n* this 的指向和调用位置有关，与声明位置无关\n* 没有明确指向的时候，this指向window\n* 在浏览器环境下，setTimeout、setInterval和匿名函数执行时this的指向为全局对象window\n* call和apply能够强制改变this的指向为当前的第一个传参\n* 在es6中，箭头函数（又称lamdba表达式），是在声明的时候绑定this的\n* 严格模式下，this没有明确指向时,指向undefinde而非window\n\n# 作用域\njs中的作用域也是一个非常重要和易出错的地方，话不多说，先上代码\n\n```js\nfoo();//undefined\n function foo(){\n   console.log(a);\n   var a=2;\n }\n```\n<p class=\"tip\">\n上面的代码在执行时别js引擎解析成如下的代码\n`function foo(){\n  var a;//undefined\n  console.log(a);\n  a=2; \n}\nfoo();`\n</p>\n\n```\nshow();//TypeError: show is not a function\nvar show=function (){\n  console.log(1)\n}\n```\n<p class=\"tip\">\n上面代码等价与下面\n`var show;//undefined\nshow ();\nshow=function (){\n  console.log(1)\n}`\n</p>\n\n```js\ntypeof show; // function  \nvar show=11;\nfunction show(){\n  console.log('show')\n}\n```\n<p class=\"tip\">\n上面代码等价于以下代码\nfunction show(){\n  console.log('show')\n}\nvar show=11;\ntypeof show;\n故由此可知，函数的变量提升优于变量\n</p>\n\n```\nif(someVar ===undefined){\n  var someVar=1;\n  console.log(someVar)\n}\n```\n<p class=\"tip\">\n虽然此处有`if`,但js中没有块级作用域的概念，变量`someVar`依然也会发生作用域提升。\n</p>\n\n**从上述代码片段及运行结果可得知，js的作用域有以下特性**\n\n* 函数和变量的声明都会产生作用域提升\n* 变量的上升只是声明会提升，赋值不会\n* 函数表达式（包括匿名和具名）不会发生作用域提升\n* 函数提升的优先级高于变量，且不会被同名变量覆盖\n* 声明的提升不会被条件判断给控制住（不过不同浏览器的实现不同，有的会控制有的不会控制）\n\n# 继承\n\n*TODO 此部分还有很多没理解，待深究*\n\n## [es6中的继承特性](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes)\n* 使用extends关键字\n* 子类继承父类时，子类的构造函数需要显式的调用下父类的super方法\n* 可以定义static方法\n\n## [ES5实现继承的黑魔法](http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html)\n\n### 原型链继承\n\n```js\nfunction Super(){\n  this.name='super';\n}\nSuper.prototype.showName=function(){\n  console.log(this.name)\n}\n\nfunction Sub(){\n  this.name='sub';\n  this.age=24;\n}\nSub.prototype=new Super();\nSub.prototype.showAge=function(){\n  console.log(this.age)\n}\n```\n<p class=\"tip\">\n原型链继承的缺点：父类的构造函数会在创建子类及实例化子类的时候分别各执行了一次，造成了内存的浪费\n</p>\n\n### 组合继承\n\n由于原型继承存在上述缺点，所有就有了组合继承，F是空对象，所以几乎不占内存\n```js\nfunction extend(Child, Parent) {\n　　　　var F = function(){};\n　　　　F.prototype = Parent.prototype;\n　　　　Child.prototype = new F();\n　　　　Child.prototype.constructor = Child;\n　　　　Child.uber = Parent.prototype;\n　　}\n\n//使用的时候，方法如下\nextend(Cat,Animal);\nvar cat1 = new Cat(\"大毛\",\"黄色\");\nalert(cat1.species); // 动物\n```\n\n# 跨域\n\n跨域的定义：协议&域名&端口有任何一个不相同，则称这两个域名是跨域的\n\n跨域的限制?\n\n1. Cookie、localstorage、indexDB无法读取\n2. DOM无法取得\n3. ajax网络请求无法发出\n\n常用的跨域方式有以下5种\n* jsonp\n* 服务器请求头设置允许跨域\n* iframe+hash传值\n* iframe+name传值\n* postMessage\n\n下面借助实现方式及细节来介绍下5种跨域方式，具体代码可参见[github](https://github.com/snowlotus/homework/tree/master/learn-js/crossSite)\n\n## jsonp\n```js\n//定义一个全局的回调方法\nwindow.xxx = function (value) {\n  console.log(value)\n}\nvar script = document.createElement('script')\n\n//向服务器发起jsonp请求，传递约定好的callback参数\nscript.src = 'http://x.localhost.com:7001/json?callback=xxx'\ndocument.body.appendChild(script)\n```\n\n```node.js\napp.get('/json', app.jsonp({ callback: 'callback' }), app.controller.json.index)\n```\n\n<p class=\"tip\">\n  在js中需要定义一个全局方法，方法名你和服务端约定好的callback方法名，方法体为拿到返回值后的执行逻辑\n  在服务端代码（本处用node实现），接受callback请求，执行逻辑返回一个json数据\n  该方法只支持get请求，即使使用jquery的jsonp方法，type设为POST，也会自动变为GET\n</p>\n\n## Access-Control-Allow-Origin\n\n本方式是在服务端配置针对某个域名的请求设置是否允许跨域，即可以在响应头中通过代码实现，也可以在如nginx服务器配置项中设置，本次以代码的方式加以说明\n\n```node.js\nmodule.exports = app => {\n  class CrosController extends app.Controller {\n    * index(req) {\n      // https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS\n      /* comment:设置响应头Access-Control-Allow-Origin \n      设置为* ，表示该资源可以被任意外域访问，\n      但会导致浏览器cookie无法发送到服务器，即使配置Access-Control-Allow-Credentials：true 也不行 */\n\n      // this.ctx.set('Access-Control-Allow-Origin', '*')\n\n      /* comment: \n      如果我们想要 http://*.localhost.com 都支持跨域怎么办？\n      首先肯定不能直接写this.ctx.set('Access-Control-Allow-Origin', 'http://*.localhost.com')\n      这样只会对http://*.localhost.com 这个域名才跨域生效\n      见上述正则\n      */\n      this.ctx.set('Access-Control-Allow-Origin', originReg(req.header.origin))\n\n      /* comment：如何把Cookie发到服务器？\n      一方面要服务器同意，指定Access-Control-Allow-Credentials:true\n      另一方面，开发者必须在AJAX请求中打开withCredentials属性。xhr.withCredentials = true;\n      */\n     this.ctx.set('Access-Control-Allow-Credentials','true')\n      this.ctx.body = { msg: 'hello world' }\n    }\n  }\n  return CrosController\n}\n```\n\n## iframe hash or name\n\n这两种方式都差不多，将需要跨域的域通过iframe的方式加载，通过name或hash值的设置来达到跨域的目的。不太常用，仅做了解不做详细说明，具体可看例子中的`3.js`和`4.js`这两个文件\n\n## postMessage\n\npostMessage是html5引入的API,允许来自不同源的脚本采用异步方式进行有效的通信,可以实现跨文本文档,多窗口,跨域消息传递,具体实现方式如下。\n\n**父窗体创建跨域iframe并发送信息**\n\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n        <title>跨域POST消息发送</title>\n        <script type=\"text/JavaScript\">    \n            // sendPost 通过postMessage实现跨域通信将表单信息发送到 moweide.gitcafe.io上,\n            // 并取得返回的数据    \n            function sendPost() {        \n                // 获取id为otherPage的iframe窗口对象        \n                var iframeWin = document.getElementById(\"otherPage\").contentWindow;        \n                // 向该窗口发送消息        \n                iframeWin.postMessage(document.getElementById(\"message\").value, \n                    'http://moweide.gitcafe.io');    \n            }    \n            // 监听跨域请求的返回    \n            window.addEventListener(\"message\", function(event) {        \n                console.log(event, event.data);    \n            }, false);\n        </script>\n    </head>\n    <body> \n        <textarea id=\"message\"></textarea> \n        <input type=\"button\" value=\"发送\" onclick=\"sendPost()\"> \n        <iframe\n            src=\"http://moweide.gitcafe.io/other-domain.html\" id=\"otherPage\"\n            style=\"display:none\"></iframe>\n    </body>\n</html>\n```\n\n**子窗体接收信息并处理**\n\n```\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n        <title>POST Handler</title>\n        <script src=\"//code.jquery.com/jquery-1.11.0.min.js\"></script>\n        <script type=\"text/JavaScript\">\n            window.addEventListener(\"message\", function( event ) {\n                // 监听父窗口发送过来的数据向服务器发送post请求\n                var data = event.data;\n                $.ajax({\n                    // 注意这里的url只是一个示例.实际练习的时候你需要自己想办法提供一个后台接口\n                    type: 'POST', \n                    url: 'http://moweide.gitcafe.io/getData',\n                    data: \"info=\" + data,\n                    dataType: \"json\"\n                }).done(function(res){        \n                    //将请求成功返回的数据通过postMessage发送给父窗口        \n                    window.parent.postMessage(res, \"*\");    \n                }).fail(function(res){        \n                    //将请求失败返回的数据通过postMessage发送给父窗口        \n                    window.parent.postMessage(res, \"*\");    \n                });\n            }, false);\n        </script>\n    </head>\n\n    <body></body>\n</html>\n```","source":"_posts/note-of-the-difficulty-in-javascript.md","raw":"---\ntitle: 学习笔记-js中难点梳理\ndate: 2019-06-18 09:44:30\ntags: [学习笔记,js,知识梳理]\n---\n\n`js`的语言特性导致有很多知识点在日常开发中容易混淆或者难理解的，在此通过代码示例和文字总结加深理解，同时也方便后续复习查阅\n\n# this\n与其它语言相比，函数的`this`关键字在`javascript`中表现略不同。此外，在严格模式、非严格模式及`es2015`的箭头函数中也各有不同。\n\n** 一般情况下（箭头函数除外）,`this`的指向与声明位置无关，与调用位置有关 **\n\n```js\nvar name=\"window\";\nvar obj={\n  name:'obj',\n  showName:function(){\n    console.log(this.name);\n  }\n}\nvar otherObj={\n  name:'otherObj',\n  showName:obj.showName\n}\nobj.showName(); //obj\notherObj.showName();//otherObj\n```\n\n<p class=\"tip\">\n  此时调用`showName`方法的是`obj`，故`this`指向`obj`\n</p>\n\n```js\n\nvar anotherObj={\n  name:'anotherObj',\n  showName:function(){\n    //tempFunc =function(){console.log(this.name)}\n    var tempFunc=obj.showName;\n    tempFunc();\n  }\n}\nvar anonymousObj={\n  name:'anonymousObj',\n  foo:function(){\n    console.log(this.name)\n  },\n  showName:function(){\n    //this.foo=function(){\n    //   console.log(this.name)\n    // }\n    // cb=this.foo,cb是一个匿名函数，\n    // 匿名函数在执行时，this也是指向window\n    (function(cb){\n      cb();\n    })(this.foo)\n  }\n}\n\nanotherObj.showName() ;//undefined\nanonymousObj.showName();//undefined\n```\n<p class=\"tip\">\n  1. 在`anotherObj`的作用域中调用的`tempFunc`，`tempFunc`中的`this`无明确指向，故指向`window`\n  2. 在`anonymousObj`的作用域中执行匿名函数，this也是指向window\n</p>\n\n```js\nvar obj={\n  name:'obj',\n  showName:function(){\n    console.log(this.name);\n  }\n}\nvar anotherObj={\n  name:'anotherObj',\n  showName:function(){\n    var tempFunc=obj.showName;\n    tempFunc();\n  }\n}\nobj.showName.apply();//undefined 此时虽然时obj调用showName方法\nobj.showName.apply(anotherObj); //anotherObj \n```\n<p class=\"tip\">\n  `apply`可以改变`this`的指向为第一个参数\n  故在`obj.showName.apply()`中this指向空，即window\n  在`obj.showName.apply(anotherObj)`中this指向空anotherObj\n</p>\n\n```js\nvar arrowObj={\n  name:'arrowObj',\n  showName:()=>{\n    //this 指向undefined（即全局对象window），具体可查看babel转义后的结果\n    console.log(this.name); \n  }\n}\nvar arrowObj1={\n  name:'arrowObj1',\n  showName:function(){\n    setTimeout(()=>{\n      console.log(this.name);\n    },0)\n  }\n}\narrowObj.showName();//undefined\narrowObj1.showName(); //'arrowObj1'\n\n```\n<p class=\"tip\">\n  在es6中，箭头函数（又称lamdba表达式），是在声明的时候绑定this的而非调用时\n</p>\n\n```js\n(function(){\n  \"use strict\";\n  var name='snowdrop'\n  console.log(this.name); //Uncaught TypeError: Cannot read property 'name' of undefined  \n  function fun() { return this; }\n  console.assert(fun() === undefined);\n  console.assert(fun.apply(null) === null);\n  console.assert(fun.call(undefined) === undefined);\n})()\n```\n<p class=\"tip\">\n  在严格模式和非严格模式下，this的指向还略有不同\n  从上述结果可知，严格模式下，this没有明确指向时,指向undefinde而非window\n</p>\n\n**从上述代码片段及运行结果可得知，`this`有以下特性（坑）**\n\n* this 的指向和调用位置有关，与声明位置无关\n* 没有明确指向的时候，this指向window\n* 在浏览器环境下，setTimeout、setInterval和匿名函数执行时this的指向为全局对象window\n* call和apply能够强制改变this的指向为当前的第一个传参\n* 在es6中，箭头函数（又称lamdba表达式），是在声明的时候绑定this的\n* 严格模式下，this没有明确指向时,指向undefinde而非window\n\n# 作用域\njs中的作用域也是一个非常重要和易出错的地方，话不多说，先上代码\n\n```js\nfoo();//undefined\n function foo(){\n   console.log(a);\n   var a=2;\n }\n```\n<p class=\"tip\">\n上面的代码在执行时别js引擎解析成如下的代码\n`function foo(){\n  var a;//undefined\n  console.log(a);\n  a=2; \n}\nfoo();`\n</p>\n\n```\nshow();//TypeError: show is not a function\nvar show=function (){\n  console.log(1)\n}\n```\n<p class=\"tip\">\n上面代码等价与下面\n`var show;//undefined\nshow ();\nshow=function (){\n  console.log(1)\n}`\n</p>\n\n```js\ntypeof show; // function  \nvar show=11;\nfunction show(){\n  console.log('show')\n}\n```\n<p class=\"tip\">\n上面代码等价于以下代码\nfunction show(){\n  console.log('show')\n}\nvar show=11;\ntypeof show;\n故由此可知，函数的变量提升优于变量\n</p>\n\n```\nif(someVar ===undefined){\n  var someVar=1;\n  console.log(someVar)\n}\n```\n<p class=\"tip\">\n虽然此处有`if`,但js中没有块级作用域的概念，变量`someVar`依然也会发生作用域提升。\n</p>\n\n**从上述代码片段及运行结果可得知，js的作用域有以下特性**\n\n* 函数和变量的声明都会产生作用域提升\n* 变量的上升只是声明会提升，赋值不会\n* 函数表达式（包括匿名和具名）不会发生作用域提升\n* 函数提升的优先级高于变量，且不会被同名变量覆盖\n* 声明的提升不会被条件判断给控制住（不过不同浏览器的实现不同，有的会控制有的不会控制）\n\n# 继承\n\n*TODO 此部分还有很多没理解，待深究*\n\n## [es6中的继承特性](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes)\n* 使用extends关键字\n* 子类继承父类时，子类的构造函数需要显式的调用下父类的super方法\n* 可以定义static方法\n\n## [ES5实现继承的黑魔法](http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html)\n\n### 原型链继承\n\n```js\nfunction Super(){\n  this.name='super';\n}\nSuper.prototype.showName=function(){\n  console.log(this.name)\n}\n\nfunction Sub(){\n  this.name='sub';\n  this.age=24;\n}\nSub.prototype=new Super();\nSub.prototype.showAge=function(){\n  console.log(this.age)\n}\n```\n<p class=\"tip\">\n原型链继承的缺点：父类的构造函数会在创建子类及实例化子类的时候分别各执行了一次，造成了内存的浪费\n</p>\n\n### 组合继承\n\n由于原型继承存在上述缺点，所有就有了组合继承，F是空对象，所以几乎不占内存\n```js\nfunction extend(Child, Parent) {\n　　　　var F = function(){};\n　　　　F.prototype = Parent.prototype;\n　　　　Child.prototype = new F();\n　　　　Child.prototype.constructor = Child;\n　　　　Child.uber = Parent.prototype;\n　　}\n\n//使用的时候，方法如下\nextend(Cat,Animal);\nvar cat1 = new Cat(\"大毛\",\"黄色\");\nalert(cat1.species); // 动物\n```\n\n# 跨域\n\n跨域的定义：协议&域名&端口有任何一个不相同，则称这两个域名是跨域的\n\n跨域的限制?\n\n1. Cookie、localstorage、indexDB无法读取\n2. DOM无法取得\n3. ajax网络请求无法发出\n\n常用的跨域方式有以下5种\n* jsonp\n* 服务器请求头设置允许跨域\n* iframe+hash传值\n* iframe+name传值\n* postMessage\n\n下面借助实现方式及细节来介绍下5种跨域方式，具体代码可参见[github](https://github.com/snowlotus/homework/tree/master/learn-js/crossSite)\n\n## jsonp\n```js\n//定义一个全局的回调方法\nwindow.xxx = function (value) {\n  console.log(value)\n}\nvar script = document.createElement('script')\n\n//向服务器发起jsonp请求，传递约定好的callback参数\nscript.src = 'http://x.localhost.com:7001/json?callback=xxx'\ndocument.body.appendChild(script)\n```\n\n```node.js\napp.get('/json', app.jsonp({ callback: 'callback' }), app.controller.json.index)\n```\n\n<p class=\"tip\">\n  在js中需要定义一个全局方法，方法名你和服务端约定好的callback方法名，方法体为拿到返回值后的执行逻辑\n  在服务端代码（本处用node实现），接受callback请求，执行逻辑返回一个json数据\n  该方法只支持get请求，即使使用jquery的jsonp方法，type设为POST，也会自动变为GET\n</p>\n\n## Access-Control-Allow-Origin\n\n本方式是在服务端配置针对某个域名的请求设置是否允许跨域，即可以在响应头中通过代码实现，也可以在如nginx服务器配置项中设置，本次以代码的方式加以说明\n\n```node.js\nmodule.exports = app => {\n  class CrosController extends app.Controller {\n    * index(req) {\n      // https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS\n      /* comment:设置响应头Access-Control-Allow-Origin \n      设置为* ，表示该资源可以被任意外域访问，\n      但会导致浏览器cookie无法发送到服务器，即使配置Access-Control-Allow-Credentials：true 也不行 */\n\n      // this.ctx.set('Access-Control-Allow-Origin', '*')\n\n      /* comment: \n      如果我们想要 http://*.localhost.com 都支持跨域怎么办？\n      首先肯定不能直接写this.ctx.set('Access-Control-Allow-Origin', 'http://*.localhost.com')\n      这样只会对http://*.localhost.com 这个域名才跨域生效\n      见上述正则\n      */\n      this.ctx.set('Access-Control-Allow-Origin', originReg(req.header.origin))\n\n      /* comment：如何把Cookie发到服务器？\n      一方面要服务器同意，指定Access-Control-Allow-Credentials:true\n      另一方面，开发者必须在AJAX请求中打开withCredentials属性。xhr.withCredentials = true;\n      */\n     this.ctx.set('Access-Control-Allow-Credentials','true')\n      this.ctx.body = { msg: 'hello world' }\n    }\n  }\n  return CrosController\n}\n```\n\n## iframe hash or name\n\n这两种方式都差不多，将需要跨域的域通过iframe的方式加载，通过name或hash值的设置来达到跨域的目的。不太常用，仅做了解不做详细说明，具体可看例子中的`3.js`和`4.js`这两个文件\n\n## postMessage\n\npostMessage是html5引入的API,允许来自不同源的脚本采用异步方式进行有效的通信,可以实现跨文本文档,多窗口,跨域消息传递,具体实现方式如下。\n\n**父窗体创建跨域iframe并发送信息**\n\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n        <title>跨域POST消息发送</title>\n        <script type=\"text/JavaScript\">    \n            // sendPost 通过postMessage实现跨域通信将表单信息发送到 moweide.gitcafe.io上,\n            // 并取得返回的数据    \n            function sendPost() {        \n                // 获取id为otherPage的iframe窗口对象        \n                var iframeWin = document.getElementById(\"otherPage\").contentWindow;        \n                // 向该窗口发送消息        \n                iframeWin.postMessage(document.getElementById(\"message\").value, \n                    'http://moweide.gitcafe.io');    \n            }    \n            // 监听跨域请求的返回    \n            window.addEventListener(\"message\", function(event) {        \n                console.log(event, event.data);    \n            }, false);\n        </script>\n    </head>\n    <body> \n        <textarea id=\"message\"></textarea> \n        <input type=\"button\" value=\"发送\" onclick=\"sendPost()\"> \n        <iframe\n            src=\"http://moweide.gitcafe.io/other-domain.html\" id=\"otherPage\"\n            style=\"display:none\"></iframe>\n    </body>\n</html>\n```\n\n**子窗体接收信息并处理**\n\n```\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n        <title>POST Handler</title>\n        <script src=\"//code.jquery.com/jquery-1.11.0.min.js\"></script>\n        <script type=\"text/JavaScript\">\n            window.addEventListener(\"message\", function( event ) {\n                // 监听父窗口发送过来的数据向服务器发送post请求\n                var data = event.data;\n                $.ajax({\n                    // 注意这里的url只是一个示例.实际练习的时候你需要自己想办法提供一个后台接口\n                    type: 'POST', \n                    url: 'http://moweide.gitcafe.io/getData',\n                    data: \"info=\" + data,\n                    dataType: \"json\"\n                }).done(function(res){        \n                    //将请求成功返回的数据通过postMessage发送给父窗口        \n                    window.parent.postMessage(res, \"*\");    \n                }).fail(function(res){        \n                    //将请求失败返回的数据通过postMessage发送给父窗口        \n                    window.parent.postMessage(res, \"*\");    \n                });\n            }, false);\n        </script>\n    </head>\n\n    <body></body>\n</html>\n```","slug":"note-of-the-difficulty-in-javascript","published":1,"updated":"2019-06-24T07:20:44.122Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2mo4myf001ddt47bhbxc78b","content":"<p><code>js</code>的语言特性导致有很多知识点在日常开发中容易混淆或者难理解的，在此通过代码示例和文字总结加深理解，同时也方便后续复习查阅</p>\n<h1 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h1><p>与其它语言相比，函数的<code>this</code>关键字在<code>javascript</code>中表现略不同。此外，在严格模式、非严格模式及<code>es2015</code>的箭头函数中也各有不同。</p>\n<p><strong> 一般情况下（箭头函数除外）,<code>this</code>的指向与声明位置无关，与调用位置有关 </strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name=<span class=\"string\">\"window\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj=&#123;</span><br><span class=\"line\">  name:<span class=\"string\">'obj'</span>,</span><br><span class=\"line\">  showName:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> otherObj=&#123;</span><br><span class=\"line\">  name:<span class=\"string\">'otherObj'</span>,</span><br><span class=\"line\">  showName:obj.showName</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.showName(); <span class=\"comment\">//obj</span></span><br><span class=\"line\">otherObj.showName();<span class=\"comment\">//otherObj</span></span><br></pre></td></tr></table></figure>\n<p class=\"tip\"><br>  此时调用<code>showName</code>方法的是<code>obj</code>，故<code>this</code>指向<code>obj</code><br></p>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> anotherObj=&#123;</span><br><span class=\"line\">  name:<span class=\"string\">'anotherObj'</span>,</span><br><span class=\"line\">  showName:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//tempFunc =function()&#123;console.log(this.name)&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> tempFunc=obj.showName;</span><br><span class=\"line\">    tempFunc();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> anonymousObj=&#123;</span><br><span class=\"line\">  name:<span class=\"string\">'anonymousObj'</span>,</span><br><span class=\"line\">  foo:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  showName:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//this.foo=function()&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//   console.log(this.name)</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// cb=this.foo,cb是一个匿名函数，</span></span><br><span class=\"line\">    <span class=\"comment\">// 匿名函数在执行时，this也是指向window</span></span><br><span class=\"line\">    (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">cb</span>)</span>&#123;</span><br><span class=\"line\">      cb();</span><br><span class=\"line\">    &#125;)(<span class=\"keyword\">this</span>.foo)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">anotherObj.showName() ;<span class=\"comment\">//undefined</span></span><br><span class=\"line\">anonymousObj.showName();<span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure>\n<p class=\"tip\"><br>  1. 在<code>anotherObj</code>的作用域中调用的<code>tempFunc</code>，<code>tempFunc</code>中的<code>this</code>无明确指向，故指向<code>window</code><br>  2. 在<code>anonymousObj</code>的作用域中执行匿名函数，this也是指向window<br></p>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj=&#123;</span><br><span class=\"line\">  name:<span class=\"string\">'obj'</span>,</span><br><span class=\"line\">  showName:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> anotherObj=&#123;</span><br><span class=\"line\">  name:<span class=\"string\">'anotherObj'</span>,</span><br><span class=\"line\">  showName:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tempFunc=obj.showName;</span><br><span class=\"line\">    tempFunc();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.showName.apply();<span class=\"comment\">//undefined 此时虽然时obj调用showName方法</span></span><br><span class=\"line\">obj.showName.apply(anotherObj); <span class=\"comment\">//anotherObj</span></span><br></pre></td></tr></table></figure>\n<p class=\"tip\"><br>  <code>apply</code>可以改变<code>this</code>的指向为第一个参数<br>  故在<code>obj.showName.apply()</code>中this指向空，即window<br>  在<code>obj.showName.apply(anotherObj)</code>中this指向空anotherObj<br></p>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arrowObj=&#123;</span><br><span class=\"line\">  name:<span class=\"string\">'arrowObj'</span>,</span><br><span class=\"line\">  showName:<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//this 指向undefined（即全局对象window），具体可查看babel转义后的结果</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name); </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arrowObj1=&#123;</span><br><span class=\"line\">  name:<span class=\"string\">'arrowObj1'</span>,</span><br><span class=\"line\">  showName:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;,<span class=\"number\">0</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">arrowObj.showName();<span class=\"comment\">//undefined</span></span><br><span class=\"line\">arrowObj1.showName(); <span class=\"comment\">//'arrowObj1'</span></span><br></pre></td></tr></table></figure>\n<p class=\"tip\"><br>  在es6中，箭头函数（又称lamdba表达式），是在声明的时候绑定this的而非调用时<br></p>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"meta\">  \"use strict\"</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> name=<span class=\"string\">'snowdrop'</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name); <span class=\"comment\">//Uncaught TypeError: Cannot read property 'name' of undefined  </span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.assert(fun() === <span class=\"literal\">undefined</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.assert(fun.apply(<span class=\"literal\">null</span>) === <span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.assert(fun.call(<span class=\"literal\">undefined</span>) === <span class=\"literal\">undefined</span>);</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n<p class=\"tip\"><br>  在严格模式和非严格模式下，this的指向还略有不同<br>  从上述结果可知，严格模式下，this没有明确指向时,指向undefinde而非window<br></p>\n\n<p><strong>从上述代码片段及运行结果可得知，<code>this</code>有以下特性（坑）</strong></p>\n<ul>\n<li>this 的指向和调用位置有关，与声明位置无关</li>\n<li>没有明确指向的时候，this指向window</li>\n<li>在浏览器环境下，setTimeout、setInterval和匿名函数执行时this的指向为全局对象window</li>\n<li>call和apply能够强制改变this的指向为当前的第一个传参</li>\n<li>在es6中，箭头函数（又称lamdba表达式），是在声明的时候绑定this的</li>\n<li>严格模式下，this没有明确指向时,指向undefinde而非window</li>\n</ul>\n<h1 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h1><p>js中的作用域也是一个非常重要和易出错的地方，话不多说，先上代码</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo();<span class=\"comment\">//undefined</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">   <span class=\"keyword\">var</span> a=<span class=\"number\">2</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p class=\"tip\"><br>上面的代码在执行时别js引擎解析成如下的代码<br><code>function foo(){\n  var a;//undefined\n  console.log(a);\n  a=2; \n}\nfoo();</code><br></p>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show();//TypeError: show is not a function</span><br><span class=\"line\">var show=function ()&#123;</span><br><span class=\"line\">  console.log(1)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p class=\"tip\"><br>上面代码等价与下面<br><code>var show;//undefined\nshow ();\nshow=function (){\n  console.log(1)\n}</code><br></p>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> show; <span class=\"comment\">// function  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> show=<span class=\"number\">11</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'show'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p class=\"tip\"><br>上面代码等价于以下代码<br>function show(){<br>  console.log(‘show’)<br>}<br>var show=11;<br>typeof show;<br>故由此可知，函数的变量提升优于变量<br></p>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(someVar ===undefined)&#123;</span><br><span class=\"line\">  var someVar=1;</span><br><span class=\"line\">  console.log(someVar)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p class=\"tip\"><br>虽然此处有<code>if</code>,但js中没有块级作用域的概念，变量<code>someVar</code>依然也会发生作用域提升。<br></p>\n\n<p><strong>从上述代码片段及运行结果可得知，js的作用域有以下特性</strong></p>\n<ul>\n<li>函数和变量的声明都会产生作用域提升</li>\n<li>变量的上升只是声明会提升，赋值不会</li>\n<li>函数表达式（包括匿名和具名）不会发生作用域提升</li>\n<li>函数提升的优先级高于变量，且不会被同名变量覆盖</li>\n<li>声明的提升不会被条件判断给控制住（不过不同浏览器的实现不同，有的会控制有的不会控制）</li>\n</ul>\n<h1 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h1><p><em>TODO 此部分还有很多没理解，待深究</em></p>\n<h2 id=\"es6中的继承特性\"><a href=\"#es6中的继承特性\" class=\"headerlink\" title=\"es6中的继承特性\"></a><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes\" target=\"_blank\" rel=\"noopener\">es6中的继承特性</a></h2><ul>\n<li>使用extends关键字</li>\n<li>子类继承父类时，子类的构造函数需要显式的调用下父类的super方法</li>\n<li>可以定义static方法</li>\n</ul>\n<h2 id=\"ES5实现继承的黑魔法\"><a href=\"#ES5实现继承的黑魔法\" class=\"headerlink\" title=\"ES5实现继承的黑魔法\"></a><a href=\"http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html\" target=\"_blank\" rel=\"noopener\">ES5实现继承的黑魔法</a></h2><h3 id=\"原型链继承\"><a href=\"#原型链继承\" class=\"headerlink\" title=\"原型链继承\"></a>原型链继承</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Super</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name=<span class=\"string\">'super'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Super.prototype.showName=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Sub</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name=<span class=\"string\">'sub'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age=<span class=\"number\">24</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Sub.prototype=<span class=\"keyword\">new</span> Super();</span><br><span class=\"line\">Sub.prototype.showAge=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.age)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p class=\"tip\"><br>原型链继承的缺点：父类的构造函数会在创建子类及实例化子类的时候分别各执行了一次，造成了内存的浪费<br></p>\n\n<h3 id=\"组合继承\"><a href=\"#组合继承\" class=\"headerlink\" title=\"组合继承\"></a>组合继承</h3><p>由于原型继承存在上述缺点，所有就有了组合继承，F是空对象，所以几乎不占内存<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">extend</span>(<span class=\"params\">Child, Parent</span>) </span>&#123;</span><br><span class=\"line\">　　　　<span class=\"keyword\">var</span> F = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">　　　　F.prototype = Parent.prototype;</span><br><span class=\"line\">　　　　Child.prototype = <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">　　　　Child.prototype.constructor = Child;</span><br><span class=\"line\">　　　　Child.uber = Parent.prototype;</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用的时候，方法如下</span></span><br><span class=\"line\">extend(Cat,Animal);</span><br><span class=\"line\"><span class=\"keyword\">var</span> cat1 = <span class=\"keyword\">new</span> Cat(<span class=\"string\">\"大毛\"</span>,<span class=\"string\">\"黄色\"</span>);</span><br><span class=\"line\">alert(cat1.species); <span class=\"comment\">// 动物</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h1><p>跨域的定义：协议&amp;域名&amp;端口有任何一个不相同，则称这两个域名是跨域的</p>\n<p>跨域的限制?</p>\n<ol>\n<li>Cookie、localstorage、indexDB无法读取</li>\n<li>DOM无法取得</li>\n<li>ajax网络请求无法发出</li>\n</ol>\n<p>常用的跨域方式有以下5种</p>\n<ul>\n<li>jsonp</li>\n<li>服务器请求头设置允许跨域</li>\n<li>iframe+hash传值</li>\n<li>iframe+name传值</li>\n<li>postMessage</li>\n</ul>\n<p>下面借助实现方式及细节来介绍下5种跨域方式，具体代码可参见<a href=\"https://github.com/snowlotus/homework/tree/master/learn-js/crossSite\" target=\"_blank\" rel=\"noopener\">github</a></p>\n<h2 id=\"jsonp\"><a href=\"#jsonp\" class=\"headerlink\" title=\"jsonp\"></a>jsonp</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义一个全局的回调方法</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.xxx = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'script'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//向服务器发起jsonp请求，传递约定好的callback参数</span></span><br><span class=\"line\">script.src = <span class=\"string\">'http://x.localhost.com:7001/json?callback=xxx'</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.appendChild(script)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.get(&apos;/json&apos;, app.jsonp(&#123; callback: &apos;callback&apos; &#125;), app.controller.json.index)</span><br></pre></td></tr></table></figure>\n<p class=\"tip\"><br>  在js中需要定义一个全局方法，方法名你和服务端约定好的callback方法名，方法体为拿到返回值后的执行逻辑<br>  在服务端代码（本处用node实现），接受callback请求，执行逻辑返回一个json数据<br>  该方法只支持get请求，即使使用jquery的jsonp方法，type设为POST，也会自动变为GET<br></p>\n\n<h2 id=\"Access-Control-Allow-Origin\"><a href=\"#Access-Control-Allow-Origin\" class=\"headerlink\" title=\"Access-Control-Allow-Origin\"></a>Access-Control-Allow-Origin</h2><p>本方式是在服务端配置针对某个域名的请求设置是否允许跨域，即可以在响应头中通过代码实现，也可以在如nginx服务器配置项中设置，本次以代码的方式加以说明</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = app =&gt; &#123;</span><br><span class=\"line\">  class CrosController extends app.Controller &#123;</span><br><span class=\"line\">    * index(req) &#123;</span><br><span class=\"line\">      // https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS</span><br><span class=\"line\">      /* comment:设置响应头Access-Control-Allow-Origin </span><br><span class=\"line\">      设置为* ，表示该资源可以被任意外域访问，</span><br><span class=\"line\">      但会导致浏览器cookie无法发送到服务器，即使配置Access-Control-Allow-Credentials：true 也不行 */</span><br><span class=\"line\"></span><br><span class=\"line\">      // this.ctx.set(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">      /* comment: </span><br><span class=\"line\">      如果我们想要 http://*.localhost.com 都支持跨域怎么办？</span><br><span class=\"line\">      首先肯定不能直接写this.ctx.set(&apos;Access-Control-Allow-Origin&apos;, &apos;http://*.localhost.com&apos;)</span><br><span class=\"line\">      这样只会对http://*.localhost.com 这个域名才跨域生效</span><br><span class=\"line\">      见上述正则</span><br><span class=\"line\">      */</span><br><span class=\"line\">      this.ctx.set(&apos;Access-Control-Allow-Origin&apos;, originReg(req.header.origin))</span><br><span class=\"line\"></span><br><span class=\"line\">      /* comment：如何把Cookie发到服务器？</span><br><span class=\"line\">      一方面要服务器同意，指定Access-Control-Allow-Credentials:true</span><br><span class=\"line\">      另一方面，开发者必须在AJAX请求中打开withCredentials属性。xhr.withCredentials = true;</span><br><span class=\"line\">      */</span><br><span class=\"line\">     this.ctx.set(&apos;Access-Control-Allow-Credentials&apos;,&apos;true&apos;)</span><br><span class=\"line\">      this.ctx.body = &#123; msg: &apos;hello world&apos; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return CrosController</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"iframe-hash-or-name\"><a href=\"#iframe-hash-or-name\" class=\"headerlink\" title=\"iframe hash or name\"></a>iframe hash or name</h2><p>这两种方式都差不多，将需要跨域的域通过iframe的方式加载，通过name或hash值的设置来达到跨域的目的。不太常用，仅做了解不做详细说明，具体可看例子中的<code>3.js</code>和<code>4.js</code>这两个文件</p>\n<h2 id=\"postMessage\"><a href=\"#postMessage\" class=\"headerlink\" title=\"postMessage\"></a>postMessage</h2><p>postMessage是html5引入的API,允许来自不同源的脚本采用异步方式进行有效的通信,可以实现跨文本文档,多窗口,跨域消息传递,具体实现方式如下。</p>\n<p><strong>父窗体创建跨域iframe并发送信息</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"X-UA-Compatible\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"IE=edge\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>跨域POST消息发送<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/JavaScript\"</span>&gt;</span><span class=\"undefined\">    </span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// sendPost 通过postMessage实现跨域通信将表单信息发送到 moweide.gitcafe.io上,</span></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// 并取得返回的数据    </span></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sendPost</span>(<span class=\"params\"></span>) </span>&#123;        </span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"comment\">// 获取id为otherPage的iframe窗口对象        </span></span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">var</span> iframeWin = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"otherPage\"</span>).contentWindow;        </span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"comment\">// 向该窗口发送消息        </span></span></span><br><span class=\"line\"><span class=\"javascript\">                iframeWin.postMessage(<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"message\"</span>).value, </span></span><br><span class=\"line\"><span class=\"javascript\">                    <span class=\"string\">'http://moweide.gitcafe.io'</span>);    </span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;    </span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// 监听跨域请求的返回    </span></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">\"message\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;        </span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(event, event.data);    </span></span><br><span class=\"line\"><span class=\"javascript\">            &#125;, <span class=\"literal\">false</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">        </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">textarea</span> <span class=\"attr\">id</span>=<span class=\"string\">\"message\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">textarea</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"发送\"</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"sendPost()\"</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">iframe</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">src</span>=<span class=\"string\">\"http://moweide.gitcafe.io/other-domain.html\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"otherPage\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">style</span>=<span class=\"string\">\"display:none\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">iframe</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>子窗体接收信息并处理</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">    &lt;head&gt;</span><br><span class=\"line\">        &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class=\"line\">        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class=\"line\">        &lt;title&gt;POST Handler&lt;/title&gt;</span><br><span class=\"line\">        &lt;script src=&quot;//code.jquery.com/jquery-1.11.0.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">        &lt;script type=&quot;text/JavaScript&quot;&gt;</span><br><span class=\"line\">            window.addEventListener(&quot;message&quot;, function( event ) &#123;</span><br><span class=\"line\">                // 监听父窗口发送过来的数据向服务器发送post请求</span><br><span class=\"line\">                var data = event.data;</span><br><span class=\"line\">                $.ajax(&#123;</span><br><span class=\"line\">                    // 注意这里的url只是一个示例.实际练习的时候你需要自己想办法提供一个后台接口</span><br><span class=\"line\">                    type: &apos;POST&apos;, </span><br><span class=\"line\">                    url: &apos;http://moweide.gitcafe.io/getData&apos;,</span><br><span class=\"line\">                    data: &quot;info=&quot; + data,</span><br><span class=\"line\">                    dataType: &quot;json&quot;</span><br><span class=\"line\">                &#125;).done(function(res)&#123;        </span><br><span class=\"line\">                    //将请求成功返回的数据通过postMessage发送给父窗口        </span><br><span class=\"line\">                    window.parent.postMessage(res, &quot;*&quot;);    </span><br><span class=\"line\">                &#125;).fail(function(res)&#123;        </span><br><span class=\"line\">                    //将请求失败返回的数据通过postMessage发送给父窗口        </span><br><span class=\"line\">                    window.parent.postMessage(res, &quot;*&quot;);    </span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;, false);</span><br><span class=\"line\">        &lt;/script&gt;</span><br><span class=\"line\">    &lt;/head&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;body&gt;&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p><code>js</code>的语言特性导致有很多知识点在日常开发中容易混淆或者难理解的，在此通过代码示例和文字总结加深理解，同时也方便后续复习查阅</p>\n<h1 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h1><p>与其它语言相比，函数的<code>this</code>关键字在<code>javascript</code>中表现略不同。此外，在严格模式、非严格模式及<code>es2015</code>的箭头函数中也各有不同。</p>\n<p><strong> 一般情况下（箭头函数除外）,<code>this</code>的指向与声明位置无关，与调用位置有关 </strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name=<span class=\"string\">\"window\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj=&#123;</span><br><span class=\"line\">  name:<span class=\"string\">'obj'</span>,</span><br><span class=\"line\">  showName:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> otherObj=&#123;</span><br><span class=\"line\">  name:<span class=\"string\">'otherObj'</span>,</span><br><span class=\"line\">  showName:obj.showName</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.showName(); <span class=\"comment\">//obj</span></span><br><span class=\"line\">otherObj.showName();<span class=\"comment\">//otherObj</span></span><br></pre></td></tr></table></figure>\n<p class=\"tip\"><br>  此时调用<code>showName</code>方法的是<code>obj</code>，故<code>this</code>指向<code>obj</code><br></p>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> anotherObj=&#123;</span><br><span class=\"line\">  name:<span class=\"string\">'anotherObj'</span>,</span><br><span class=\"line\">  showName:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//tempFunc =function()&#123;console.log(this.name)&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> tempFunc=obj.showName;</span><br><span class=\"line\">    tempFunc();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> anonymousObj=&#123;</span><br><span class=\"line\">  name:<span class=\"string\">'anonymousObj'</span>,</span><br><span class=\"line\">  foo:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  showName:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//this.foo=function()&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//   console.log(this.name)</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// cb=this.foo,cb是一个匿名函数，</span></span><br><span class=\"line\">    <span class=\"comment\">// 匿名函数在执行时，this也是指向window</span></span><br><span class=\"line\">    (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">cb</span>)</span>&#123;</span><br><span class=\"line\">      cb();</span><br><span class=\"line\">    &#125;)(<span class=\"keyword\">this</span>.foo)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">anotherObj.showName() ;<span class=\"comment\">//undefined</span></span><br><span class=\"line\">anonymousObj.showName();<span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure>\n<p class=\"tip\"><br>  1. 在<code>anotherObj</code>的作用域中调用的<code>tempFunc</code>，<code>tempFunc</code>中的<code>this</code>无明确指向，故指向<code>window</code><br>  2. 在<code>anonymousObj</code>的作用域中执行匿名函数，this也是指向window<br></p>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj=&#123;</span><br><span class=\"line\">  name:<span class=\"string\">'obj'</span>,</span><br><span class=\"line\">  showName:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> anotherObj=&#123;</span><br><span class=\"line\">  name:<span class=\"string\">'anotherObj'</span>,</span><br><span class=\"line\">  showName:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tempFunc=obj.showName;</span><br><span class=\"line\">    tempFunc();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.showName.apply();<span class=\"comment\">//undefined 此时虽然时obj调用showName方法</span></span><br><span class=\"line\">obj.showName.apply(anotherObj); <span class=\"comment\">//anotherObj</span></span><br></pre></td></tr></table></figure>\n<p class=\"tip\"><br>  <code>apply</code>可以改变<code>this</code>的指向为第一个参数<br>  故在<code>obj.showName.apply()</code>中this指向空，即window<br>  在<code>obj.showName.apply(anotherObj)</code>中this指向空anotherObj<br></p>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arrowObj=&#123;</span><br><span class=\"line\">  name:<span class=\"string\">'arrowObj'</span>,</span><br><span class=\"line\">  showName:<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//this 指向undefined（即全局对象window），具体可查看babel转义后的结果</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name); </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arrowObj1=&#123;</span><br><span class=\"line\">  name:<span class=\"string\">'arrowObj1'</span>,</span><br><span class=\"line\">  showName:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;,<span class=\"number\">0</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">arrowObj.showName();<span class=\"comment\">//undefined</span></span><br><span class=\"line\">arrowObj1.showName(); <span class=\"comment\">//'arrowObj1'</span></span><br></pre></td></tr></table></figure>\n<p class=\"tip\"><br>  在es6中，箭头函数（又称lamdba表达式），是在声明的时候绑定this的而非调用时<br></p>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"meta\">  \"use strict\"</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> name=<span class=\"string\">'snowdrop'</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name); <span class=\"comment\">//Uncaught TypeError: Cannot read property 'name' of undefined  </span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.assert(fun() === <span class=\"literal\">undefined</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.assert(fun.apply(<span class=\"literal\">null</span>) === <span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.assert(fun.call(<span class=\"literal\">undefined</span>) === <span class=\"literal\">undefined</span>);</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n<p class=\"tip\"><br>  在严格模式和非严格模式下，this的指向还略有不同<br>  从上述结果可知，严格模式下，this没有明确指向时,指向undefinde而非window<br></p>\n\n<p><strong>从上述代码片段及运行结果可得知，<code>this</code>有以下特性（坑）</strong></p>\n<ul>\n<li>this 的指向和调用位置有关，与声明位置无关</li>\n<li>没有明确指向的时候，this指向window</li>\n<li>在浏览器环境下，setTimeout、setInterval和匿名函数执行时this的指向为全局对象window</li>\n<li>call和apply能够强制改变this的指向为当前的第一个传参</li>\n<li>在es6中，箭头函数（又称lamdba表达式），是在声明的时候绑定this的</li>\n<li>严格模式下，this没有明确指向时,指向undefinde而非window</li>\n</ul>\n<h1 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h1><p>js中的作用域也是一个非常重要和易出错的地方，话不多说，先上代码</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo();<span class=\"comment\">//undefined</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">   <span class=\"keyword\">var</span> a=<span class=\"number\">2</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p class=\"tip\"><br>上面的代码在执行时别js引擎解析成如下的代码<br><code>function foo(){\n  var a;//undefined\n  console.log(a);\n  a=2; \n}\nfoo();</code><br></p>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show();//TypeError: show is not a function</span><br><span class=\"line\">var show=function ()&#123;</span><br><span class=\"line\">  console.log(1)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p class=\"tip\"><br>上面代码等价与下面<br><code>var show;//undefined\nshow ();\nshow=function (){\n  console.log(1)\n}</code><br></p>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> show; <span class=\"comment\">// function  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> show=<span class=\"number\">11</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'show'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p class=\"tip\"><br>上面代码等价于以下代码<br>function show(){<br>  console.log(‘show’)<br>}<br>var show=11;<br>typeof show;<br>故由此可知，函数的变量提升优于变量<br></p>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(someVar ===undefined)&#123;</span><br><span class=\"line\">  var someVar=1;</span><br><span class=\"line\">  console.log(someVar)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p class=\"tip\"><br>虽然此处有<code>if</code>,但js中没有块级作用域的概念，变量<code>someVar</code>依然也会发生作用域提升。<br></p>\n\n<p><strong>从上述代码片段及运行结果可得知，js的作用域有以下特性</strong></p>\n<ul>\n<li>函数和变量的声明都会产生作用域提升</li>\n<li>变量的上升只是声明会提升，赋值不会</li>\n<li>函数表达式（包括匿名和具名）不会发生作用域提升</li>\n<li>函数提升的优先级高于变量，且不会被同名变量覆盖</li>\n<li>声明的提升不会被条件判断给控制住（不过不同浏览器的实现不同，有的会控制有的不会控制）</li>\n</ul>\n<h1 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h1><p><em>TODO 此部分还有很多没理解，待深究</em></p>\n<h2 id=\"es6中的继承特性\"><a href=\"#es6中的继承特性\" class=\"headerlink\" title=\"es6中的继承特性\"></a><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes\" target=\"_blank\" rel=\"noopener\">es6中的继承特性</a></h2><ul>\n<li>使用extends关键字</li>\n<li>子类继承父类时，子类的构造函数需要显式的调用下父类的super方法</li>\n<li>可以定义static方法</li>\n</ul>\n<h2 id=\"ES5实现继承的黑魔法\"><a href=\"#ES5实现继承的黑魔法\" class=\"headerlink\" title=\"ES5实现继承的黑魔法\"></a><a href=\"http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html\" target=\"_blank\" rel=\"noopener\">ES5实现继承的黑魔法</a></h2><h3 id=\"原型链继承\"><a href=\"#原型链继承\" class=\"headerlink\" title=\"原型链继承\"></a>原型链继承</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Super</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name=<span class=\"string\">'super'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Super.prototype.showName=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Sub</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name=<span class=\"string\">'sub'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age=<span class=\"number\">24</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Sub.prototype=<span class=\"keyword\">new</span> Super();</span><br><span class=\"line\">Sub.prototype.showAge=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.age)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p class=\"tip\"><br>原型链继承的缺点：父类的构造函数会在创建子类及实例化子类的时候分别各执行了一次，造成了内存的浪费<br></p>\n\n<h3 id=\"组合继承\"><a href=\"#组合继承\" class=\"headerlink\" title=\"组合继承\"></a>组合继承</h3><p>由于原型继承存在上述缺点，所有就有了组合继承，F是空对象，所以几乎不占内存<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">extend</span>(<span class=\"params\">Child, Parent</span>) </span>&#123;</span><br><span class=\"line\">　　　　<span class=\"keyword\">var</span> F = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">　　　　F.prototype = Parent.prototype;</span><br><span class=\"line\">　　　　Child.prototype = <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">　　　　Child.prototype.constructor = Child;</span><br><span class=\"line\">　　　　Child.uber = Parent.prototype;</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用的时候，方法如下</span></span><br><span class=\"line\">extend(Cat,Animal);</span><br><span class=\"line\"><span class=\"keyword\">var</span> cat1 = <span class=\"keyword\">new</span> Cat(<span class=\"string\">\"大毛\"</span>,<span class=\"string\">\"黄色\"</span>);</span><br><span class=\"line\">alert(cat1.species); <span class=\"comment\">// 动物</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h1><p>跨域的定义：协议&amp;域名&amp;端口有任何一个不相同，则称这两个域名是跨域的</p>\n<p>跨域的限制?</p>\n<ol>\n<li>Cookie、localstorage、indexDB无法读取</li>\n<li>DOM无法取得</li>\n<li>ajax网络请求无法发出</li>\n</ol>\n<p>常用的跨域方式有以下5种</p>\n<ul>\n<li>jsonp</li>\n<li>服务器请求头设置允许跨域</li>\n<li>iframe+hash传值</li>\n<li>iframe+name传值</li>\n<li>postMessage</li>\n</ul>\n<p>下面借助实现方式及细节来介绍下5种跨域方式，具体代码可参见<a href=\"https://github.com/snowlotus/homework/tree/master/learn-js/crossSite\" target=\"_blank\" rel=\"noopener\">github</a></p>\n<h2 id=\"jsonp\"><a href=\"#jsonp\" class=\"headerlink\" title=\"jsonp\"></a>jsonp</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义一个全局的回调方法</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.xxx = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'script'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//向服务器发起jsonp请求，传递约定好的callback参数</span></span><br><span class=\"line\">script.src = <span class=\"string\">'http://x.localhost.com:7001/json?callback=xxx'</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.appendChild(script)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.get(&apos;/json&apos;, app.jsonp(&#123; callback: &apos;callback&apos; &#125;), app.controller.json.index)</span><br></pre></td></tr></table></figure>\n<p class=\"tip\"><br>  在js中需要定义一个全局方法，方法名你和服务端约定好的callback方法名，方法体为拿到返回值后的执行逻辑<br>  在服务端代码（本处用node实现），接受callback请求，执行逻辑返回一个json数据<br>  该方法只支持get请求，即使使用jquery的jsonp方法，type设为POST，也会自动变为GET<br></p>\n\n<h2 id=\"Access-Control-Allow-Origin\"><a href=\"#Access-Control-Allow-Origin\" class=\"headerlink\" title=\"Access-Control-Allow-Origin\"></a>Access-Control-Allow-Origin</h2><p>本方式是在服务端配置针对某个域名的请求设置是否允许跨域，即可以在响应头中通过代码实现，也可以在如nginx服务器配置项中设置，本次以代码的方式加以说明</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = app =&gt; &#123;</span><br><span class=\"line\">  class CrosController extends app.Controller &#123;</span><br><span class=\"line\">    * index(req) &#123;</span><br><span class=\"line\">      // https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS</span><br><span class=\"line\">      /* comment:设置响应头Access-Control-Allow-Origin </span><br><span class=\"line\">      设置为* ，表示该资源可以被任意外域访问，</span><br><span class=\"line\">      但会导致浏览器cookie无法发送到服务器，即使配置Access-Control-Allow-Credentials：true 也不行 */</span><br><span class=\"line\"></span><br><span class=\"line\">      // this.ctx.set(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">      /* comment: </span><br><span class=\"line\">      如果我们想要 http://*.localhost.com 都支持跨域怎么办？</span><br><span class=\"line\">      首先肯定不能直接写this.ctx.set(&apos;Access-Control-Allow-Origin&apos;, &apos;http://*.localhost.com&apos;)</span><br><span class=\"line\">      这样只会对http://*.localhost.com 这个域名才跨域生效</span><br><span class=\"line\">      见上述正则</span><br><span class=\"line\">      */</span><br><span class=\"line\">      this.ctx.set(&apos;Access-Control-Allow-Origin&apos;, originReg(req.header.origin))</span><br><span class=\"line\"></span><br><span class=\"line\">      /* comment：如何把Cookie发到服务器？</span><br><span class=\"line\">      一方面要服务器同意，指定Access-Control-Allow-Credentials:true</span><br><span class=\"line\">      另一方面，开发者必须在AJAX请求中打开withCredentials属性。xhr.withCredentials = true;</span><br><span class=\"line\">      */</span><br><span class=\"line\">     this.ctx.set(&apos;Access-Control-Allow-Credentials&apos;,&apos;true&apos;)</span><br><span class=\"line\">      this.ctx.body = &#123; msg: &apos;hello world&apos; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return CrosController</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"iframe-hash-or-name\"><a href=\"#iframe-hash-or-name\" class=\"headerlink\" title=\"iframe hash or name\"></a>iframe hash or name</h2><p>这两种方式都差不多，将需要跨域的域通过iframe的方式加载，通过name或hash值的设置来达到跨域的目的。不太常用，仅做了解不做详细说明，具体可看例子中的<code>3.js</code>和<code>4.js</code>这两个文件</p>\n<h2 id=\"postMessage\"><a href=\"#postMessage\" class=\"headerlink\" title=\"postMessage\"></a>postMessage</h2><p>postMessage是html5引入的API,允许来自不同源的脚本采用异步方式进行有效的通信,可以实现跨文本文档,多窗口,跨域消息传递,具体实现方式如下。</p>\n<p><strong>父窗体创建跨域iframe并发送信息</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"X-UA-Compatible\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"IE=edge\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>跨域POST消息发送<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/JavaScript\"</span>&gt;</span><span class=\"undefined\">    </span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// sendPost 通过postMessage实现跨域通信将表单信息发送到 moweide.gitcafe.io上,</span></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// 并取得返回的数据    </span></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sendPost</span>(<span class=\"params\"></span>) </span>&#123;        </span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"comment\">// 获取id为otherPage的iframe窗口对象        </span></span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">var</span> iframeWin = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"otherPage\"</span>).contentWindow;        </span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"comment\">// 向该窗口发送消息        </span></span></span><br><span class=\"line\"><span class=\"javascript\">                iframeWin.postMessage(<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"message\"</span>).value, </span></span><br><span class=\"line\"><span class=\"javascript\">                    <span class=\"string\">'http://moweide.gitcafe.io'</span>);    </span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;    </span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">// 监听跨域请求的返回    </span></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">\"message\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;        </span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">console</span>.log(event, event.data);    </span></span><br><span class=\"line\"><span class=\"javascript\">            &#125;, <span class=\"literal\">false</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">        </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">textarea</span> <span class=\"attr\">id</span>=<span class=\"string\">\"message\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">textarea</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"发送\"</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"sendPost()\"</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">iframe</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">src</span>=<span class=\"string\">\"http://moweide.gitcafe.io/other-domain.html\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"otherPage\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">style</span>=<span class=\"string\">\"display:none\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">iframe</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>子窗体接收信息并处理</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">    &lt;head&gt;</span><br><span class=\"line\">        &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class=\"line\">        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class=\"line\">        &lt;title&gt;POST Handler&lt;/title&gt;</span><br><span class=\"line\">        &lt;script src=&quot;//code.jquery.com/jquery-1.11.0.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">        &lt;script type=&quot;text/JavaScript&quot;&gt;</span><br><span class=\"line\">            window.addEventListener(&quot;message&quot;, function( event ) &#123;</span><br><span class=\"line\">                // 监听父窗口发送过来的数据向服务器发送post请求</span><br><span class=\"line\">                var data = event.data;</span><br><span class=\"line\">                $.ajax(&#123;</span><br><span class=\"line\">                    // 注意这里的url只是一个示例.实际练习的时候你需要自己想办法提供一个后台接口</span><br><span class=\"line\">                    type: &apos;POST&apos;, </span><br><span class=\"line\">                    url: &apos;http://moweide.gitcafe.io/getData&apos;,</span><br><span class=\"line\">                    data: &quot;info=&quot; + data,</span><br><span class=\"line\">                    dataType: &quot;json&quot;</span><br><span class=\"line\">                &#125;).done(function(res)&#123;        </span><br><span class=\"line\">                    //将请求成功返回的数据通过postMessage发送给父窗口        </span><br><span class=\"line\">                    window.parent.postMessage(res, &quot;*&quot;);    </span><br><span class=\"line\">                &#125;).fail(function(res)&#123;        </span><br><span class=\"line\">                    //将请求失败返回的数据通过postMessage发送给父窗口        </span><br><span class=\"line\">                    window.parent.postMessage(res, &quot;*&quot;);    </span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;, false);</span><br><span class=\"line\">        &lt;/script&gt;</span><br><span class=\"line\">    &lt;/head&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;body&gt;&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>"},{"title":"React native简介","date":"2019-11-06T06:59:36.000Z","summary":"React native简介","_content":"\n\n### 开发前准备\n\n","source":"_posts/intro-of-react-native.md","raw":"---\ntitle: React native简介\ndate: 2019-11-06 14:59:36\ntags: [react native,react,jsx,es6]\nsummary: React native简介\n\n---\n\n\n### 开发前准备\n\n","slug":"intro-of-react-native","published":1,"updated":"2019-11-06T02:44:53.422Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2mojn8h0000e347cw4e0y2o","content":"<h3 id=\"开发前准备\"><a href=\"#开发前准备\" class=\"headerlink\" title=\"开发前准备\"></a>开发前准备</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"开发前准备\"><a href=\"#开发前准备\" class=\"headerlink\" title=\"开发前准备\"></a>开发前准备</h3>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ck2mo4mxf0006dt47ep1xxctf","tag_id":"ck2mo4mxb0003dt47lprpkyci","_id":"ck2mo4mxi0009dt47l18m49ml"},{"post_id":"ck2mo4mx00000dt47cd1hqdcx","tag_id":"ck2mo4mxb0003dt47lprpkyci","_id":"ck2mo4mxp000fdt470xvcm26u"},{"post_id":"ck2mo4mx00000dt47cd1hqdcx","tag_id":"ck2mo4mxg0007dt4754ibf9sl","_id":"ck2mo4mxq000gdt47wxu2w6ur"},{"post_id":"ck2mo4mx00000dt47cd1hqdcx","tag_id":"ck2mo4mxj000bdt470taojxi9","_id":"ck2mo4mxq000idt4731n5vklj"},{"post_id":"ck2mo4mx90002dt47zf6mduef","tag_id":"ck2mo4mxb0003dt47lprpkyci","_id":"ck2mo4mxq000jdt47djqyt0kp"},{"post_id":"ck2mo4mxd0004dt47g4sjjzn1","tag_id":"ck2mo4mxq000hdt47yyj3o743","_id":"ck2mo4mxr000mdt47ggymwuui"},{"post_id":"ck2mo4mxd0004dt47g4sjjzn1","tag_id":"ck2mo4mxq000kdt4759wkooot","_id":"ck2mo4mxr000ndt47au2lf0hw"},{"post_id":"ck2mo4mxe0005dt47jqler9ti","tag_id":"ck2mo4mxr000ldt47g9axls3r","_id":"ck2mo4mxu000rdt47pgbnio2u"},{"post_id":"ck2mo4mxe0005dt47jqler9ti","tag_id":"ck2mo4mxs000odt471gs9zr2f","_id":"ck2mo4mxu000sdt479ehmpakg"},{"post_id":"ck2mo4mxe0005dt47jqler9ti","tag_id":"ck2mo4mxt000pdt47ymooyy5v","_id":"ck2mo4mxu000udt47k0y3onpc"},{"post_id":"ck2mo4mxh0008dt47cniwcjhx","tag_id":"ck2mo4mxt000qdt474acurnqp","_id":"ck2mo4mxu000wdt47mebbf2a8"},{"post_id":"ck2mo4mxh0008dt47cniwcjhx","tag_id":"ck2mo4mxu000tdt475kcazfpm","_id":"ck2mo4mxu000xdt47ncj8905g"},{"post_id":"ck2mo4mxi000adt47plfrassl","tag_id":"ck2mo4mxu000vdt47kwet7een","_id":"ck2mo4mxw0011dt47txe5l3xs"},{"post_id":"ck2mo4mxi000adt47plfrassl","tag_id":"ck2mo4mxv000ydt47gjah2kxh","_id":"ck2mo4mxw0012dt47d814cgqp"},{"post_id":"ck2mo4mxi000adt47plfrassl","tag_id":"ck2mo4mxv000zdt475p8ockvq","_id":"ck2mo4mxx0014dt47mui4p0ze"},{"post_id":"ck2mo4mxk000cdt47yg157amy","tag_id":"ck2mo4mxs000odt471gs9zr2f","_id":"ck2mo4mxx0015dt47j22x5fqa"},{"post_id":"ck2mo4mxl000ddt47fqhugyxf","tag_id":"ck2mo4mxs000odt471gs9zr2f","_id":"ck2mo4mxx0016dt475nbs7hid"},{"post_id":"ck2mo4mya0017dt472yiu8675","tag_id":"ck2mo4mye001bdt479jpjqmbz","_id":"ck2mo4myj001fdt478l6tncjb"},{"post_id":"ck2mo4mya0017dt472yiu8675","tag_id":"ck2mo4mxt000qdt474acurnqp","_id":"ck2mo4myj001gdt47750ldl01"},{"post_id":"ck2mo4myc0019dt47tfxoxkly","tag_id":"ck2mo4mye001bdt479jpjqmbz","_id":"ck2mo4myk001idt47inrocyec"},{"post_id":"ck2mo4myc0019dt47tfxoxkly","tag_id":"ck2mo4mxt000qdt474acurnqp","_id":"ck2mo4myk001jdt47h7s6vss3"},{"post_id":"ck2mo4mye001cdt47wpiff9v3","tag_id":"ck2mo4myj001hdt47j6f393f6","_id":"ck2mo4myl001ldt470ywmba89"},{"post_id":"ck2mo4myf001ddt47bhbxc78b","tag_id":"ck2mo4myk001kdt47uarba496","_id":"ck2mo4myo001odt47czlfz0xr"},{"post_id":"ck2mo4myf001ddt47bhbxc78b","tag_id":"ck2mo4myl001mdt47dibgolb2","_id":"ck2mo4myp001pdt473ksn2cat"},{"post_id":"ck2mo4myf001ddt47bhbxc78b","tag_id":"ck2mo4mym001ndt475jonu3yx","_id":"ck2mo4myp001qdt47r6kl3jvx"},{"post_id":"ck2mojn8h0000e347cw4e0y2o","tag_id":"ck2mojn8n0001e34747v1b7p6","_id":"ck2mojn8u0005e347z851328y"},{"post_id":"ck2mojn8h0000e347cw4e0y2o","tag_id":"ck2mojn8s0002e347mxd8b3fe","_id":"ck2mojn8u0006e3477ujic34j"},{"post_id":"ck2mojn8h0000e347cw4e0y2o","tag_id":"ck2mojn8t0003e3475wit0nyg","_id":"ck2mojn8v0007e34759igxa4y"},{"post_id":"ck2mojn8h0000e347cw4e0y2o","tag_id":"ck2mojn8u0004e347nm9yh5ng","_id":"ck2mojn8v0008e347f8nf9lu4"}],"Tag":[{"name":"javascript","_id":"ck2mo4mxb0003dt47lprpkyci"},{"name":"性能","_id":"ck2mo4mxg0007dt4754ibf9sl"},{"name":"监控","_id":"ck2mo4mxj000bdt470taojxi9"},{"name":"CSS","_id":"ck2mo4mxq000hdt47yyj3o743"},{"name":"面试","_id":"ck2mo4mxq000kdt4759wkooot"},{"name":"mpvue","_id":"ck2mo4mxr000ldt47g9axls3r"},{"name":"vue","_id":"ck2mo4mxs000odt471gs9zr2f"},{"name":"小程序","_id":"ck2mo4mxt000pdt47ymooyy5v"},{"name":"feelings","_id":"ck2mo4mxt000qdt474acurnqp"},{"name":"生活","_id":"ck2mo4mxu000tdt475kcazfpm"},{"name":"API","_id":"ck2mo4mxu000vdt47kwet7een"},{"name":"备忘单","_id":"ck2mo4mxv000ydt47gjah2kxh"},{"name":"sheet","_id":"ck2mo4mxv000zdt475p8ockvq"},{"name":"读书","_id":"ck2mo4mye001bdt479jpjqmbz"},{"name":"git merge rebase","_id":"ck2mo4myj001hdt47j6f393f6"},{"name":"学习笔记","_id":"ck2mo4myk001kdt47uarba496"},{"name":"js","_id":"ck2mo4myl001mdt47dibgolb2"},{"name":"知识梳理","_id":"ck2mo4mym001ndt475jonu3yx"},{"name":"react native","_id":"ck2mojn8n0001e34747v1b7p6"},{"name":"react","_id":"ck2mojn8s0002e347mxd8b3fe"},{"name":"jsx","_id":"ck2mojn8t0003e3475wit0nyg"},{"name":"es6","_id":"ck2mojn8u0004e347nm9yh5ng"}]}}